#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
#include <vector>
#include <cstdlib>
#include <limits>
#include <ctime>
#include <time.h>
#include <iomanip>
#include <list>
#include <algorithm>
#include <map>
#include <unordered_map>
#include <set>
#include <iomanip>
#include <random>
#include "Airplane.h"
#include "Airstrip.h"
#include "Passenger.h"
#include "Route.h"
#include "Node.h"
#include <float.h>
#include <chrono>
#include "Model.h"

using namespace std;

template<typename type>
struct MyCOMP {
	bool operator() (
		const type & first, const type & second) const {
		return first > second;
	}

};

template<typename type>
struct MyCOMP1 {
	bool operator() (
		const type & first, const type & second) const {
		return first < second;
	}

};


double Sum(vector<double> Weight) {
	double sum = 0;
	for (double i : Weight) sum += i;
	return sum;
}

double Accumulated(int j, vector<double> Weight) {
	double accum = 0.0;
	double sum = 0.0;
	for (double i : Weight) sum += i;
	for (double i = 0; i <= j; i++) accum += ((Weight[i]) / sum);
	return accum;
}

double Ob_Funct_Improvement(double newsolution, double oldsolution) {
	double rate_max_improvement = 10000;
	if (newsolution >= oldsolution) {
		return 0;
	}
	else {
		return ((oldsolution - newsolution) / rate_max_improvement);
	}
}

double Time_Spend(double time) {
	double rate_time = 20;
	return time / rate_time;

}


void stampo_caso_strano_single(Route r, map<string, double>& from_to, map<string, Airplane> map_airplane) {

	
	
		
		for (Passenger p : r.passengers_in_route) {
			if (r.places[p.solution_from] != p.departure_location || r.places[p.solution_to] != p.arrival_location) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON IL PASSEGGERO:" << endl;
				cout << " Sto chiamando questo codice dentro a Update di Route " << endl;
				p.print();
				cout << "nella route: " << endl;
				r.print();
				system("pause");
			}
		}
		




		for (int i = 1; i < r.index; i++) {

			if (r.time_arr[i] <= (((from_to[r.places[i - 1] + ";" + r.places[i]] / map_airplane[r.aircraft_code].speed) * 60) + r.time_dep[i - 1] - 1) || r.time_arr[i] >= (((from_to[r.places[i - 1] + ";" + r.places[i]] / map_airplane[r.aircraft_code].speed) * 60) + r.time_dep[i - 1] + 1)) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON i TEMPIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII nell arco " << (i - 1) << endl;
				cout << "dovrebbe essere: " << (((from_to[r.places[i - 1] + ";" + r.places[i]] / map_airplane[r.aircraft_code].speed) * 60) + r.time_dep[i - 1]) << " mentre invece è " << r.time_arr[i] << endl;
				r.print();
				system("pause");
			}


			double fly_time = (from_to[r.places[i - 1] + ";" + r.places[i]] / map_airplane[r.aircraft_code].speed);
			double fuel_consumed = 0.0;
			if (fly_time <= 1) {
				fuel_consumed = fly_time * map_airplane[r.aircraft_code].fuel_burn_first;
			}
			else {
				fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (fly_time - 1)* map_airplane[r.aircraft_code].fuel_burn_second;
			}

			if (!r.refueling[i]) {
				if ((r.quantity_fuel[i - 1] - r.quantity_fuel[i]) <= (fuel_consumed - 1) || (r.quantity_fuel[i - 1] - r.quantity_fuel[i]) >= (fuel_consumed + 1)) {
					cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON IL FUEL nell arco DA " << (i - 1) << " A " << i << endl;
					cout << "dovrebbe essere: " << fuel_consumed << " mentre invece è " << (r.quantity_fuel[i - 1] - r.quantity_fuel[i]) << endl;
					r.print();
					system("pause");
				}
			}






		}


		for (int i = 0; i < r.index - 1; i++) {
			if (r.quantity_fuel[i] < r.quantity_fuel[i + 1] && !r.refueling[i + 1] || r.weight[i] < 0) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' IL PROBLEMA O DEL FUEL CHE NON CALA O DEL PESO NEGATIVO" << endl;
				r.print();
				system("pause");
			}


			if (r.places[i] == r.places[i + 1]) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' IL PROBLEMA DI PIù POSTI UGUALI " << endl;
				r.print();
				system("pause");
			}


		}




		for (int i = 0; i < r.index; i++) {
			double peso_arco_passeggeri = 0.0;
			for (Passenger p : r.passengers_in_route) {
				if (p.solution_from <= i && p.solution_to > i) {
					peso_arco_passeggeri += p.weight;
				}
			}

			if ((r.quantity_fuel[i] + r.weight[i] + peso_arco_passeggeri) <= (map_airplane[r.aircraft_code].weight_fuel_people -1) || (r.quantity_fuel[i] + r.weight[i] + peso_arco_passeggeri) >= (map_airplane[r.aircraft_code].weight_fuel_people + 1)) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON IL PESO TOTALE NEL NODO " << i << " CON PESO TOTALE --> " + to_string(r.quantity_fuel[i] + r.weight[i] + peso_arco_passeggeri) << endl;
				r.print();
				system("pause");
			}
		}


		for (int i = 0; i < r.index - 1; i++) {
			double minimo_peso = r.weight[i];
			if (r.quantity_fuel[i] < map_airplane[r.aircraft_code].max_fuel && r.refueling[i]) {
				for (int j = i + 1; j < r.index; j++) {
					if (r.refueling[j]) break;
					if (r.weight[j] < minimo_peso) minimo_peso = r.weight[j];
				}
				if (minimo_peso >= 1) {
					cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' IL PROBLEMA DEL FUEL NON MASSIMO *************************" << endl;
					r.print();
					system("pause");
				}

			}
		}









}



//function of split
vector<string> split(string stringa, char separatore) {
	vector<string> words;
	stringstream ss(stringa);
	string individual_string;
	while (getline(ss, individual_string, separatore)) {
		words.push_back(individual_string);
	}

	return words;
}

//function that read the file Airplane and create a vector of them
vector<Airplane> fillAirplane(string file_input) {

	vector<Airplane> airplanes;
	ifstream  file;
	file.open(file_input);
	//check for error
	if (file.fail()) {
		cerr << "Error Opening File Airplane.csv" << endl;
		exit(1);
	}
	//read the file untill the end
	while (!file.eof()) {
		string row;
		getline(file, row);
		vector<string> e = split(row, ';');
		Airplane a(e[1], stoi(e[6]), stod(e[5]), e[0], stoi(e[3]), stoi(e[4]), e[7], stod(e[10]), stoi(e[8]), stoi(e[9]), stod(e[11]), stod(e[12]));
		airplanes.push_back(a);
	}
	file.close();

	return airplanes;
};

//function that read the file Airstrip and create a vector of them
vector<Airstrip> fillAirstrip(string file_input) {

	vector<Airstrip> airstrips;
	ifstream file;
	file.open(file_input);
	if (file.fail()) {
		cerr << "Error Opening File Airstrip.csv" << endl;
		exit(1);
	}
	while (!file.eof()) {
		string row;
		getline(file, row);
		vector<string> e = split(row, ';');
		bool fuel = false;
		if (e[6] == "1") fuel = true;
		Airstrip a(e[0], e[1], stoi(e[2]), stoi(e[3]), stod(e[4]), stod(e[5]), fuel, stod(e[7]));
		airstrips.push_back(a);
	}
	file.close();

	return airstrips;
}

//function that read the file instance and create a vector of passenger
vector<Passenger> fillPassenger(string file_input) {

	vector<Passenger> passengers;
	ifstream file;
	file.open(file_input);
	if (file.fail()) {
		cerr << "Error Opening File Airstrip.csv" << endl;
		exit(1);
	}
	while (!file.eof()) {
		string row;
		getline(file, row);
		vector<string> e = split(row, ';');
		int min_dep;
		int min_arr;
		if (e[9] != "Charter") {
			vector<string> dep_min = split(e[9], ':');
			min_dep = (stoi(dep_min[0]) * 60) + stoi(dep_min[1]);
			vector<string> arr_min = split(e[10], ':');
			min_arr = (stoi(arr_min[0]) * 60) + stoi(arr_min[1]);
		}
		else {
			min_arr = 0;
			min_dep = 0;
		}
		Passenger p(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], min_dep, min_arr);
		passengers.push_back(p);

	}
	file.close();

	return passengers;
}
//function that read the file instance and create a vector of routes
vector<Route> fillRoute(string file_input) {

	vector<Route> routes;
	ifstream file;
	file.open(file_input);
	if (file.fail()) {
		cerr << "Error Opening File" << file_input << endl;
		exit(1);
	}
	while (!file.eof()) {
		string row;
		getline(file, row);
		vector<Passenger> Pass;
		vector<string> e = split(row, ';');
		Route r(e[1], Pass);
		for (int i = 2; i < e.size() - 1; i = i + 2) {
			r.addPlace_companySolution(e[i], stoi(e[i + 1]));
		}
		routes.push_back(r);
	}
	file.close();

	return routes;
}



map<string, double> fill_from_to_fuel_consumed(map<string, double>& from_to, vector<Airplane> airplanes) {
	
	map<string, double> from_to_fuel_consumed;

	for (Airplane a : airplanes) {
		for (auto x : from_to) {
			double time_fly = x.second / a.speed;
			double fuel_consumed = 0.0;
			if (time_fly <= 1) {
				fuel_consumed = time_fly * a.fuel_burn_first;
			}
			else {
				fuel_consumed = a.fuel_burn_first + (time_fly-1) * a.fuel_burn_second;
			}
			from_to_fuel_consumed.insert( make_pair(a.code+";"+x.first,fuel_consumed) );
			//cout << " da/a: " << x.second << " time fly: " << time_fly << " fuel consumed: " << fuel_consumed << endl;
		}
	}
	return from_to_fuel_consumed;
}

map <string, Passenger> fillMapPassenger(vector<Passenger> passengers){
	map <string, Passenger> map_pass;
	for(Passenger p: passengers)
	{
		map_pass.insert(make_pair(p.pnr, p));
	}



	return  map_pass;
}

map<string, double> fillMatrix(string file_input, vector<Airstrip> airstrips) {

	map<string, double> from_to;

	ifstream file;
	file.open(file_input);
	if (file.fail()) {
		cerr << "Error Opening File Matrix.csv" << endl;
		exit(1);
	}
	int index_row = 0;
	while (!file.eof()) {
		string row;
		getline(file, row);
		vector<string> e = split(row, ';');
		for (int i = 0; i < e.size(); i++) {
			istringstream is(e[i]);
			double d;
			is >> d;
			//cout << "String: " << e[i] << "\n";
			//cout << "Double: " << setprecision(14) << d << endl;
			from_to.insert(make_pair(airstrips[index_row].code + ";" + airstrips[i].code, d));
		}
		index_row++;
	}
	file.close();

	return from_to;
}

double calculationCostCompany(string route_azienza, string passengers_azienda, vector<Airstrip> airstrips, vector<Airplane> airplanes, vector<Passenger> passengers, map<string, double>& from_to) {
	vector<Route> routes_company_solution =  fillRoute(route_azienza);
	int costi_time_windows = 0;
	vector<double> cost_route;
	//build an hashmap of airstip where the key is the code of the airstip
	map<string, Airstrip> airstrips_map;
	for (int i = 0; i < airstrips.size(); i++) {
		airstrips_map.insert(make_pair(airstrips[i].code, airstrips[i]));
	}
	//look if the airstrips map are well saved
	//for (auto& x : airstrips_map)  x.second.print();

	map<string, Airplane> airplanes_map;
	for (int i = 0; i < airplanes.size(); i++) {
		airplanes_map.insert(make_pair(airplanes[i].code, airplanes[i]));
	}

	for (int r = 0; r < routes_company_solution.size(); r++) {
		double c = airplanes_map[routes_company_solution[r].aircraft_code].fixed_cost; //ho aggiunto il costo fisso
		//cout << airplanes_map[routes_company_solution[r].aircraft_code].fixed_cost ;
		string places = ";";
		for (int i = 0; i < routes_company_solution[r].places.size(); i++) {
			places += routes_company_solution[r].places[i] + ";";

			if (i >= 1) {
				//ho messo che parto da uno in modo tale da non considerare il leading cost del primo aereoporto
				//cout << " + " << airstrips_map[routes_company_solution[r].places[i]].landing_cost;
				c += airstrips_map[routes_company_solution[r].places[i]].landing_cost; //aggiungo il leading cost
			}

			//aggiungo il costo dei kilometri e del fuel
			if (i < routes_company_solution[r].places.size() - 1) {
				//cout << routes_company_solution[r].places[i] << " ; " << routes_company_solution[r].places[i + 1] << endl;
				//cout << " + " << from_to[routes_company_solution[r].places[i] + ";" + routes_company_solution[r].places[i + 1]];
				c += from_to[routes_company_solution[r].places[i] + ";" + routes_company_solution[r].places[i + 1]];
				double time_flight = (from_to[routes_company_solution[r].places[i] + ";" + routes_company_solution[r].places[i + 1]]) / airplanes_map[routes_company_solution[r].aircraft_code].speed;
				//cout << " time flight: " << time_flight;
				double cost_fuel = 0;
				if (time_flight <= 1) {
					cost_fuel = time_flight * airplanes_map[routes_company_solution[r].aircraft_code].fuel_burn_first;
				}
				else {
					cost_fuel = airplanes_map[routes_company_solution[r].aircraft_code].fuel_burn_first + (time_flight - 1)*airplanes_map[routes_company_solution[r].aircraft_code].fuel_burn_second;
				}
				//cout << " + " << cost_fuel;
				c += cost_fuel;
			}
		}
		//cout << endl;
		//cout << places << endl;


		//ora devo leggere i passeggeri_soluzione******************************************************************************************
		cost_route.push_back(c);
	}


	double costo_routing = 0.0;
	for (double c : cost_route) costo_routing += c;
	cout << "Costo Routing per la compagnia: " << costo_routing << endl;



	vector<Passenger> passengers_solution; //il code_flight qui è l'aereo
	ifstream file;
	file.open(passengers_azienda);
	if (file.fail()) {
		cerr << "Error Opening File passenger azienda" << endl;
		exit(1);
	}
	while (!file.eof()) {
		string row;
		getline(file, row);
		vector<string> e = split(row, ';');
		int min_dep;
		int min_arr;
		if (e[2] != "Charter") {
			vector<string> dep_min = split(e[4], ':');
			min_dep = (stoi(dep_min[0]) * 60) + stoi(dep_min[1]);
			vector<string> arr_min = split(e[5], ':');
			min_arr = (stoi(arr_min[0]) * 60) + stoi(arr_min[1]);
		}
		else {
			min_arr = 0;
			min_dep = 0;
		}
		Passenger p("", e[0], "", e[2], e[3], "", e[1], "", "", min_dep, min_arr);
		passengers_solution.push_back(p);

	}
	file.close();
	//***********************************************************************************************************************************
	//calcolo matrice A e costo della penalità per essere fuori dall'orario previsto
	for (int p = 0; p < passengers.size(); p++) {
		int c = 0; //costo_time_windows
		size_t trovato_pass;
		int controllo = 0;
		vector<Passenger> pass_trovato;
		transform(passengers[p].name.begin(), passengers[p].name.end(), passengers[p].name.begin(), ::tolower);
		//cout << "- " << passengers[p].name << endl;

		for (int j = 0; j < passengers_solution.size(); j++) {
			trovato_pass = passengers_solution[j].name.find(passengers[p].name);
			if (trovato_pass <= passengers_solution[j].name.size()) {
				pass_trovato.push_back(passengers_solution[j]);
				controllo += 1;
			}
			/*else {
				cout << " Non ho trovato il passeggiero " << endl;
				passengers[p].print();
				system("pause");
			}*/
		}
		if (controllo >= 1) {
			//vuol dire che ho trovato il passeggero
			//controllo se trovo l'andata
			for (int z = 0; z < pass_trovato.size(); z++) {
				if (pass_trovato[z].departure_location == passengers[p].departure_location) {
					//calcolo la time windows
					int differenza_dep = passengers[p].departure_time - pass_trovato[z].departure_time;
					if (differenza_dep > 25) {

						//cout << " + " << passengers[p].departure_time - routes[r].time[index_dep] - 25;
						c += differenza_dep - 25;
					}

					if (differenza_dep < -5) {
						//cout << " + " << (passengers[p].departure_time - routes[r].time[index_dep] + 5)*(-1);
						c += (differenza_dep + 5)*(-1);
					}
					//cout << "- time: " << c << endl;
				}
				if (pass_trovato[z].arrival_location == passengers[p].arrival_location) {
					//calcolo la time windows
					int differenza_arr = passengers[p].arrival_time - pass_trovato[z].arrival_time;
					if (differenza_arr > 30) {
						//cout << " + " << passengers[p].arrival_time - routes[r].time[index_arr] - 30;
						c += differenza_arr - 30;
					}
					if (differenza_arr < 0) {
						//cout << " + " << (passengers[p].arrival_time - routes[r].time[index_arr])*(-1);
						c += (differenza_arr)*(-1);
					}

					//cout << "- time: " << c << endl;
				}
			}
		}


		costi_time_windows += c;
	}
	double costo_Soluzione = costi_time_windows;
	for (int i = 0; i < cost_route.size(); i++) {
		costo_Soluzione += cost_route[i];
		//cout << "->" << cost_route[i] << endl;
	}
	//cout << "the cost of the company solution is:   " << costo_Soluzione << endl;
	//cout << endl;
	cout << "costo delle time windows per la compagnia: " << costi_time_windows << endl;

	return costo_Soluzione;


};

double cost_single_route(Route r, map<string, Airstrip>& map_airstrip, map<string, Airplane>& map_airplane, map<string, double>& from_to, map<string, double>& from_to_FuelConsumed) {

	double cost = 0.0;
	cost += map_airplane[r.aircraft_code].fixed_cost;
	for (int i = 1; i < r.index; i++) cost += map_airstrip[r.places[i]].landing_cost;

	//second of all calculate the cost of the Km and the fuel burn
	double mileage = 0.0;
	double fuel_consumed = 0.0;
	//double first_hour = 0.0;
	//double second_hour = 0.0;
	for (int i = 0; i < r.index - 1; i++) {
		//double time_travel = 0.0;
		if (i == 0 && r.capacity[i] == 0) {
			mileage = 0.0;
		}
		else {
			mileage += from_to[r.places[i] + ";" + r.places[i + 1]];
			//time_travel = from_to[r.places[i] + ";" + r.places[i + 1]] / map_airplane[r.aircraft_code].speed;
			fuel_consumed += from_to_FuelConsumed[r.aircraft_code + ";" + r.places[i] + ";" + r.places[i + 1]];
		}

		/*
		if (time_travel <= 1) {
			first_hour += time_travel;
		}
		else {
			first_hour += 1;
			second_hour += (time_travel - 1);
		}
		*/
	}
	cost += mileage;
	//cost += first_hour * map_airplane[r.aircraft_code].fuel_burn_first + second_hour * map_airplane[r.aircraft_code].fuel_burn_second;
	cost += fuel_consumed;

	for (auto p : r.passengers_in_route) {
		
		//double time_departure = r.time_arr[p.solution_from];
		//double time_arrival = r.time_arr[p.solution_to];
		double TW_departure = 0.0;
		if (r.time_arr[p.solution_from] < p.early_departure) TW_departure = p.early_departure - r.time_arr[p.solution_from];
		if (r.time_arr[p.solution_from] > p.late_departure) TW_departure = r.time_arr[p.solution_from] - p.late_departure;
		double TW_arrival = 0.0;
		if (r.time_arr[p.solution_to] < p.early_arrival) TW_arrival = p.early_arrival - r.time_arr[p.solution_to];
		if (r.time_arr[p.solution_to] > p.late_arrival) TW_arrival = r.time_arr[p.solution_to] - p.late_arrival;
		cost += TW_departure + TW_arrival;
	}

	return cost;
}

double calculate_ObjectiveFunction(vector<Route>& solution, map<string, Airstrip>& map_airstrip, map<string, Airplane>& map_airplane, map<string, double>& from_to, map<string, double>& from_to_FuelConsumed) {
	double cost = 0.0;

	for (auto& r : solution) {
		double cost_route = 0.0;
		//cout << "Route-----" << endl;
		//first of all calculate the fixed cost of use the aircraft and the landing cost;
		cost += map_airplane[r.aircraft_code].fixed_cost;
		cost_route += map_airplane[r.aircraft_code].fixed_cost;
		//cout << "costo fisso: " << cost << endl;
		for (int i = 1; i < r.index; i++) {
			cost += map_airstrip[r.places[i]].landing_cost;
			cost_route += map_airstrip[r.places[i]].landing_cost;
		}
		//cout << "costo landing: " << cost << endl;



		//second of all calculate the cost of the Km and the fuel burn
		double mileage = 0.0;
		//double first_hour = 0.0;
		//double second_hour = 0.0;
		double fuel_consumed = 0.0;
		for (int i = 0; i < r.index - 1; i++) {
			//double time_travel = 0.0;
			if (i == 0 && r.capacity[i] == 0) {
				mileage = 0.0;
			}
			else {
				mileage += from_to[r.places[i] + ";" + r.places[i + 1]];
				//time_travel = from_to[r.places[i] + ";" + r.places[i + 1]] / map_airplane[r.aircraft_code].speed;
				fuel_consumed += from_to_FuelConsumed[r.aircraft_code + ";" + r.places[i] + ";" + r.places[i + 1]];
			}

			/*
			if (time_travel <= 1) {
				first_hour += time_travel;
			}
			else {
				first_hour += 1;
				second_hour += (time_travel - 1);
			}
			*/
		}
		//now i add the mileage and the fuel consumption to the objective function
		cost += mileage;
		cost_route += mileage;
		//cout << "costo milege: " << cost << endl;
		//cost += first_hour * map_airplane[r.aircraft_code].fuel_burn_first + second_hour * map_airplane[r.aircraft_code].fuel_burn_second;
		cost += fuel_consumed;
		//cost_route += first_hour * map_airplane[r.aircraft_code].fuel_burn_first + second_hour * map_airplane[r.aircraft_code].fuel_burn_second;
		cost_route += fuel_consumed;
		//cout << "costo fuel: " << cost << endl;
		//now i have to calculate the penalitis regarding the time windows for each passeger
		for (auto p : r.passengers_in_route) {
			double time_departure = r.time_arr[p.solution_from];
			double time_arrival = r.time_arr[p.solution_to];

			double TW_departure = 0.0;
			if (time_departure < p.early_departure) TW_departure = p.early_departure - time_departure;
			if (time_departure > p.late_departure) TW_departure = time_departure - p.late_departure;

			double TW_arrival = 0.0;
			if (time_arrival < p.early_arrival) TW_arrival = p.early_arrival - time_arrival;
			if (time_arrival > p.late_arrival) TW_arrival = time_arrival - p.late_arrival;

			cost += TW_departure + TW_arrival;
			cost_route += TW_departure + TW_arrival;
		}
		//cout << "costo timeW: " << cost << endl;
		//cout << "The cost: " << cost << endl;
		//cout << "- " << cost_route << endl;
		r.cost = cost_route;
	}

	return cost;
}

double cost_time_windows_for_route(Route r) {
	double cost = 0.0;

	//cout << "*********************************************************dentro alla funzione*********************************************************" << endl;
	//cout << "indice del vettore degli arrivi " << r.time_arr.size();



	for (Passenger p : r.passengers_in_route) {
		//cout << " Indice from: " << p.solution_from << endl;
		//cout << " Indice to: " << p.solution_to << endl;
		//r.print();
		
		//double time_departure = r.time_arr[p.solution_from];
		//double time_arrival = r.time_arr[p.solution_to];

		double TW_departure = 0.0;
		if (r.time_arr[p.solution_from] < p.early_departure) TW_departure = p.early_departure - r.time_arr[p.solution_from];
		if (r.time_arr[p.solution_from] > p.late_departure) TW_departure = r.time_arr[p.solution_from] - p.late_departure;

		double TW_arrival = 0.0;
		if (r.time_arr[p.solution_to] < p.early_arrival) TW_arrival = p.early_arrival - r.time_arr[p.solution_to];
		if (r.time_arr[p.solution_to] > p.late_arrival) TW_arrival = r.time_arr[p.solution_to] - p.late_arrival;

		cost += TW_departure + TW_arrival;
	}

	//cout << "*********************************************************fine dentro funzione*********************************************************" << endl;


	return cost;
}

double cost_time_windows_for_node(Route r, vector<Passenger> pass) {
	double cost = 0.0;
	for (Passenger p : pass) {
		//double time_departure = r.time_arr[p.solution_from];
		//double time_arrival = r.time_arr[p.solution_to];

		double TW_departure = 0.0;
		if (r.time_arr[p.solution_from] < p.early_departure) TW_departure = p.early_departure - r.time_arr[p.solution_from];
		if (r.time_arr[p.solution_from] > p.late_departure) TW_departure = r.time_arr[p.solution_from] - p.late_departure;

		double TW_arrival = 0.0;
		if (r.time_arr[p.solution_to] < p.early_arrival) TW_arrival = p.early_arrival - r.time_arr[p.solution_to];
		if (r.time_arr[p.solution_to] > p.late_arrival) TW_arrival = r.time_arr[p.solution_to] - p.late_arrival;

		cost += TW_departure + TW_arrival;
	}

	return cost;
}

double cost_time_windows_for_route_passenger(Route r, Passenger p) {
	double cost = 0.0;
	
	//cout << "**************************************" << endl;
	//cout << "r.time_arr.size()" << r.time_arr.size();
	//p.print();
	
	//double time_departure = r.time_arr[p.solution_from];
	//double time_arrival = r.time_arr[p.solution_to];

	double TW_departure = 0.0;
	if (r.time_arr[p.solution_from] < p.early_departure) TW_departure = p.early_departure - r.time_arr[p.solution_from];
	if (r.time_arr[p.solution_from] > p.late_departure) TW_departure = r.time_arr[p.solution_from] - p.late_departure;

	double TW_arrival = 0.0;
	if (r.time_arr[p.solution_to] < p.early_arrival) TW_arrival = p.early_arrival - r.time_arr[p.solution_to];
	if (r.time_arr[p.solution_to] > p.late_arrival) TW_arrival = r.time_arr[p.solution_to] - p.late_arrival;

	cost += TW_departure + TW_arrival;

	return cost;
}

bool relateness_passenger(int trheshold, map<string, double> from_to, string idP, Passenger r, int i, vector<Passenger>& passengers_removed, vector<Passenger>& passengers, vector<Passenger> all_passenger, map<string, Passenger>& map_id_passenger) {
	//cout << " Sono dentro la funzione Relateness " << endl;
	//vector<string> Pass1 = split(idP, '/');
	// Poi questo for si potra togliere
	Passenger pass = map_id_passenger[idP];
	/*
	for (Passenger p : all_passenger) {
		//if (p.name == Pass1[0] && p.surname == Pass1[1] && p.pnr == Pass1[2] && p.code_flight == Pass1[3] && p.gender == Pass1[4] && p.arrival_location == Pass1[5] && p.departure_location == Pass1[6] && to_string(p.weight) == Pass1[7]) {
		if(p.pnr == idP){
			pass = p;
			break;
		}
	}
	*/
	//cout << " Il passeggiero da A di confronto " << endl;
	//pass.print();
	//cout << " Il passeggiero da B di confronto siamo al Numero " << i << endl;
	//r.print();
	// Questo poi va cambiato
	if (pass.name.size() == 0) {
		cout << " ******************************* ERRORE ***********************************" << endl;
		cout << " Problema con il passeggiero con Pnr: " << idP << endl;
		cin.get();
	}
	double Relateness = from_to[r.arrival_location + ";" + pass.arrival_location] + from_to[r.departure_location + ";" + pass.departure_location] + abs(r.arrival_time - pass.arrival_time) + abs(r.departure_time - pass.departure_time);
	//cout <<" Relateness ---> " << Relateness << "  Soglia " << trheshold <<endl;
	if (Relateness <= trheshold) {
		/*
		cout << " Sono dentro Releatensess---> Valore : " << Relateness <<  endl;
		cout << " Sono dentro Releatensess---> Dato il passeggiero : " << endl;
		pass.print();

		cout << " Sono dentro Releatensess---> Devo togliere il passeggiero " << endl;
		r.print();
		*/
		r.route_before = i;
		passengers_removed.push_back(r);
		passengers.erase(passengers.begin() + i);
		//cout << " Passeggieri dopo ha: " << passengers.size() << endl;
		return true;
	}
	else {
		return false;
	}

}




//*************************************************************************************COSTRUTTIVI************************************************************************
vector<Route> heuristic_costructive_second_fase(vector<Route> solution, double end_day) {
	vector<Route> sol;

	for (Route r : solution) {
		Route best_route = r;
		Route r_support = best_route;
		double best_cost = cost_time_windows_for_route(best_route);
		if (cost_time_windows_for_route(r) != 0) { //chiaramente cerco di migliorare la dove le timewindows non sono zero
			for (int i = 0; i < r.index - 1; i++) {  //ATTENTO, SECONDO ME QUA CI VUOLE UN MENO 1 oppure no!!!! se ci sono dei problemi BUTTA L'OCCCHIO QUA
				double wait_time = 0;
				if (i == 0) {
					do {
						for (int j = 0; j < r.index; j++) {
							r_support.time_arr[j] += 2;
							r_support.time_dep[j] += 2;
						}
						if (cost_time_windows_for_route(r_support) < best_cost && r_support.time_arr[r_support.index - 1] <= end_day) {
							best_route = r_support;
							best_cost = cost_time_windows_for_route(r_support);
						}
						wait_time += 2;  //prima c'era ++ per ottimizzare ho messo più due in modo da valutare ogni due minuti non ogni minuto
					} while (wait_time <= 60);
				}
				else {
					do {
						r_support.time_dep[i] += 2;
						for (int j = i + 1; j < r.index; j++) {
							r_support.time_arr[j] += 2;
							r_support.time_dep[j] += 2;
						}
						if (cost_time_windows_for_route(r_support) < best_cost  && r_support.time_arr[r_support.index - 1] <= end_day) {
							best_route = r_support;
							best_cost = cost_time_windows_for_route(r_support);
						}
						wait_time += 2;
					} while (wait_time <= 60);
				}
				r_support = best_route;
			}
		}
		sol.push_back(best_route);
	}
	return sol;
}

vector<Route> heuristic_costructive_second_fase_SP(vector<Route> solution, double end_day) {
	vector<Route> sol;

	for (Route r : solution) {
		Route best_route = r;
		Route r_support = best_route;
		double best_cost = cost_time_windows_for_route(best_route);
		if (cost_time_windows_for_route(r) != 0) { //chiaramente cerco di migliorare la dove le timewindows non sono zero
			for (int i = 0; i < r.index - 1; i++) {  //ATTENTO, SECONDO ME QUA CI VUOLE UN MENO 1 oppure no!!!! se ci sono dei problemi BUTTA L'OCCCHIO QUA
				double wait_time = 0;
				if (i == 0) {
					do {
						for (int j = 0; j < r.index; j++) {
							r_support.time_arr[j] += 2;
							r_support.time_dep[j] += 2;
						}
						if (cost_time_windows_for_route(r_support) < best_cost && r_support.time_arr[r_support.index - 1] <= end_day) {
							best_route = r_support;
							best_cost = cost_time_windows_for_route(r_support);
						}
						wait_time += 2;  //prima c'era ++ per ottimizzare ho messo più due in modo da valutare ogni due minuti non ogni minuto
					} while (wait_time <= 30);
				}
				else {
					do {
						r_support.time_dep[i] += 2;
						for (int j = i + 1; j < r.index; j++) {
							r_support.time_arr[j] += 2;
							r_support.time_dep[j] += 2;
						}
						if (cost_time_windows_for_route(r_support) < best_cost  && r_support.time_arr[r_support.index - 1] <= end_day) {
							best_route = r_support;
							best_cost = cost_time_windows_for_route(r_support);
						}
						wait_time += 2;
					} while (wait_time <= 30);
				}
				r_support = best_route;
			}
		}
		sol.push_back(best_route);
	}
	return sol;
}


vector<Route> heuristic_costructive_first_fase(vector<Airplane> airplanes, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, double start_day, double end_day, vector<Passenger> passengers, int number_of_aircraft, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {
	//creo i punti di partenza
	vector<Route> solution;
	int cont = 0;
	do {
		vector<Passenger> pass_in_solution;
		Route r(airplanes[cont].code, pass_in_solution);
		r.addPlace(airplanes[cont].depot, map_airstrip[airplanes[cont].depot].fuel, map_airplane[r.aircraft_code].max_fuel, 0.0, 0, 0.0, 0.0);
		solution.push_back(r);
		cont++;
	} while (cont < number_of_aircraft);

	for (auto p : passengers) {
		string situation = "Error";
		int best_route = -1; //index of the best route where can i put my passenger
		int best_from = -1;
		int best_to = -1;
		double best_cost = DBL_MAX;
		int i = 0;
		//cout << "- sto calcolando dove metttere il passeggero: " << p.name << endl;
		//qui calcolo solo dove mettere il passeggero
		for (auto r : solution) {
			if (r.primo_pass == false) {
				if (r.places[r.index - 1] == p.departure_location) {
					//in questo caso c'è solo lui nella route, il costo è dato dalla sua inserzione, quindi, chilometri, costo fisso per uso aereo e fuel
					double cost = map_airplane[r.aircraft_code].fixed_cost + from_to[p.departure_location + ";" + p.arrival_location];
					//double travel_time = from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[r.aircraft_code].speed;
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code+";"+p.departure_location + ";" + p.arrival_location];
					/*
					if (travel_time <= 1) {
						fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/

					cost += fuel_consumed;
					//per il check sul fuel:
					double fuel_after_trip = 0.0;
					fuel_after_trip = r.quantity_fuel[r.index - 1] - fuel_consumed;
					if (best_cost > cost && fuel_after_trip >= ( map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code+"/"+p.arrival_location])) {
						best_cost = cost;
						best_route = i;
						situation = "A";
					}
				}
				else {
					//qui c'è solo lui nell'aereo ma deve fare un pezzo vuoto all'inizio dal deposito alla partenza per il cliente, devo aggiungere più kilometri e un landing stop
					//non considero le time windows, faccio una partenza mirata per loro visto che sono i primi
					double cost = map_airplane[r.aircraft_code].fixed_cost + from_to[p.departure_location + ";" + p.arrival_location] + from_to[r.places[r.index - 1] + ";" + p.departure_location];
					//double travel_time = (from_to[p.departure_location + ";" + p.arrival_location] + from_to[r.places[r.index - 1] + ";" + p.departure_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + p.departure_location + ";" + p.arrival_location] + from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + p.departure_location];
					/*
					if (travel_time <= 1) {
						fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					cost += fuel_consumed;

					//per il check sul fuel
					//double travel_primo_tratto = (from_to[r.places[r.index - 1] + ";" + p.departure_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed_primo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + p.departure_location];
					/*
					if (travel_primo_tratto <= 1) {
						fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_primo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					//****
					double travel_secondo_tratto = (from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed_secondo_tratto = from_to_FuelConsumed[r.aircraft_code+";"+ p.departure_location + ";" + p.arrival_location];
					/*
					if (travel_secondo_tratto <= 1) {
						fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_secondo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
					//refuel
					double f_after_primo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto;
					double f_after_secondo_tratto = 0.0;
					if (map_airstrip[p.departure_location].fuel) {
						f_after_secondo_tratto = map_airplane[r.aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
					}
					else {
						f_after_secondo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
					}

					if (best_cost > cost && f_after_primo_tratto >= map_airplane[r.aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code+"/"+p.arrival_location] )) {
						best_cost = cost;
						best_route = i;
						situation = "B";
					}
				}
			}
			else {
				//nella route c'è almeno un altro passeggero, devo fare le considerazioni riguardo alla fisibilità della route
				//prendo tutte le coppie FROM-TO che ci sono nella route, se non c'è il FROM, non cerco il TO
				vector<int> FROM;
				vector<int> TO;
				for (int t = 0; t < r.index; t++) {
					if (r.places[t] == p.departure_location) FROM.push_back(t);
				}

				if (FROM.size() != 0) {
					//dentro questo abbiamo trovato dei FROM 
					for (int t = FROM[0]; t < r.index; t++) {
						if (r.places[t] == p.arrival_location) TO.push_back(t);
					}

					if (TO.size() != 0) {
						for (auto from : FROM) {
							for (auto to : TO) {
								if (from < to && to - from <= p.stop) {
									//se sono qua dentro il to è maggiore del from e gli stop intermedi sono minori di tre
									//per prima cosa guardo se ci sto con la capacità, altrimenti break sul primo for
									bool capacity_satisfy = true;
									for (int c = from; c < to; c++) {
										if ((r.capacity[c] + 1) > map_airplane[r.aircraft_code].capacity) capacity_satisfy = false;

										//double travel_time = (from_to[r.places[c] + ";" + r.places[c + 1]]) / map_airplane[r.aircraft_code].speed;
										double fuel_consumed = from_to_FuelConsumed[r.aircraft_code+";"+ r.places[c] + ";" + r.places[c + 1]];
										/*
										if (travel_time <= 1) {
											fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
										}
										else {
											fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
										}
										*/
										double fuel_i_j = fuel_consumed + map_airplane[r.aircraft_code].min_fuel;

										//aggiunto questa parte per l'ultimo tratto che deve prevedere l'andare da almeno un'altra parte con il fuel
										if (c == to - 1) fuel_i_j += location_fuel[r.aircraft_code + "/" + p.arrival_location];

										if (!r.refueling[c] && r.weight[c] - p.weight + (r.quantity_fuel[c] - fuel_i_j) < 0) capacity_satisfy = false;

									}
									//se non soddisfa la capacità non guardo neanche e passo al TO successivo
									if (!capacity_satisfy) break; //check also for the fuel;





									//se sorpasso il break vuol dire che soddisfo la capacità, in questo caso il solo costo che considerò per l'aggiunta del passeggero qui
									//è la time windows, se calcolo la time windows qua vuol dire che sfrutto il tempo in cui mi trovo in queste posizioni

									double TW_departure = 0.0;
									double t_arr_departure = r.time_arr[from];
									if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
									if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

									double TW_arrival = 0.0;
									double t_arr_arrival = r.time_arr[to];
									if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
									if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;

									double cost = TW_departure + TW_arrival;
									if (best_cost > cost) {
										best_cost = cost;
										best_route = i;
										situation = "D";
										best_from = from;
										best_to = to;
									}
								}
							}
						}
					}
					//da qui in giu considero il caso in cui non ci sono TO ma anche se ci sono ma non mi conviene farlo fermare li 
					//quindi il for per tutti i from ma al di fuori della route e poi considero anche il costo di aggiungerlo a parte il pezzetto che manca
					if (r.places[r.index - 1] != p.arrival_location) {
						for (auto from : FROM) {
							bool capacity_satisfy = true;
							for (int c = from; c < r.index; c++) {
								if ((r.capacity[c] + 1) > map_airplane[r.aircraft_code].capacity) capacity_satisfy = false;

								if (c < r.index - 1) {
									//double travel_time = (from_to[r.places[c] + ";" + r.places[c + 1]]) / map_airplane[r.aircraft_code].speed;
									double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[c] + ";" + r.places[c + 1]];
									/*
									if (travel_time <= 1) {
										fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
									}
									else {
										fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
									}
									*/
									double fuel_i_j = fuel_consumed + map_airplane[r.aircraft_code].min_fuel;

									if (!r.refueling[c] && r.weight[c] - p.weight + (r.quantity_fuel[c] - fuel_i_j) < 0) capacity_satisfy = false;
								}
							}
							//se non soddisfa la capacità non guardo neanche e passo al TO successivo
							//cout << p.stop<< endl;
							if (capacity_satisfy && (r.index - from) <= p.stop) {

								double TW_departure = 0.0;
								double t_arr_departure = r.time_arr[from];
								if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
								if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

								double cost = TW_departure;
								// ora ci metto chilometri e fuel dell'ultimo pezzo;
								cost += from_to[r.places[r.index - 1] + ";" + p.arrival_location];
								double travel_time = (from_to[r.places[r.index - 1] + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed;
								double fuel_consumed = from_to_FuelConsumed[r.aircraft_code+";"+ r.places[r.index - 1] + ";" + p.arrival_location];
								/*
								if (travel_time <= 1) {
									fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
								}
								else {
									fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
								}
								*/
								cost += fuel_consumed;

								bool fuel_ok = true;
								if (!r.refueling[r.index - 1]) {
									double fuel_i_j = fuel_consumed + map_airplane[r.aircraft_code].min_fuel;
									if (r.weight[r.index - 1] - p.weight + (r.quantity_fuel[r.index - 1] - fuel_i_j) < 0) fuel_ok = false;
								}

								double TW_arrival = 0.0;
								double t_arr_arrival = 0.0;
								t_arr_arrival = r.time_arr[r.index - 1] + travel_time * 60 + map_airstrip[r.places[r.index - 1]].ground_time;
								if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
								if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;
								cost += TW_arrival;

								if (fuel_ok && best_cost > cost && t_arr_arrival <= end_day && r.quantity_fuel[r.index - 1] - fuel_consumed >= (map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code + "/" + p.arrival_location])) {
									best_cost = cost;
									best_route = i;
									best_from = from;
									situation = "E";
								}
							}
						}
					}
					//guardo il costo di aggiungere un pezzo alla fine
					//double travel_time = (from_to[r.places[r.index - 1] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + p.departure_location] + from_to_FuelConsumed[r.aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*
					if (travel_time <= 1) {
						fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					double cost = fuel_consumed + from_to[r.places[r.index - 1] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];

					double TW_departure = 0.0;
					double t_arr_departure = r.time_arr[r.index - 1] + (map_airstrip[r.places[r.index - 1]].ground_time + (from_to[r.places[r.index - 1] + ";" + p.departure_location]) / map_airplane[r.aircraft_code].speed) * 60;
					if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

					double TW_arrival = 0.0;
					double t_arr_arrival = t_arr_departure + map_airstrip[p.departure_location].ground_time + ((from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed) * 60;
					if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;
					cost += TW_departure + TW_arrival;

					//per il check sul fuel:
					//double travel_primo_tratto = (from_to[r.places[r.index - 1] + ";" + p.departure_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed_primo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + p.departure_location];
					/*
					if (travel_primo_tratto <= 1) {
						fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_primo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					//****
					//double travel_secondo_tratto = (from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed_secondo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*if (travel_secondo_tratto <= 1) {
						fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_secondo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}*/

					//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
					//refuel
					double f_after_primo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto;
					double f_after_secondo_tratto = 0.0;
					if (map_airstrip[p.departure_location].fuel) {
						f_after_secondo_tratto = map_airplane[r.aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
					}
					else {
						f_after_secondo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
					}



					if (best_cost > cost && t_arr_arrival <= end_day && f_after_primo_tratto >= map_airplane[r.aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = i;
						situation = "C";
					}

				}
			}
			i++;
		}

		//cout << " caso : " << situation << " for the passeger:" << endl;
		//p.print();
		//ora devo aggiungere il passeggero nel posto migliore, quindi serve valutare in che caso sono A,B,C,D
		if (situation == "A") {
			solution[best_route].primo_pass = true;
			//time
			solution[best_route].time_dep[solution[best_route].index - 1] = p.early_departure + map_airstrip[p.departure_location].ground_time;
			solution[best_route].time_arr[solution[best_route].index - 1] = p.early_departure; // in questo caso anche l'arrivo in quanto è la partenza dal depot

			p.solution_from = solution[best_route].index - 1;
			solution[best_route].capacity[solution[best_route].index_cap - 1]++;

			//for the weight
			solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
				solution[best_route].quantity_fuel[solution[best_route].index_cap - 1] - p.weight;  //here i put max_fuel because at the beginnig in the depot all the airplane have full fuel
			if (solution[best_route].weight[solution[best_route].index_cap - 1] < 0) {
				solution[best_route].quantity_fuel[solution[best_route].index_cap - 1] += solution[best_route].weight[solution[best_route].index_cap - 1];
				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					solution[best_route].quantity_fuel[solution[best_route].index_cap - 1] - p.weight;
			}
			//end for weight




			double travel_time = ((from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[solution[best_route].aircraft_code].speed) * 60;
			double time_from = solution[best_route].time_dep[solution[best_route].index - 1];
			double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code+";"+ p.departure_location + ";" + p.arrival_location];

			if (map_airstrip[p.arrival_location].fuel) {
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 0, time_from + travel_time, time_from + travel_time + map_airstrip[p.arrival_location].ground_time);
				//for the weight
				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people - map_airplane[solution[best_route].aircraft_code].max_fuel;
				//end for weight
			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];

				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time_from + travel_time, time_from + travel_time + map_airstrip[p.arrival_location].ground_time);
				//for the weight
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] + fuel_consumed + p.weight;
				//end for weight

			}
			p.solution_to = solution[best_route].index - 1;
			solution[best_route].passengers_in_route.push_back(p);





		}
		if (situation == "B") {
			solution[best_route].primo_pass = true;
			solution[best_route].time_arr[solution[best_route].index - 1] = p.early_departure - (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60 -
				map_airstrip[solution[best_route].places[solution[best_route].index - 1]].ground_time;
			solution[best_route].time_dep[solution[best_route].index - 1] = p.early_departure - (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;

			//for the weight
			solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
				solution[best_route].quantity_fuel[solution[best_route].index_cap - 1];  //here i put max_fuel because at the beginnig in the depot all the airplane have full fuel
			//end for weight

			double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location];

			if (map_airstrip[p.departure_location].fuel) {
				solution[best_route].addPlace(p.departure_location, map_airstrip[p.departure_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 1, p.early_departure, p.early_departure + map_airstrip[p.departure_location].ground_time);

				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel - p.weight;
			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];

				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;

				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.departure_location, map_airstrip[p.departure_location].fuel, fuel_before - fuel_consumed, 0.0, 1, p.early_departure, p.early_departure + map_airstrip[p.departure_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] - p.weight + fuel_consumed;

			}
			p.solution_from = solution[best_route].index - 1;
			double time = p.early_departure + map_airstrip[p.departure_location].ground_time + (from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;




			if (map_airstrip[p.arrival_location].fuel) {
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);

				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel;
			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];
				double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location];
				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;
				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] + p.weight + fuel_consumed;

			}
			p.solution_to = solution[best_route].index - 1;
			solution[best_route].passengers_in_route.push_back(p);




		}
		if (situation == "C") {

			if (map_airstrip[p.departure_location].fuel) {
				solution[best_route].addPlace(p.departure_location, map_airstrip[p.departure_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 1,
					solution[best_route].time_dep[solution[best_route].index - 1] +
					(from_to[solution[best_route].places[solution[best_route].index - 1] + ";" +
						p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60,
					solution[best_route].time_dep[solution[best_route].index - 1] + (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" +
						p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60 + map_airstrip[p.departure_location].ground_time);

				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel - p.weight;


			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];
				double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location];
				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;

				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.departure_location, map_airstrip[p.departure_location].fuel, fuel_before - fuel_consumed, 0.0, 1, solution[best_route].time_dep[solution[best_route].index - 1] +
					(from_to[solution[best_route].places[solution[best_route].index - 1] + ";" +
						p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60,
					solution[best_route].time_dep[solution[best_route].index - 1] + (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" +
						p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60 + map_airstrip[p.departure_location].ground_time);

				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] - p.weight + fuel_consumed;

			}
			p.solution_from = solution[best_route].index - 1;
			double time = solution[best_route].time_dep[solution[best_route].index - 1] + (from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;





			if (map_airstrip[p.arrival_location].fuel) {
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel;

			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];
				double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location];
				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;

				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] + fuel_consumed;

			}


			p.solution_to = solution[best_route].index - 1;
			solution[best_route].passengers_in_route.push_back(p);
		}
		if (situation == "D") {



			for (int h = best_from; h < best_to; h++) {
				solution[best_route].capacity[h]++;
				solution[best_route].weight[h] -= p.weight;
			}

			//**************************************************************************
			double add_fuel = 0;
			int index_weight_neg = -1;
			for (int j = best_from; j < solution[best_route].index; j++) {
				//cout << " Sono nel rapeir devo aggiunger fuel linea 1015 devo guardare da " << node_add_from << " a " << node_add_to << endl;
				if (solution[best_route].weight[j] < 0) {
					//cout << " Weigth negativo in " << j << weight[j] << endl;
					add_fuel = solution[best_route].weight[j];
					index_weight_neg = j;
					int index_refueling = index_weight_neg;
					for (int i = index_weight_neg; i >= 0; i--) {
						if (solution[best_route].refueling[i]) {
							index_refueling = i;
							break;
						}
					}
					//cout << " Paro ad aggiornare in index refule " << index_refueling << endl;
					for (int t = index_refueling; t < solution[best_route].index; t++) {
						if (solution[best_route].refueling[t] && t != index_refueling) break;
						//cout << " Aggiorno nodo " << t << endl;
						solution[best_route].quantity_fuel[t] += add_fuel;
						solution[best_route].weight[t] -= add_fuel;
						//cout << " Weight dopo " << weight[t] << endl;
					}
				}
			}
			//**************************************************************************




			p.solution_from = best_from;
			p.solution_to = best_to;
			solution[best_route].passengers_in_route.push_back(p);
		}
		if (situation == "E") {


			for (int h = best_from; h < solution[best_route].index; h++) {
				solution[best_route].capacity[h]++;
				solution[best_route].weight[h] -= p.weight;


			}

			//******************************************************************************
			double add_fuel = 0;
			int index_weight_neg = -1;
			for (int j = best_from; j < solution[best_route].index; j++) {
				//cout << " Sono nel rapeir devo aggiunger fuel linea 1015 devo guardare da " << node_add_from << " a " << node_add_to << endl;
				if (solution[best_route].weight[j] < 0) {
					//cout << " Weigth negativo in " << j << weight[j] << endl;
					add_fuel = solution[best_route].weight[j];
					index_weight_neg = j;
					int index_refueling = index_weight_neg;
					for (int i = index_weight_neg; i >= 0; i--) {
						if (solution[best_route].refueling[i]) {
							index_refueling = i;
							break;
						}
					}
					//cout << " Paro ad aggiornare in index refule " << index_refueling << endl;
					for (int t = index_refueling; t < solution[best_route].index; t++) {
						if (solution[best_route].refueling[t] && t != index_refueling) break;
						//cout << " Aggiorno nodo " << t << endl;
						solution[best_route].quantity_fuel[t] += add_fuel;
						solution[best_route].weight[t] -= add_fuel;
						//cout << " Weight dopo " << weight[t] << endl;
					}
				}
			}
			//******************************************************************************

			p.solution_from = best_from;
			string place_1 = solution[best_route].places[solution[best_route].index - 1];
			double aircraft_speed = map_airplane[solution[best_route].aircraft_code].speed;
			double time = solution[best_route].time_dep[solution[best_route].index - 1] + (from_to[place_1 + ";" + p.arrival_location] / aircraft_speed) * 60;

			if (map_airstrip[p.arrival_location].fuel) {
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel;

			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];
				double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location];
				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;
				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/

				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] + fuel_consumed + p.weight;

			}

			p.solution_to = solution[best_route].index - 1;
			solution[best_route].passengers_in_route.push_back(p);

		}
		if (situation == "Error") cout << " il passeggero: " << p.name << " non trova sistemazione" << endl;
	}
	vector<Route> solution_clean;
	for (auto s : solution) {
		//s.print();
		if (s.index != 1) solution_clean.push_back(s);
	}


	return solution_clean;
}


vector<Route> heuristic_costructive_first_fase_sequential(vector<Airplane> airplanes, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, double start_day, double end_day, vector<Passenger> passengers, int number_of_aircraft, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {
	//creo i punti di partenza
	vector<Route> solution;
	int cont = 0;
	do {
		vector<Passenger> pass_in_solution;
		Route r(airplanes[cont].code, pass_in_solution);
		r.addPlace(airplanes[cont].depot, map_airstrip[airplanes[cont].depot].fuel, map_airplane[r.aircraft_code].max_fuel, 0.0, 0, 0.0, 0.0);
		solution.push_back(r);
		cont++;
	} while (cont < number_of_aircraft);
	//now i have created only the possible route, now i that one of them and fill it untill the condition stop

	for (Route& r : solution) {
		//cout << "sto prendendo la route nuova******************************************" << endl;
		string situation = "";
		do {
			situation = "Error"; //se situation rimane error vuol dire che nessun passeggero si può inserire, quindi che la route è piena e devo passare ad un'altra
			int best_passenger = -1;
			int best_from = -1;
			int best_to = -1;
			double best_cost = DBL_MAX;

			//cout << "passengers.size()= " << passengers.size() << endl;
			for (int p = 0; p < passengers.size(); p++) {
				if (r.primo_pass == false) {
					if (r.places[r.index - 1] == passengers[p].departure_location) {
						//in questo caso c'è solo lui nella route, il costo è dato dalla sua inserzione, quindi, chilometri, costo fisso per uso aereo e fuel
						double cost = map_airplane[r.aircraft_code].fixed_cost + from_to[passengers[p].departure_location + ";" + passengers[p].arrival_location];
						//double travel_time = from_to[passengers[p].departure_location + ";" + passengers[p].arrival_location] / map_airplane[r.aircraft_code].speed;
						double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + passengers[p].departure_location + ";" + passengers[p].arrival_location];
						
						/*
						if (travel_time <= 1) {
							fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
						}
						else {
							fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/
						cost += fuel_consumed;
						//per il check sul fuel:
						double fuel_after_trip = 0.0;
						fuel_after_trip = r.quantity_fuel[r.index - 1] - fuel_consumed;
						if (best_cost > cost && fuel_after_trip >= (map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code + "/" + passengers[p].arrival_location])) {
							best_cost = cost;
							best_passenger = p;
							situation = "A";
							//cout << "situation A, cost: " << cost << "passenger: " << p << endl;

						}
					}
					else {
						//qui c'è solo lui nell'aereo ma deve fare un pezzo vuoto all'inizio dal deposito alla partenza per il cliente, devo aggiungere più kilometri e un landing stop
						//non considero le time windows, faccio una partenza mirata per loro visto che sono i primi
						double cost = map_airplane[r.aircraft_code].fixed_cost + from_to[passengers[p].departure_location + ";" + passengers[p].arrival_location] + from_to[r.places[r.index - 1] + ";" + passengers[p].departure_location];
						//double travel_time = (from_to[passengers[p].departure_location + ";" + passengers[p].arrival_location] + from_to[r.places[r.index - 1] + ";" + passengers[p].departure_location]) / map_airplane[r.aircraft_code].speed;
						double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + passengers[p].departure_location + ";" + passengers[p].arrival_location] + from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[p].departure_location];
						/*
						if (travel_time <= 1) {
							fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
						}
						else {
							fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/
						cost += fuel_consumed;

						//per il check sul fuel
						//double travel_primo_tratto = (from_to[r.places[r.index - 1] + ";" + passengers[p].departure_location]) / map_airplane[r.aircraft_code].speed;
						double fuel_consumed_primo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[p].departure_location];

						/*
						if (travel_primo_tratto <= 1) {
							fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
						}
						else {
							fuel_consumed_primo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/
						//****
						//double travel_secondo_tratto = (from_to[passengers[p].departure_location + ";" + passengers[p].arrival_location]) / map_airplane[r.aircraft_code].speed;
						double fuel_consumed_secondo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + passengers[p].departure_location + ";" + passengers[p].arrival_location];
						/*
						if (travel_secondo_tratto <= 1) {
							fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
						}
						else {
							fuel_consumed_secondo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/
						//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
						//refuel
						double f_after_primo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto;
						double f_after_secondo_tratto = 0.0;
						if (map_airstrip[passengers[p].departure_location].fuel) {
							f_after_secondo_tratto = map_airplane[r.aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
						}
						else {
							f_after_secondo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
						}

						if (best_cost > cost && f_after_primo_tratto >= map_airplane[r.aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[r.aircraft_code].min_fuel+ location_fuel[r.aircraft_code + "/" + passengers[p].arrival_location])) {
							best_cost = cost;
							best_passenger = p;
							situation = "B";
							//cout << "situation B, cost: " << cost << "passenger: " << p << endl;
						}
					}
				}
				else {
					//nella route c'è almeno un altro passeggero, devo fare le considerazioni riguardo alla fisibilità della route
					//prendo tutte le coppie FROM-TO che ci sono nella route, se non c'è il FROM, non cerco il TO
					vector<int> FROM;
					vector<int> TO;
					for (int t = 0; t < r.index; t++) {
						if (r.places[t] == passengers[p].departure_location) FROM.push_back(t);
					}

					if (FROM.size() != 0) {
						//dentro questo abbiamo trovato dei FROM 
						for (int t = FROM[0]; t < r.index; t++) {
							if (r.places[t] == passengers[p].arrival_location) TO.push_back(t);
						}

						if (TO.size() != 0) {
							for (auto from : FROM) {
								for (auto to : TO) {
									if (from < to && to - from <= passengers[p].stop) {
										//se sono qua dentro il to è maggiore del from e gli stop intermedi sono minori di tre
										//per prima cosa guardo se ci sto con la capacità, altrimenti break sul primo for
										bool capacity_satisfy = true;
										for (int c = from; c < to; c++) {
											if ((r.capacity[c] + 1) > map_airplane[r.aircraft_code].capacity) capacity_satisfy = false;

											//double travel_time = (from_to[r.places[c] + ";" + r.places[c + 1]]) / map_airplane[r.aircraft_code].speed;
											double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[c] + ";" + r.places[c + 1]];
											/*
											if (travel_time <= 1) {
												fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
											}
											else {
												fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
											}
											*/
											double fuel_i_j = fuel_consumed + map_airplane[r.aircraft_code].min_fuel;

											if (c == to - 1) fuel_i_j += location_fuel[r.aircraft_code + "/" + passengers[p].arrival_location];

											if (!r.refueling[c] && r.weight[c] - passengers[p].weight + (r.quantity_fuel[c] - fuel_i_j) < 0) capacity_satisfy = false;

										}
										//se non soddisfa la capacità non guardo neanche e passo al TO successivo
										if (!capacity_satisfy) break; //check also for the fuel;





										//se sorpasso il break vuol dire che soddisfo la capacità, in questo caso il solo costo che considerò per l'aggiunta del passeggero qui
										//è la time windows, se calcolo la time windows qua vuol dire che sfrutto il tempo in cui mi trovo in queste posizioni

										double TW_departure = 0.0;
										double t_arr_departure = r.time_arr[from];
										if (t_arr_departure < passengers[p].early_departure) TW_departure = passengers[p].early_departure - t_arr_departure;
										if (t_arr_departure > passengers[p].late_departure) TW_departure = t_arr_departure - passengers[p].late_departure;

										double TW_arrival = 0.0;
										double t_arr_arrival = r.time_arr[to];
										if (t_arr_arrival < passengers[p].early_arrival) TW_arrival = passengers[p].early_arrival - t_arr_arrival;
										if (t_arr_arrival > passengers[p].late_arrival) TW_arrival = t_arr_arrival - passengers[p].late_arrival;

										double cost = TW_departure + TW_arrival;
										if (best_cost > cost) {
											best_cost = cost;
											best_passenger = p;
											situation = "D";
											best_from = from;
											best_to = to;
											//cout << "situation D, cost: " << cost << "passenger: " << p << endl;
										}
									}
								}
							}
						}
						//da qui in giu considero il caso in cui non ci sono TO ma anche se ci sono ma non mi conviene farlo fermare li 
						//quindi il for per tutti i from ma al di fuori della route e poi considero anche il costo di aggiungerlo a parte il pezzetto che manca
						if (r.places[r.index - 1] != passengers[p].arrival_location) {
							for (auto from : FROM) {
								bool capacity_satisfy = true;
								for (int c = from; c < r.index; c++) {
									if ((r.capacity[c] + 1) > map_airplane[r.aircraft_code].capacity) capacity_satisfy = false;

									if (c < r.index - 1) {
										//double travel_time = (from_to[r.places[c] + ";" + r.places[c + 1]]) / map_airplane[r.aircraft_code].speed;
										double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[c] + ";" + r.places[c + 1]];
										/*
										if (travel_time <= 1) {
											fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
										}
										else {
											fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
										}
										*/
										double fuel_i_j = fuel_consumed + map_airplane[r.aircraft_code].min_fuel;

										if (!r.refueling[c] && r.weight[c] - passengers[p].weight + (r.quantity_fuel[c] - fuel_i_j) < 0) capacity_satisfy = false;
									}
								}
								//se non soddisfa la capacità non guardo neanche e passo al TO successivo
								//cout << p.stop<< endl;
								if (capacity_satisfy && (r.index - from) <= passengers[p].stop) {

									double TW_departure = 0.0;
									double t_arr_departure = r.time_arr[from];
									if (t_arr_departure < passengers[p].early_departure) TW_departure = passengers[p].early_departure - t_arr_departure;
									if (t_arr_departure > passengers[p].late_departure) TW_departure = t_arr_departure - passengers[p].late_departure;

									double cost = TW_departure;
									// ora ci metto chilometri e fuel dell'ultimo pezzo;
									cost += from_to[r.places[r.index - 1] + ";" + passengers[p].arrival_location];
									double travel_time = (from_to[r.places[r.index - 1] + ";" + passengers[p].arrival_location]) / map_airplane[r.aircraft_code].speed;
									double fuel_consumed = from_to[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[p].arrival_location];
									/*
									if (travel_time <= 1) {
										fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
									}
									else {
										fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
									}
									*/
									cost += fuel_consumed;

									bool fuel_ok = true;
									if (!r.refueling[r.index - 1]) {
										double fuel_i_j = fuel_consumed + map_airplane[r.aircraft_code].min_fuel;
										if (r.weight[r.index - 1] - passengers[p].weight + (r.quantity_fuel[r.index - 1] - fuel_i_j) < 0) fuel_ok = false;
									}

									double TW_arrival = 0.0;
									double t_arr_arrival = 0.0;
									t_arr_arrival = r.time_arr[r.index - 1] + travel_time * 60 + map_airstrip[r.places[r.index - 1]].ground_time;
									if (t_arr_arrival < passengers[p].early_arrival) TW_arrival = passengers[p].early_arrival - t_arr_arrival;
									if (t_arr_arrival > passengers[p].late_arrival) TW_arrival = t_arr_arrival - passengers[p].late_arrival;
									cost += TW_arrival;

									if (fuel_ok && best_cost > cost && t_arr_arrival <= end_day && r.quantity_fuel[r.index - 1] - fuel_consumed >= (map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code + "/" + passengers[p].arrival_location])) {
										best_cost = cost;
										best_passenger = p;
										best_from = from;
										situation = "E";
										//cout << "situation E, cost: " << cost << "passenger: " << p << endl;
									}
								}
							}
						}
						//guardo il costo di aggiungere un pezzo alla fine
						//double travel_time = (from_to[r.places[r.index - 1] + ";" + passengers[p].departure_location] + from_to[passengers[p].departure_location + ";" + passengers[p].arrival_location]) / map_airplane[r.aircraft_code].speed;
						double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[p].departure_location] + from_to_FuelConsumed[r.aircraft_code + ";" + passengers[p].departure_location + ";" + passengers[p].arrival_location];
						/*
						if (travel_time <= 1) {
							fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
						}
						else {
							fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/
						double cost = fuel_consumed + from_to[r.places[r.index - 1] + ";" + passengers[p].departure_location] + from_to[passengers[p].departure_location + ";" + passengers[p].arrival_location];

						double TW_departure = 0.0;
						double t_arr_departure = r.time_arr[r.index - 1] + (map_airstrip[r.places[r.index - 1]].ground_time + (from_to[r.places[r.index - 1] + ";" + passengers[p].departure_location]) / map_airplane[r.aircraft_code].speed) * 60;
						if (t_arr_departure < passengers[p].early_departure) TW_departure = passengers[p].early_departure - t_arr_departure;
						if (t_arr_departure > passengers[p].late_departure) TW_departure = t_arr_departure - passengers[p].late_departure;

						double TW_arrival = 0.0;
						double t_arr_arrival = t_arr_departure + map_airstrip[passengers[p].departure_location].ground_time + ((from_to[passengers[p].departure_location + ";" + passengers[p].arrival_location]) / map_airplane[r.aircraft_code].speed) * 60;
						if (t_arr_arrival < passengers[p].early_arrival) TW_arrival = passengers[p].early_arrival - t_arr_arrival;
						if (t_arr_arrival > passengers[p].late_arrival) TW_arrival = t_arr_arrival - passengers[p].late_arrival;
						cost += TW_departure + TW_arrival;

						//per il check sul fuel:
						//double travel_primo_tratto = (from_to[r.places[r.index - 1] + ";" + passengers[p].departure_location]) / map_airplane[r.aircraft_code].speed;
						double fuel_consumed_primo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[p].departure_location];
						/*
						if (travel_primo_tratto <= 1) {
							fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
						}
						else {
							fuel_consumed_primo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/
						//****
						//double travel_secondo_tratto = (from_to[passengers[p].departure_location + ";" + passengers[p].arrival_location]) / map_airplane[r.aircraft_code].speed;
						double fuel_consumed_secondo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + passengers[p].departure_location + ";" + passengers[p].arrival_location];
						/*
						if (travel_secondo_tratto <= 1) {
							fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
						}
						else {
							fuel_consumed_secondo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/
						//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
						//refuel
						double f_after_primo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto;
						double f_after_secondo_tratto = 0.0;
						if (map_airstrip[passengers[p].departure_location].fuel) {
							f_after_secondo_tratto = map_airplane[r.aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
						}
						else {
							f_after_secondo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
						}



						if (best_cost > cost && t_arr_arrival <= end_day && f_after_primo_tratto >= map_airplane[r.aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[r.aircraft_code].min_fuel+ location_fuel[r.aircraft_code + "/" + passengers[p].arrival_location])) {
							best_cost = cost;
							best_passenger = p;
							situation = "C";
							//cout << "situation C, cost: " << cost << "passenger: " << p << endl;
						}

					}
				}
			}
			//qui dovrei avere tutte le cose per fare la mossa sempre se la route non è piena

			//cout << "la situation scelta e " << situation << "per il passeggero " << best_passenger << " al costo di " << best_cost << endl;
			if (situation == "A") {
				r.primo_pass = true;
				//time
				r.time_dep[r.index - 1] = passengers[best_passenger].early_departure + map_airstrip[passengers[best_passenger].departure_location].ground_time;
				r.time_arr[r.index - 1] = passengers[best_passenger].early_departure; // in questo caso anche l'arrivo in quanto è la partenza dal depot

				passengers[best_passenger].solution_from = r.index - 1;
				r.capacity[r.index_cap - 1]++;

				//for the weight
				r.weight[r.index_cap - 1] = map_airplane[r.aircraft_code].weight_fuel_people -
					r.quantity_fuel[r.index_cap - 1] - passengers[best_passenger].weight;  //here i put max_fuel because at the beginnig in the depot all the airplane have full fuel
				if (r.weight[r.index_cap - 1] < 0) {
					r.quantity_fuel[r.index_cap - 1] += r.weight[r.index_cap - 1];
					r.weight[r.index_cap - 1] = map_airplane[r.aircraft_code].weight_fuel_people -
						r.quantity_fuel[r.index_cap - 1] - passengers[best_passenger].weight;
				}
				//end for weight




				double travel_time = ((from_to[passengers[best_passenger].departure_location + ";" + passengers[best_passenger].arrival_location]) / map_airplane[r.aircraft_code].speed) * 60;
				double time_from = r.time_dep[r.index - 1];
				double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + passengers[best_passenger].departure_location + ";" + passengers[best_passenger].arrival_location];

				if (map_airstrip[passengers[best_passenger].arrival_location].fuel) {
					r.addPlace(passengers[best_passenger].arrival_location, map_airstrip[passengers[best_passenger].arrival_location].fuel, map_airplane[r.aircraft_code].max_fuel, 0.0, 0, time_from + travel_time, time_from + travel_time + map_airstrip[passengers[best_passenger].arrival_location].ground_time);
					//for the weight
					r.weight[r.index_cap - 1] = map_airplane[r.aircraft_code].weight_fuel_people - map_airplane[r.aircraft_code].max_fuel;
					//end for weight
				}
				else {
					double fuel_before = r.quantity_fuel[r.index - 1];


					/*
					if (travel_time <= 60) {
						fuel_consumed += (travel_time / 60)*map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[r.aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					r.addPlace(passengers[best_passenger].arrival_location, map_airstrip[passengers[best_passenger].arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time_from + travel_time, time_from + travel_time + map_airstrip[passengers[best_passenger].arrival_location].ground_time);
					//for the weight
					r.weight[r.index_cap - 1] = r.weight[r.index_cap - 2] + fuel_consumed + passengers[best_passenger].weight;
					//end for weight

				}
				passengers[best_passenger].solution_to = r.index - 1;
				r.passengers_in_route.push_back(passengers[best_passenger]);





			}
			if (situation == "B") {
				r.primo_pass = true;
				r.time_arr[r.index - 1] = passengers[best_passenger].early_departure - (from_to[r.places[r.index - 1] + ";" + passengers[best_passenger].departure_location] / map_airplane[r.aircraft_code].speed) * 60 -
					map_airstrip[r.places[r.index - 1]].ground_time;
				r.time_dep[r.index - 1] = passengers[best_passenger].early_departure - (from_to[r.places[r.index - 1] + ";" + passengers[best_passenger].departure_location] / map_airplane[r.aircraft_code].speed) * 60;

				//for the weight
				r.weight[r.index_cap - 1] = map_airplane[r.aircraft_code].weight_fuel_people -
					r.quantity_fuel[r.index_cap - 1];  //here i put max_fuel because at the beginnig in the depot all the airplane have full fuel
				//end for weight

				double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[best_passenger].departure_location];
				if (map_airstrip[passengers[best_passenger].departure_location].fuel) {
					r.addPlace(passengers[best_passenger].departure_location, map_airstrip[passengers[best_passenger].departure_location].fuel, map_airplane[r.aircraft_code].max_fuel, 0.0, 1, passengers[best_passenger].early_departure, passengers[best_passenger].early_departure + map_airstrip[passengers[best_passenger].departure_location].ground_time);

					r.weight[r.index_cap - 1] = map_airplane[r.aircraft_code].weight_fuel_people -
						map_airplane[r.aircraft_code].max_fuel - passengers[best_passenger].weight;
				}
				else {
					double fuel_before = r.quantity_fuel[r.index - 1];

					//double travel_time = (from_to[r.places[r.index - 1] + ";" + passengers[best_passenger].departure_location] / map_airplane[r.aircraft_code].speed) * 60;
					/*
					if (travel_time <= 60) {
						fuel_consumed += (travel_time / 60)*map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[r.aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					r.addPlace(passengers[best_passenger].departure_location, map_airstrip[passengers[best_passenger].departure_location].fuel, fuel_before - fuel_consumed, 0.0, 1, passengers[best_passenger].early_departure, passengers[best_passenger].early_departure + map_airstrip[passengers[best_passenger].departure_location].ground_time);
					r.weight[r.index_cap - 1] = r.weight[r.index_cap - 2] - passengers[best_passenger].weight + fuel_consumed;

				}
				passengers[best_passenger].solution_from = r.index - 1;
				double time = passengers[best_passenger].early_departure + map_airstrip[passengers[best_passenger].departure_location].ground_time + (from_to[passengers[best_passenger].departure_location + ";" + passengers[best_passenger].arrival_location] / map_airplane[r.aircraft_code].speed) * 60;




				if (map_airstrip[passengers[best_passenger].arrival_location].fuel) {
					r.addPlace(passengers[best_passenger].arrival_location, map_airstrip[passengers[best_passenger].arrival_location].fuel, map_airplane[r.aircraft_code].max_fuel, 0.0, 0, time, time + map_airstrip[passengers[best_passenger].arrival_location].ground_time);

					r.weight[r.index_cap - 1] = map_airplane[r.aircraft_code].weight_fuel_people -
						map_airplane[r.aircraft_code].max_fuel;
				}
				else {
					double fuel_before = r.quantity_fuel[r.index - 1];
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[best_passenger].arrival_location];
					//double travel_time = (from_to[r.places[r.index - 1] + ";" + passengers[best_passenger].arrival_location] / map_airplane[r.aircraft_code].speed) * 60;

					/*
					if (travel_time <= 60) {
						fuel_consumed += (travel_time / 60)*map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[r.aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					r.addPlace(passengers[best_passenger].arrival_location, map_airstrip[passengers[best_passenger].arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time, time + map_airstrip[passengers[best_passenger].arrival_location].ground_time);
					r.weight[r.index_cap - 1] = r.weight[r.index_cap - 2] + passengers[best_passenger].weight + fuel_consumed;

				}
				passengers[best_passenger].solution_to = r.index - 1;
				r.passengers_in_route.push_back(passengers[best_passenger]);




			}
			if (situation == "C") {

				if (map_airstrip[passengers[best_passenger].departure_location].fuel) {
					r.addPlace(passengers[best_passenger].departure_location, map_airstrip[passengers[best_passenger].departure_location].fuel, map_airplane[r.aircraft_code].max_fuel, 0.0, 1,
						r.time_dep[r.index - 1] +
						(from_to[r.places[r.index - 1] + ";" +
							passengers[best_passenger].departure_location] / map_airplane[r.aircraft_code].speed) * 60,
						r.time_dep[r.index - 1] + (from_to[r.places[r.index - 1] + ";" +
							passengers[best_passenger].departure_location] / map_airplane[r.aircraft_code].speed) * 60 + map_airstrip[passengers[best_passenger].departure_location].ground_time);

					r.weight[r.index_cap - 1] = map_airplane[r.aircraft_code].weight_fuel_people -
						map_airplane[r.aircraft_code].max_fuel - passengers[best_passenger].weight;


				}
				else {
					double fuel_before = r.quantity_fuel[r.index - 1];
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[best_passenger].departure_location];
					//double travel_time = (from_to[r.places[r.index - 1] + ";" + passengers[best_passenger].departure_location] / map_airplane[r.aircraft_code].speed) * 60;

					/*
					if (travel_time <= 60) {
						fuel_consumed += (travel_time / 60)*map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[r.aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					r.addPlace(passengers[best_passenger].departure_location, map_airstrip[passengers[best_passenger].departure_location].fuel, fuel_before - fuel_consumed, 0.0, 1, r.time_dep[r.index - 1] +
						(from_to[r.places[r.index - 1] + ";" +
							passengers[best_passenger].departure_location] / map_airplane[r.aircraft_code].speed) * 60,
						r.time_dep[r.index - 1] + (from_to[r.places[r.index - 1] + ";" +
							passengers[best_passenger].departure_location] / map_airplane[r.aircraft_code].speed) * 60 + map_airstrip[passengers[best_passenger].departure_location].ground_time);

					r.weight[r.index_cap - 1] = r.weight[r.index_cap - 2] - passengers[best_passenger].weight + fuel_consumed;

				}
				passengers[best_passenger].solution_from = r.index - 1;
				double time = r.time_dep[r.index - 1] + (from_to[passengers[best_passenger].departure_location + ";" + passengers[best_passenger].arrival_location] / map_airplane[r.aircraft_code].speed) * 60;





				if (map_airstrip[passengers[best_passenger].arrival_location].fuel) {
					r.addPlace(passengers[best_passenger].arrival_location, map_airstrip[passengers[best_passenger].arrival_location].fuel, map_airplane[r.aircraft_code].max_fuel, 0.0, 0, time, time + map_airstrip[passengers[best_passenger].arrival_location].ground_time);
					r.weight[r.index_cap - 1] = map_airplane[r.aircraft_code].weight_fuel_people -
						map_airplane[r.aircraft_code].max_fuel;

				}
				else {
					double fuel_before = r.quantity_fuel[r.index - 1];
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[best_passenger].arrival_location];
					//double travel_time = (from_to[r.places[r.index - 1] + ";" + passengers[best_passenger].arrival_location] / map_airplane[r.aircraft_code].speed) * 60;


					/*
					if (travel_time <= 60) {
						fuel_consumed += (travel_time / 60)*map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[r.aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					r.addPlace(passengers[best_passenger].arrival_location, map_airstrip[passengers[best_passenger].arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time, time + map_airstrip[passengers[best_passenger].arrival_location].ground_time);
					r.weight[r.index_cap - 1] = r.weight[r.index_cap - 2] + fuel_consumed;

				}


				passengers[best_passenger].solution_to = r.index - 1;
				r.passengers_in_route.push_back(passengers[best_passenger]);
			}
			if (situation == "D") {


				for (int h = best_from; h < best_to; h++) {
					r.capacity[h]++;
					r.weight[h] -= passengers[best_passenger].weight;
				}


				//**************************************************************************
				double add_fuel = 0;
				int index_weight_neg = -1;
				for (int j = best_from; j < r.index; j++) {
					//cout << " Sono nel rapeir devo aggiunger fuel linea 1015 devo guardare da " << node_add_from << " a " << node_add_to << endl;
					if (r.weight[j] < 0) {
						//cout << " Weigth negativo in " << j << weight[j] << endl;
						add_fuel = r.weight[j];
						index_weight_neg = j;
						int index_refueling = index_weight_neg;
						for (int i = index_weight_neg; i >= 0; i--) {
							if (r.refueling[i]) {
								index_refueling = i;
								break;
							}
						}
						//cout << " Paro ad aggiornare in index refule " << index_refueling << endl;
						for (int t = index_refueling; t < r.index; t++) {
							if (r.refueling[t] && t != index_refueling) break;
							//cout << " Aggiorno nodo " << t << endl;
							r.quantity_fuel[t] += add_fuel;
							r.weight[t] -= add_fuel;
							//cout << " Weight dopo " << weight[t] << endl;
						}
					}
				}
				//**************************************************************************




				passengers[best_passenger].solution_from = best_from;
				passengers[best_passenger].solution_to = best_to;
				r.passengers_in_route.push_back(passengers[best_passenger]);
			}
			if (situation == "E") {

				

				for (int h = best_from; h < r.index; h++) {
					r.capacity[h]++;
					r.weight[h] -= passengers[best_passenger].weight;
				}


				//******************************************************************************
				double add_fuel = 0;
				int index_weight_neg = -1;
				for (int j = best_from; j < r.index; j++) {
					//cout << " Sono nel rapeir devo aggiunger fuel linea 1015 devo guardare da " << node_add_from << " a " << node_add_to << endl;
					if (r.weight[j] < 0) {
						//cout << " Weigth negativo in " << j << weight[j] << endl;
						add_fuel = r.weight[j];
						index_weight_neg = j;
						int index_refueling = index_weight_neg;
						for (int i = index_weight_neg; i >= 0; i--) {
							if (r.refueling[i]) {
								index_refueling = i;
								break;
							}
						}
						//cout << " Paro ad aggiornare in index refule " << index_refueling << endl;
						for (int t = index_refueling; t < r.index; t++) {
							if (r.refueling[t] && t != index_refueling) break;
							//cout << " Aggiorno nodo " << t << endl;
							r.quantity_fuel[t] += add_fuel;
							r.weight[t] -= add_fuel;
							//cout << " Weight dopo " << weight[t] << endl;
						}
					}
				}
				//******************************************************************************



				passengers[best_passenger].solution_from = best_from;
				string place_1 = r.places[r.index - 1];
				double aircraft_speed = map_airplane[r.aircraft_code].speed;
				double time = r.time_dep[r.index - 1] + (from_to[place_1 + ";" + passengers[best_passenger].arrival_location] / aircraft_speed) * 60;

				if (map_airstrip[passengers[best_passenger].arrival_location].fuel) {
					r.addPlace(passengers[best_passenger].arrival_location, map_airstrip[passengers[best_passenger].arrival_location].fuel, map_airplane[r.aircraft_code].max_fuel, 0.0, 0, time, time + map_airstrip[passengers[best_passenger].arrival_location].ground_time);
					r.weight[r.index_cap - 1] = map_airplane[r.aircraft_code].weight_fuel_people -
						map_airplane[r.aircraft_code].max_fuel;

				}
				else {
					double fuel_before = r.quantity_fuel[r.index - 1];
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + passengers[best_passenger].arrival_location];
					//double travel_time = (from_to[r.places[r.index - 1] + ";" + passengers[best_passenger].arrival_location] / map_airplane[r.aircraft_code].speed) * 60;
					/*
					if (travel_time <= 60) {
						fuel_consumed += (travel_time / 60)*map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[r.aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					r.addPlace(passengers[best_passenger].arrival_location, map_airstrip[passengers[best_passenger].arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time, time + map_airstrip[passengers[best_passenger].arrival_location].ground_time);
					r.weight[r.index_cap - 1] = r.weight[r.index_cap - 2] + fuel_consumed + passengers[best_passenger].weight;

				}

				passengers[best_passenger].solution_to = r.index - 1;
				r.passengers_in_route.push_back(passengers[best_passenger]);

			}

			//qua devo rimuovere il passeggero se e solo se l'ho trovato
			if (situation != "Error") passengers.erase(passengers.begin() + best_passenger);



		} while (situation != "Error");
		if (passengers.size() == 0) break;
	}





	vector<Route> solution_clean;
	for (auto s : solution) {
		//s.print();
		if (s.index != 1) solution_clean.push_back(s);
	}


	return solution_clean;
}


bool route_feasible(Route r, map<string, Airplane>& map_airplane, double end_day, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {
	bool feasible = true;

	//check of the intermediate stop
	for (Passenger p : r.passengers_in_route) {
		if (p.solution_to - p.solution_from > p.stop) feasible = false;
	}

	//check for the fuel of take-off
	for (int i = 1; i < r.index; i++) {
		//if (r.quantity_fuel[i] < map_airplane[r.aircraft_code].min_fuel && !r.refueling[i]) feasible = false;
		if (r.quantity_fuel[i] < map_airplane[r.aircraft_code].min_fuel) feasible = false;
		if (r.refueling[i] && !r.refueling[i - 1]) {

			//double time_fly = (((from_to[r.places[i - 1] + ";" + r.places[i]]) / map_airplane[r.aircraft_code].speed) * 60);
			double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[i - 1] + ";" + r.places[i]];
			/*
			if (time_fly <= 60) {
				fuel_consumed += (time_fly / 60)*map_airplane[r.aircraft_code].fuel_burn_first;
			}
			else {
				fuel_consumed += map_airplane[r.aircraft_code].fuel_burn_first + ((time_fly - 60) / 60)*map_airplane[r.aircraft_code].fuel_burn_second;
			}
			*/
			if (r.quantity_fuel[i - 1] - fuel_consumed < map_airplane[r.aircraft_code].min_fuel) feasible = false;

		}

	}

	//check fo the capacity
	for (int i = 0; i < r.index - 1; i++) {
		if (r.capacity[i] > map_airplane[r.aircraft_code].capacity) feasible = false;
	}

	//check and day
	if (r.time_arr[r.index - 1] > end_day) feasible = false;

	//for the last-trip
	if (r.quantity_fuel[r.index - 1] < location_fuel[r.aircraft_code + "/" + r.places[r.index - 1]]) feasible = false;



	return feasible;
}

/*
bool intermediate_stop(Route r, int from, int to, Passenger p) {

	int stop = 0;
	string prec = "";

	for (int i = from; i < to; i++) {
		if (r.places[i] != prec) {
			stop++;
		}
		prec = r.places[i];
	}

	if (stop <= p.stop) return true;
	else return false;


}
*/


map<int, int> Compute_WorstNode(Route& route, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, map<string, double>& from_to) {
	double costoWorstNode = 0.00;
	int WorstNode = -1;
	map<double, int> Node;
	map<int, int> NodeOrder;
	set<double, MyCOMP<double>> Myset;
	if (route.index <= 2) {
		//route.print();
		Node.insert(make_pair(100000, 1));
		Myset.insert(100000);
		//cout << " Route troppo piccola fisso indice a " << 1 << endl;
	}
	else {
		for (int n = 1; n < route.index; n++) {
			double dist = 0.0;
			vector<Passenger> PassengerNodo;
			if (n != (route.index - 1)) {
				//cout << " Calcolo per nodo n mezzo " << endl;
				dist += map_airstrip[route.places[n]].landing_cost;
				dist += from_to[route.places[n - 1] + ";" + route.places[n]] + from_to[route.places[n] + ";" + route.places[n + 1]] - from_to[route.places[n-1] + ";" + route.places[n + 1]];
				for (int p = 0; p < route.passengers_in_route.size(); p++) {
					if (route.passengers_in_route[p].arrival_location == route.places[n] || route.passengers_in_route[p].departure_location == route.places[n]) {
						PassengerNodo.push_back(route.passengers_in_route[p]);
					}
				}
			}
			else {
				//cout << " Calcolo per ultimo nodo " << endl;
				dist += map_airstrip[route.places[n]].landing_cost;
				dist += from_to[route.places[n - 1] + ";" + route.places[n]];
				for (int p = 0; p < route.passengers_in_route.size(); p++) {
					if (route.passengers_in_route[p].arrival_location == route.places[n]) {
						PassengerNodo.push_back(route.passengers_in_route[p]);
					}
				}
			}

			dist += (cost_time_windows_for_node(route, PassengerNodo));
			// / PassengerNodo.size());
			//cout << " Inserisco nodo: " << n << " con il costo: " << dist << endl;
			Node.insert(make_pair(dist, n));
			Myset.insert(dist);
			//cout << " ************** Nodo: " << n << " Ha un costo: " << dist << endl;
			//cout << " ************** Nodo Peggiore finora: " << WorstNode << endl;
			//if (costoWorstNode < dist) {
				//costoWorstNode = dist;
				//WorstNode = n;
			//}
		}
	}
	
	//cout << " **************Stampo la mappa non ordinata: "<< endl;
	//for (auto x : Node) cout << x.first << " -----> " << x.second << endl;
	//cout << " **************Stampo il Set: " << endl;
	//for (auto setval : Myset) {
		//cout << setval << endl;
	//}
	
	int i = 0;
	for (auto setval : Myset) {
		NodeOrder.insert(make_pair(i, Node[setval]));
		i++;
	}
	//cout << " **************Stampo la mappa Ordinata: " << endl;
	//for (auto x : NodeOrder) cout << x.first << " -----> " << x.second << endl;
	return NodeOrder;
}







//ECCO I NOSTRI DESTROY
vector<Route> destroy_thanos(double destroy_coef_route, vector<Passenger>& passenger_removed, vector<Route>& solution, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& from_to_FuelConsumed) {


	int index = 0;
	for (Route& r : solution) {
		double f = (double)rand() / RAND_MAX;
		f = f * (10);
		//cout << f << endl;
		if (f <= destroy_coef_route && r.index > 1) {

			//genero il numero random di nodi da distruggere da 2 a place.size()-1;
			double numero_random = (double)rand() / RAND_MAX;
			if (r.places.size() == 2) {
				numero_random = round(1 + (numero_random*(r.places.size() - 2)));
				//numero_random = 0;
			}
			else {
				numero_random = round(2 + (numero_random*(r.places.size() - 3)));
			}


			//cout << "sono la route numero: " << index << " il numero random generato è: " << numero_random << " la route ha places.size-1 pari a: " << (r.places.size() - 1) << endl;

			if (numero_random == r.places.size() - 1) {
				//cout << "sono dentro all'if del numero random uguale a places()-1" << endl;
				// qua devo distruggere tutta la route e lasciare solo il depot
				for (int i = (int)(r.places.size()) - 1; i >= 1; i--) {
					r.places.erase(r.places.begin() + i);
					r.refueling.erase(r.refueling.begin() + i);
					r.quantity_fuel.erase(r.quantity_fuel.begin() + i);
					r.time_arr.erase(r.time_arr.begin() + i);
					r.time_dep.erase(r.time_dep.begin() + i);
					r.capacity.erase(r.capacity.begin() + i);
					r.weight.erase(r.weight.begin() + i);
					r.index--;
					r.index_cap--;
				}
				//qua ci dovrebbe essere solo il deposito
				//fisso il peso, capacita e fuel ai valori di default e la variabile passeggeri dentro a false
				r.quantity_fuel[0] = map_airplane[r.aircraft_code].max_fuel;
				r.weight[0] = map_airplane[r.aircraft_code].weight_fuel_people - r.quantity_fuel[0];
				r.capacity[0] = 0;
				r.primo_pass = false;

				//ora devo togliere tutti i passeggeri
				for (int p = r.passengers_in_route.size() - 1; p >= 0; p--) {
					r.passengers_in_route[p].route_before = index;
					passenger_removed.push_back(r.passengers_in_route[p]);
					r.passengers_in_route.erase(r.passengers_in_route.begin() + p);
				}

			}
			else {
				//qua devo pescare un numero di nodi da distruggere pari a numero_random
				int nodi_rimossi = 0; //finchè non ho rimosso 
				do {
					//cout << endl;
					//cout << "nodi rimossi: " << nodi_rimossi << endl;
					bool check = true;
					do {
						//if i'm here i can destroy the route
						//at the moment i destroy only a node
						int node_destroy = (int)(round(1 + ((double)rand() / RAND_MAX) * (r.index - 2)));
						//cout << "node destroy: " << node_destroy << endl;
						//cout << "r.index - 1= " << (r.index - 1) << endl;
						if (node_destroy == r.index - 1) { //this in the case of that node is at the end
							check = false;
							//cout << "nodo distrutto sono nel caso della rimozione dell'ultimo nodo: " << node_destroy <<endl;
							//r.print();
							vector<int> int_removed;
							//cout << " Sto lavorando sulla Route dell'Aereo " << r.aircraft_code << endl;
							//cout << " Questa route ha un index = " << r.index << endl; 
							//cout << "route prima della distruzione: " << endl;
							//r.print();

							int Min_From_Pass = node_destroy;
							int Max_To_Pass = node_destroy;
							for (int p = 0; p < r.passengers_in_route.size(); p++) {
								if (r.passengers_in_route[p].solution_to == node_destroy) {  // ho cambiato questa condizione
									if (r.passengers_in_route[p].solution_from < Min_From_Pass) Min_From_Pass = r.passengers_in_route[p].solution_from;
									int_removed.push_back(p);
									for (int t = r.passengers_in_route[p].solution_from; t < r.passengers_in_route[p].solution_to; t++) {
										r.capacity[t]--;
										r.weight[t] += r.passengers_in_route[p].weight;
									}
								}
							}
							for (int i = int_removed.size() - 1; i >= 0; i--) {
								// code for repair forbidden***********************************************************
								r.passengers_in_route[int_removed[i]].route_before = index;
								//*************************************************************************************
								passenger_removed.push_back(r.passengers_in_route[int_removed[i]]);
								vector<Passenger>::iterator it;
								it = r.passengers_in_route.begin();
								r.passengers_in_route.erase(it + int_removed[i]);
							}
							// Qua devo mettere codice che è quello dell'Update
							/*cout << "************* Sono nel codice che abbiamo fatto **********" << endl;
							cout << "******************* Stampiamo la Route: *******************" << endl;
							cout << " CODE ------> " << r.aircraft_code << endl;
							cout << " Minimo from passeggeri ----> " << Min_From_Pass << endl;
							cout << " Massimo to passeggeri ----> " << Max_To_Pass << endl;
							cout << " Node destroyed ------> " << node_destroy << endl;*/
							int index_min_from;
							for (int i = Min_From_Pass; i >= 0; i--) {
								if (r.refueling[i] && i != node_destroy) {
									index_min_from = i;
									break;
								}
							}
							//cout << " Parto a cercare il minimo da ------> " << index_min_from << endl;
							//Codice che serve per cercare il minimo nel range
							//cout << " Finisco a cercare il minimo in ------> " << Max_To_Pass << endl;
							for (int k = index_min_from; k < Max_To_Pass; k++) {
								if (r.refueling[k] && r.quantity_fuel[k] < map_airplane[r.aircraft_code].max_fuel) { //&& k!= node_destroy
								//cout << " Sto valutando il caso del nodo " << k << endl;
									int Node_min = k;
									double min_weight = r.weight[k];
									int index_updating_from = k;
									int index_updating_to = r.index;  //qua prima c'era -1
									for (int i = k + 1; i <= Max_To_Pass; i++) {
										//cout << " Sto guardando il nodo " << i << endl;
										//if (!(r.weight[i] > 0 && r.quantity_fuel[i] == map_airplane[r.aircraft_code].max_fuel)) {
										//cout << " Ho passato IF di controllo " << endl;
										if (r.refueling[i]) break;
										if (r.weight[i] < min_weight && i != node_destroy) {
											min_weight = r.weight[i];
											Node_min = i;
										}
										//}
									}
									//cout << " Nodo di minimo ---> " << Node_min << endl;
									//cout << " Valore di minimi --> " << min_weight << endl;
									if (Node_min >= 0) {
										for (int i = k + 1; i < r.index; i++) {
											if (r.refueling[i]) {   // && i != node_destroy ho tolto questo perchè se no se oltre quel nodo non c'è ne erano altri di fuell non trovavo un to
												index_updating_to = i;
												break;
											}
										}
										//cout << "Adesso che ho trovato il minimo devo aggiornare da ---> " << index_updating_from << endl;
										//cout << "Adesso che ho trovato il minimo devo aggiornare a ---> " << index_updating_to << endl;
										double Fuel_before = r.quantity_fuel[index_updating_from];
										//cout << " Valore Fuel Before ------> " << Fuel_before << endl;
										//cout << " Quindi alla fine parto ad aggiornare " << index_updating_from << " dove prendo il minimo tra " << map_airplane[r.aircraft_code].max_fuel << " e " << r.quantity_fuel[index_updating_from] + min_weight << endl;
										r.quantity_fuel[index_updating_from] = min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[index_updating_from] + min_weight);
										//cout << " Valore Fuel After ------> " << r.quantity_fuel[index_updating_from] << endl;
										//cout << " Valore Weigth Before ------> " << r.weight[index_updating_from] << endl;
										r.weight[index_updating_from] -= (r.quantity_fuel[index_updating_from] - Fuel_before);
										//cout << " Valore Weigth After ------> " << r.weight[index_updating_from] << endl;
										for (int i = index_updating_from + 1; i < index_updating_to; i++) {
											if (i != node_destroy) {
												r.quantity_fuel[i] += (r.quantity_fuel[index_updating_from] - Fuel_before);
												r.weight[i] -= (r.quantity_fuel[index_updating_from] - Fuel_before);
											}
										}
									}
								}

							}

							int nodi_mancanti = (int)(r.places.size());
							r.removePlace(node_destroy, map_airplane);
							nodi_mancanti -= (int)r.places.size();
							nodi_rimossi += nodi_mancanti;
							//cout << "route dopo la distruzione: " << endl;
							//r.print();
							// FORSE QUI CI VUOLE IL CODICE DEI CASI CON PESO NEGATIVO
						}
						else {
							//cout << "sono dentro l'else " << endl;
							double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[node_destroy - 1] + ";" + r.places[node_destroy + 1]];
							//double time_travel = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy + 1]] / map_airplane[r.aircraft_code].speed;
							/*
							if (time_travel <= 1) fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first*time_travel;
							else {
								fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
							}
							*/


							if (fuel_consumed <= r.quantity_fuel[node_destroy - 1] && r.places[node_destroy - 1] != r.places[node_destroy + 1]) {
								check = false;
								vector<int> int_removed;
								//cout << " route prima di togliere il Nodo: " << node_destroy << endl;
								//r.print();
								int Min_From_Pass = node_destroy;
								int Max_To_Pass = node_destroy;
								for (int p = 0; p < r.passengers_in_route.size(); p++) {
									if (r.passengers_in_route[p].solution_to == node_destroy || r.passengers_in_route[p].solution_from == node_destroy) { // ho cambiato questa condizione
										if (r.passengers_in_route[p].solution_from < Min_From_Pass) Min_From_Pass = r.passengers_in_route[p].solution_from;
										if (r.passengers_in_route[p].solution_to > Max_To_Pass) Max_To_Pass = r.passengers_in_route[p].solution_to;
										int_removed.push_back(p);
										for (int t = r.passengers_in_route[p].solution_from; t < r.passengers_in_route[p].solution_to; t++) {
											r.capacity[t]--;
											r.weight[t] += r.passengers_in_route[p].weight;
										}

									}
								}

								//cout << " Sto lavorando sulla Route dell'Aereo " << r.aircraft_code << endl;
								//cout << " (sono dentro al codice del main ) Valore Minimo di From dei passeggieri ---> " << Min_From_Pass << endl;
								//cout << " (sono dentro al codice del main ) Valore Massimo di To dei passeggieri ---> " << Max_To_Pass << endl;
								for (int i = int_removed.size() - 1; i >= 0; i--) {
									// code for repair forbidden***********************************************************
									r.passengers_in_route[int_removed[i]].route_before = index;
									//*************************************************************************************
									passenger_removed.push_back(r.passengers_in_route[int_removed[i]]);
									vector<Passenger>::iterator it;
									it = r.passengers_in_route.begin();
									r.passengers_in_route.erase(it + int_removed[i]);
								}

								int nodi_mancanti = r.places.size();
								r.update_route_destroy(node_destroy, Min_From_Pass, Max_To_Pass, from_to, map_airplane, map_airstrip); //update of the time
								//QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA***************************************************************************************

								double fuel_consumed1 = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[node_destroy - 1] + ";" + r.places[node_destroy]];
								//double time_travel1 = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
								/*
								if (time_travel1 <= 1) fuel_consumed1 = map_airplane[r.aircraft_code].fuel_burn_first*time_travel1;
								else {
									fuel_consumed1 = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel1 - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
								}
								*/
								double fuel_consumed2 = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[node_destroy] + ";" + r.places[node_destroy + 1]];
								//double time_travel2 = from_to[r.places[node_destroy] + ";" + r.places[node_destroy + 1]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
								/*
								if (time_travel2 <= 1) fuel_consumed2 = map_airplane[r.aircraft_code].fuel_burn_first*time_travel2;
								else {
									fuel_consumed2 = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel2 - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
								}
								*/


								int index_before = node_destroy - 1;
								//cout << " ************************* Ho finito  codice stampo route aggiornata gli devo ancora togliere nodo  **********************************" << endl;
								//r.print();
								//cout << " Adessos sto iniziando a sistemare i pedi perche togliero nodo " << endl;
								double diff = 0;
								//cout << " Index before: " << index_before << endl;
								for (int i = node_destroy + 1; i < r.index; i++) {
									//cout << " sono al i = " << i << endl;
									if (r.refueling[i]) break;
									//cout << "weight before: " << r.weight[i] << endl;
									if (index_before == (node_destroy - 1)) {
										//cout << " sono al primo giro faccio " << endl;
										diff = r.quantity_fuel[i];
										//cout << " diff: " << diff << endl;
										r.quantity_fuel[i] = r.quantity_fuel[index_before] - fuel_consumed;
										diff = diff - r.quantity_fuel[i];
										//cout << " diff aggiornata: " << diff << endl;

									}
									else {
										//cout << " non sono al primo giro " << endl;
										r.quantity_fuel[i] = r.quantity_fuel[i] - diff;
										//cout << " Al fuel del nodo " << i << " tolgo " << diff << endl;
										//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;
									}

									if (r.refueling[node_destroy]) {
										//cout << " caso in cui facevo refuiling nel nodo distrutto " << endl;
										//cout << "a r.weight[i]=  " << r.weight[i] << " tolgo questo valore  " << diff << endl;
										r.weight[i] = r.weight[i] + diff;

									}
									else {
										//	cout << " caso odo che ho tolto non era un fuel " << endl;
										//	cout << " weight prima " << r.weight[i] << endl;
										r.weight[i] = r.weight[i] + diff;
										//cout << " weight dopo " << r.weight[i] << endl;
									}


									//cout << "weight after: " << r.weight[i] << endl;
									//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed1 - fuel_consumed2 - (map_airplane[r.aircraft_code].max_fuel - r.quantity_fuel[node_destroy]);
									//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;
									//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;	

									//r.weight[i] = r.weight[i] - fuel_consumed1 - fuel_consumed2;
									//cout << " inidce before = " << index_before << endl;
									index_before = i + 1;
									//cout << " inidce before = " << index_before << " riparto con un altro giro " << endl;
								}
								//*****************************************************************************************************************************************************************
								r.removePlace(node_destroy, map_airplane);
								nodi_mancanti -= (int)(r.places.size());
								nodi_rimossi += (int)(nodi_mancanti);
								//cout << " Aggiornamento in main qui ho gia rimosso il nodo adesso sistemo i weigth negativi " << endl;
								double add_fuel = 0;
								int index_weight_neg = -1;
								for (int j = 0; j < r.index; j++) {
									if (r.weight[j] < 0) {
										//cout << " Nodo " << j << " della route " << r.aircraft_code << " negativo " << r.weight[j] << endl;
										add_fuel = r.weight[j];
										index_weight_neg = j;
										int index_refueling = index_weight_neg;
										for (int i = index_weight_neg; i >= 0; i--) {
											if (r.refueling[i]) { //&& i != node_destroy
												index_refueling = i;
												break;
											}
										}
										//cout << " Aggiorno da " << index_refueling << endl;
										for (int t = index_refueling; t < r.index; t++) {
											//cout << " Nodo " << t << " controllo se sto dentro o devo uscire " << endl;
											if (r.refueling[t] && t != index_refueling) break;
											//cout << " Ho passato if aggiorno nodo " << t << endl;
											//cout << " Quantità fuel prima : " << r.quantity_fuel[t] << " Weigth prima " << r.weight[t] << endl;
											r.quantity_fuel[t] += add_fuel;
											r.weight[t] -= add_fuel;
											//cout << " Quantità fuel dopo : " << r.quantity_fuel[t] << " Weigth dopo " << r.weight[t] << endl;
										}
									}
								}
								//cout << "route dopo la distruzione: " << endl;
								//r.print();
							}
						}
					} while (check);


				} while (nodi_rimossi < numero_random);




			}





		}
		//cout << "passengers removed" << endl;
		//for (Passenger p : passenger_removed) p.print();
		index++;
	}
	return solution;



}

vector<Route> destroy_casual(double destroy_coef_route, vector<Passenger>& passenger_removed, vector<Route>& solution, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& from_to_FuelConsumed) {

	//srand(time(NULL));
	int index = 0;
	for (Route& r : solution) {
		double f = (double)rand() / RAND_MAX;
		f = f * (10);
		//cout << f << endl;
		if (f <= destroy_coef_route && r.index > 1) {
			bool check = true;
			do {
				//if i'm here i can destroy the route
				//at the moment i destroy only a node
				double n_destroy = (double)rand() / RAND_MAX;
				int node_destroy = (int)(round(1 + n_destroy * (r.index - 2)));
				if (node_destroy == r.index - 1) { //this in the case of that node is at the end
					check = false;
					//cout << "nodo distrutto: " << node_destroy <<endl;
					//r.print();
					vector<int> int_removed;
					//cout << " Sto lavorando sulla Route dell'Aereo " << r.aircraft_code << endl;
					//cout << " Questa route ha un index = " << r.index << endl; 
					//cout << " siamo nel caso che il nodo distrutto sia l'ultimo " << endl;
					//r.print();

					int Min_From_Pass = node_destroy;
					int Max_To_Pass = node_destroy;
					for (int p = 0; p < r.passengers_in_route.size(); p++) {
						if (r.passengers_in_route[p].solution_to == node_destroy) {  // ho cambiato questa condizione
							if (r.passengers_in_route[p].solution_from < Min_From_Pass) Min_From_Pass = r.passengers_in_route[p].solution_from;
							int_removed.push_back(p);

							for (int t = r.passengers_in_route[p].solution_from; t < r.passengers_in_route[p].solution_to; t++) {
								r.capacity[t]--;
								r.weight[t] += r.passengers_in_route[p].weight;
								/*
								if (r.refueling[t] && r.quantity_fuel[t] < map_airplane[r.aircraft_code].max_fuel) {
								r.weight[t] -= min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight) - r.quantity_fuel[t];
								r.quantity_fuel[t] = min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight);
								}
								*/
							}


						}
					}
					for (int i = int_removed.size() - 1; i >= 0; i--) {
						// code for repair forbidden***********************************************************
						r.passengers_in_route[int_removed[i]].route_before = index;
						//*************************************************************************************

						passenger_removed.push_back(r.passengers_in_route[int_removed[i]]);
						vector<Passenger>::iterator it;
						it = r.passengers_in_route.begin();
						r.passengers_in_route.erase(it + int_removed[i]);
					}
					// Qua devo mettere codice che è quello dell'Update
					/*cout << "************* Sono nel codice che abbiamo fatto **********" << endl;
					cout << "******************* Stampiamo la Route: *******************" << endl;
					cout << " CODE ------> " << r.aircraft_code << endl;
					cout << " Minimo from passeggeri ----> " << Min_From_Pass << endl;
					cout << " Massimo to passeggeri ----> " << Max_To_Pass << endl;
					//r.print();
					cout << " Node destroyed ------> " << node_destroy << endl;
					*/

					int index_min_from;
					for (int i = Min_From_Pass; i >= 0; i--) {
						if (r.refueling[i] && i != node_destroy) {
							index_min_from = i;
							break;
						}
					}
					//cout << " Parto a cercare il minimo da ------> " << index_min_from << endl;
					// Codice che serve per cercare il minimo nel range
					//cout << " Finisco a cercare il minimo in ------> " << Max_To_Pass << endl;


					for (int k = index_min_from; k < Max_To_Pass; k++) {
						if (r.refueling[k] && r.quantity_fuel[k] < map_airplane[r.aircraft_code].max_fuel) { //&& k!= node_destroy
						//cout << " Sto valutando il caso del nodo " << k << endl;
							int Node_min = k;
							double min_weight = r.weight[k];
							int index_updating_from = k;
							int index_updating_to = r.index;  //qua prima c'era -1
							for (int i = k + 1; i <= Max_To_Pass; i++) {
								//cout << " Sto guardando il nodo " << i << endl;
								if (r.refueling[i]) break;
								//cout << " Ho passato il break " << endl;
								if (r.weight[i] < min_weight && i != node_destroy) {
									//	cout << " Ho passato IF di controllo " << endl;
									min_weight = r.weight[i];
									Node_min = i;
								}
							}
							//cout << " Nodo di minimo ---> " << Node_min << endl;
							//cout << " Valore di minimi --> " << min_weight << endl;
							if (Node_min >= 0) {
								for (int i = k + 1; i < r.index; i++) {
									if (r.refueling[i]) {   // && i != node_destroy ho tolto questo perchè se no se oltre quel nodo non c'è ne erano altri di fuell non trovavo un to
										index_updating_to = i;
										break;
									}
								}
								//cout << "Adesso che ho trovato il minimo devo aggiornare da ---> " << index_updating_from << endl;
								//cout << "Adesso che ho trovato il minimo devo aggiornare a ---> " << index_updating_to << endl;
								double Fuel_before = r.quantity_fuel[index_updating_from];
								//cout << " Valore Fuel Before ------> " << Fuel_before << endl;
								//cout << " Quindi alla fine parto ad aggiornare " << index_updating_from << " dove prendo il minimo tra " << map_airplane[r.aircraft_code].max_fuel << " e " << r.quantity_fuel[index_updating_from] + min_weight << endl;
								r.quantity_fuel[index_updating_from] = min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[index_updating_from] + min_weight);
								//cout << " Valore Fuel After ------> " << r.quantity_fuel[index_updating_from] << endl;
								//cout << " Valore Weigth Before ------> " << r.weight[index_updating_from] << endl;
								r.weight[index_updating_from] -= (r.quantity_fuel[index_updating_from] - Fuel_before);
								//cout << " Valore Weigth After ------> " << r.weight[index_updating_from] << endl;
								for (int i = index_updating_from + 1; i < index_updating_to; i++) {
									if (i != node_destroy) {
										r.quantity_fuel[i] += (r.quantity_fuel[index_updating_from] - Fuel_before);
										r.weight[i] -= (r.quantity_fuel[index_updating_from] - Fuel_before);
									}
								}
							}
						}

					}
					r.removePlace(node_destroy, map_airplane);
					//cout << " Aggiornamento in main qui ho gia rimosso il nodo adesso sistemo i weigth negativi quando tolgo ultimo nodo " << endl;
					double add_fuel = 0;
					int index_weight_neg = -1;
					for (int j = 0; j < r.index; j++) {
						if (r.weight[j] < 0) {
							//cout << " Nodo " << j << " della route " << r.aircraft_code << " negativo " << r.weight[j] << endl;
							add_fuel = r.weight[j];
							index_weight_neg = j;
							int index_refueling = index_weight_neg;
							for (int i = index_weight_neg; i >= 0; i--) {
								if (r.refueling[i]) { //&& i != node_destroy
									index_refueling = i;
									break;
								}
							}
							//cout << " Aggiorno da " << index_refueling << endl;
							for (int t = index_refueling; t < r.index; t++) {
								//cout << " Nodo " << t << " controllo se sto dentro o devo uscire " << endl;
								if (r.refueling[t] && t != index_refueling) break;
								//cout << " Ho passato if aggiorno nodo " << t << endl;
								//cout << " Quantità fuel prima : " << r.quantity_fuel[t] << " Weigth prima " << r.weight[t] << endl;
								r.quantity_fuel[t] += add_fuel;
								r.weight[t] -= add_fuel;
								//cout << " Quantità fuel dopo : " << r.quantity_fuel[t] << " Weigth dopo " << r.weight[t] << endl;
							}
						}
					}
				}
				else {

					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[node_destroy - 1] + ";" + r.places[node_destroy + 1]];
					//double time_travel = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy - 1]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
					//double time_travel = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy + 1]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
					/*
					if (time_travel <= 1) fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first*time_travel;
					else {
						fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/


					if ((fuel_consumed + map_airplane[r.aircraft_code].min_fuel) <= r.quantity_fuel[node_destroy - 1] && r.places[node_destroy - 1] != r.places[node_destroy + 1]) {   //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
						check = false;
						vector<int> int_removed;
						int Min_From_Pass = node_destroy;
						int Max_To_Pass = node_destroy;
						for (int p = 0; p < r.passengers_in_route.size(); p++) {
							if (r.passengers_in_route[p].solution_to == node_destroy || r.passengers_in_route[p].solution_from == node_destroy) { // ho cambiato questa condizione
								if (r.passengers_in_route[p].solution_from < Min_From_Pass) Min_From_Pass = r.passengers_in_route[p].solution_from;
								if (r.passengers_in_route[p].solution_to > Max_To_Pass) Max_To_Pass = r.passengers_in_route[p].solution_to;
								int_removed.push_back(p);
								for (int t = r.passengers_in_route[p].solution_from; t < r.passengers_in_route[p].solution_to; t++) {
									r.capacity[t]--;
									r.weight[t] += r.passengers_in_route[p].weight;
									/*
									if (r.refueling[t] && r.quantity_fuel[t] < map_airplane[r.aircraft_code].max_fuel) {
									r.weight[t] -= min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight) - r.quantity_fuel[t];
									r.quantity_fuel[t] = min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight);
									}
									*/
								}

							}
						}

						/*
						cout << "Nodo: " << node_destroy << endl;
						cout << " Sto tohliendo caso del nodo non ultimo riga 3278 " << endl;
						cout << " Sto lavorando sulla Route dell'Aereo " << r.aircraft_code << endl;
						cout << " (sono dentro al codice del main ) Valore Minimo di From dei passeggieri ---> " << Min_From_Pass << endl;
						cout << " (sono dentro al codice del main ) Valore Massimo di To dei passeggieri ---> " << Max_To_Pass << endl;
						*/
						for (int i = int_removed.size() - 1; i >= 0; i--) {
							// code for repair forbidden***********************************************************
							r.passengers_in_route[int_removed[i]].route_before = index;
							//*************************************************************************************
							passenger_removed.push_back(r.passengers_in_route[int_removed[i]]);
							vector<Passenger>::iterator it;
							it = r.passengers_in_route.begin();
							r.passengers_in_route.erase(it + int_removed[i]);
						}
						r.update_route_destroy(node_destroy, Min_From_Pass, Max_To_Pass, from_to, map_airplane, map_airstrip); //update of the time
						//r.print();


						//QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA***************************************************************************************
						//double fuel_consumed1 = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[node_destroy - 1] + ";" + r.places[node_destroy]];
						//double time_travel1 = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
						/*
						if (time_travel1 <= 1) fuel_consumed1 = map_airplane[r.aircraft_code].fuel_burn_first*time_travel1;
						else {
							fuel_consumed1 = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel1 - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/
						//double fuel_consumed2 = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[node_destroy] + ";" + r.places[node_destroy + 1]];
						/*double time_travel2 = from_to[r.places[node_destroy] + ";" + r.places[node_destroy + 1]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
						if (time_travel2 <= 1) fuel_consumed2 = map_airplane[r.aircraft_code].fuel_burn_first*time_travel2;
						else {
							fuel_consumed2 = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel2 - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/


						int index_before = node_destroy - 1;
						//cout << " ************************* Ho finito  codice stampo route aggiornata gli devo ancora togliere nodo  **********************************" << endl;
						//r.print();
						//cout << " Adessos sto iniziando a sistemare i pesi perche togliero nodo del aereo " << r.aircraft_code << endl;
						double diff = 0;
						//cout << " Index before: " << index_before << endl;
						for (int i = node_destroy + 1; i < r.index; i++) {
							//cout << " sono al i = " << i << endl;
							if (r.refueling[i]) break;
							//cout << "weight before: " << r.weight[i] << endl;
							if (index_before == (node_destroy - 1)) {
								//cout << " sono al primo giro faccio " << endl;
								diff = r.quantity_fuel[i];
								//cout << " diff: " << diff << endl;
								r.quantity_fuel[i] = r.quantity_fuel[index_before] - fuel_consumed;
								diff = diff - r.quantity_fuel[i];
								//cout << " diff aggiornata: " << diff << endl;

							}
							else {
								//cout << " non sono al primo giro " << endl;
								r.quantity_fuel[i] = r.quantity_fuel[i] - diff;
								//cout << " Al fuel del nodo " << i << " tolgo " << diff << endl;
								//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;
							}

							//cout << " weight prima " << r.weight[i] << endl;
							r.weight[i] = r.weight[i] + diff;
							//cout << " weight dopo " << r.weight[i] << endl;



							//cout << "weight after: " << r.weight[i] << endl;
							//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed1 - fuel_consumed2 - (map_airplane[r.aircraft_code].max_fuel - r.quantity_fuel[node_destroy]);
							//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;
							//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;	

							//r.weight[i] = r.weight[i] - fuel_consumed1 - fuel_consumed2;
							//cout << " inidce before = " << index_before << endl;
							index_before = i + 1;
							//cout << " inidce before = " << index_before << " riparto con un altro giro "<<  endl;
						}
						//*****************************************************************************************************************************************************************


						r.removePlace(node_destroy, map_airplane);
						//cout << " Aggiornamento in main qui ho gia rimosso il nodo adesso sistemo i weigth negativi " << endl;
						double add_fuel = 0;
						int index_weight_neg = -1;
						for (int j = 0; j < r.index; j++) {
							if (r.weight[j] < 0) {
								//cout << " Nodo " << j << " della route " << r.aircraft_code << " negativo " << r.weight[j] << endl;
								add_fuel = r.weight[j];
								index_weight_neg = j;
								int index_refueling = index_weight_neg;
								for (int i = index_weight_neg; i >= 0; i--) {
									if (r.refueling[i]) { //&& i != node_destroy
										index_refueling = i;
										break;
									}
								}
								//cout << " Aggiorno da " << index_refueling << endl;
								for (int t = index_refueling; t < r.index; t++) {
									//cout << " Nodo " << t << " controllo se sto dentro o devo uscire " << endl;
									if (r.refueling[t] && t != index_refueling) break;
									//cout << " Ho passato if aggiorno nodo " << t << endl;
									//cout << " Quantità fuel prima : " << r.quantity_fuel[t] << " Weigth prima " << r.weight[t] << endl;
									r.quantity_fuel[t] += add_fuel;
									r.weight[t] -= add_fuel;
									//cout << " Quantità fuel dopo : " << r.quantity_fuel[t] << " Weigth dopo " << r.weight[t] << endl;
								}
							}
						}

						//r.print();
					}
				}

			} while (check);
		}
		//cout << "passengers removed" << endl;
		//for (Passenger p : passenger_removed) p.print();
		index++;
	}
	return solution;
}

vector<Route> destroy_worst(double destroy_coef_route, vector<Passenger>& passenger_removed, vector<Route>& solution, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& from_to_FuelConsumed) {

	//srand(time(NULL));
	int index = 0;
	for (Route& r : solution) {
		double f = (double)rand() / RAND_MAX;
		f = f * (10);
		//cout << f << endl;
		if (f <= destroy_coef_route && r.index > 1) {
			// Primo elemanto la posizione il secondo il numero del nodo
			map<int, int> Node;
			bool check = true;
			int first = 0;
			do {
				// Qui va messa una funzione ch individua il nodo peggiore
				//cout << " ************** Chiamo funzione che mi calcoli il nodo peggiore **************" << endl;
				Node = Compute_WorstNode(r, map_airplane, map_airstrip, from_to);
				int node_destroy = Node[first];
				//cout << " La funzione ha finito togli il nodo: " << node_destroy << endl;
				//cout << " Route " << r.aircraft_code << endl;
				//cout << " Node ha una size di " << Node.size() << endl;
				//cout << " Voglio accedere a first = " << first << endl;
				if (node_destroy == 0 || first >= Node.size()) break;
				if (node_destroy == r.index - 1) { //this in the case of that node is at the end
					check = false;
					//cout << "nodo distrutto: " << node_destroy <<endl;
					//r.print();
					vector<int> int_removed;
					//cout << " Sto lavorando sulla Route dell'Aereo " << r.aircraft_code << endl;
					//cout << " Questa route ha un index = " << r.index << endl; 
					//r.print();

					int Min_From_Pass = node_destroy;
					int Max_To_Pass = node_destroy;
					for (int p = 0; p < r.passengers_in_route.size(); p++) {
						if (r.passengers_in_route[p].solution_to == node_destroy) {  // ho cambiato questa condizione
							if (r.passengers_in_route[p].solution_from < Min_From_Pass) Min_From_Pass = r.passengers_in_route[p].solution_from;
							int_removed.push_back(p);

							for (int t = r.passengers_in_route[p].solution_from; t < r.passengers_in_route[p].solution_to; t++) {
								r.capacity[t]--;
								r.weight[t] += r.passengers_in_route[p].weight;
								/*
								if (r.refueling[t] && r.quantity_fuel[t] < map_airplane[r.aircraft_code].max_fuel) {
								r.weight[t] -= min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight) - r.quantity_fuel[t];
								r.quantity_fuel[t] = min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight);
								}
								*/
							}


						}
					}
					for (int i = int_removed.size() - 1; i >= 0; i--) {
						// code for repair forbidden***********************************************************
						r.passengers_in_route[int_removed[i]].route_before = index;
						//*************************************************************************************

						passenger_removed.push_back(r.passengers_in_route[int_removed[i]]);
						vector<Passenger>::iterator it;
						it = r.passengers_in_route.begin();
						r.passengers_in_route.erase(it + int_removed[i]);
					}
					// Qua devo mettere codice che è quello dell'Update
					/*
					cout << "************* Sono nel codice che abbiamo fatto **********" << endl;
					cout << "******************* Stampiamo la Route: *******************" << endl;
					cout << " CODE ------> " << r.aircraft_code << endl;
					cout << " Minimo from passeggeri ----> " << Min_From_Pass << endl;
					cout << " Massimo to passeggeri ----> " << Max_To_Pass << endl;
					r.print();
					cout << " Node destroyed ------> " << node_destroy << endl;
					*/
					int index_min_from;
					for (int i = Min_From_Pass; i >= 0; i--) {
						if (r.refueling[i] && i != node_destroy) {
							index_min_from = i;
							break;
						}
					}
					//cout << " Parto a cercare il minimo da ------> " << index_min_from << endl;
					// Codice che serve per cercare il minimo nel range
					//cout << " Finisco a cercare il minimo in ------> " << Max_To_Pass << endl;


					for (int k = index_min_from; k < Max_To_Pass; k++) {
						if (r.refueling[k] && r.quantity_fuel[k] < map_airplane[r.aircraft_code].max_fuel) { //&& k!= node_destroy
						//cout << " Sto valutando il caso del nodo " << k << endl;
							int Node_min = k;
							double min_weight = r.weight[k];
							int index_updating_from = k;
							int index_updating_to = r.index;  //qua prima c'era -1
							for (int i = k + 1; i <= Max_To_Pass; i++) {
								//cout << " Sto guardando il nodo " << i << endl;
								//if (!(r.weight[i] > 0 && r.quantity_fuel[i] == map_airplane[r.aircraft_code].max_fuel)) {
								//cout << " Ho passato IF di controllo " << endl;
								if (r.refueling[i]) break;
								if (r.weight[i] < min_weight && i != node_destroy) {
									min_weight = r.weight[i];
									Node_min = i;
								}
								//}
							}
							//cout << " Nodo di minimo ---> " << Node_min << endl;
							//cout << " Valore di minimi --> " << min_weight << endl;
							if (Node_min >= 0) {
								/*
								for (int i = Node_min; i >= 0; i--) {
								if (r.refueling[i] && i != node_destroy) {
								index_updating_from = i;
								break;
								}
								}
								*/
								for (int i = k + 1; i < r.index; i++) {
									if (r.refueling[i]) {   // && i != node_destroy ho tolto questo perchè se no se oltre quel nodo non c'è ne erano altri di fuell non trovavo un to
										index_updating_to = i;
										break;
									}
								}
								//cout << "Adesso che ho trovato il minimo devo aggiornare da ---> " << index_updating_from << endl;
								//cout << "Adesso che ho trovato il minimo devo aggiornare a ---> " << index_updating_to << endl;
								double Fuel_before = r.quantity_fuel[index_updating_from];
								//cout << " Valore Fuel Before ------> " << Fuel_before << endl;
								//cout << " Quindi alla fine parto ad aggiornare " << index_updating_from << " dove prendo il minimo tra " << map_airplane[r.aircraft_code].max_fuel << " e " << r.quantity_fuel[index_updating_from] + min_weight << endl;
								r.quantity_fuel[index_updating_from] = min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[index_updating_from] + min_weight);
								//cout << " Valore Fuel After ------> " << r.quantity_fuel[index_updating_from] << endl;
								//cout << " Valore Weigth Before ------> " << r.weight[index_updating_from] << endl;
								r.weight[index_updating_from] -= (r.quantity_fuel[index_updating_from] - Fuel_before);
								//cout << " Valore Weigth After ------> " << r.weight[index_updating_from] << endl;
								for (int i = index_updating_from + 1; i < index_updating_to; i++) {
									if (i != node_destroy) {
										r.quantity_fuel[i] += (r.quantity_fuel[index_updating_from] - Fuel_before);
										r.weight[i] -= (r.quantity_fuel[index_updating_from] - Fuel_before);
									}
								}
							}
						}

					}
					r.removePlace(node_destroy, map_airplane);
				}
				else {

					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[node_destroy - 1] + ";" + r.places[node_destroy + 1]];
					//double time_travel = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy - 1]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
					/*
					double time_travel = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy + 1]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
					if (time_travel <= 1) fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first*time_travel;
					else {
						fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/


					if ((fuel_consumed + map_airplane[r.aircraft_code].min_fuel) <= r.quantity_fuel[node_destroy - 1] && r.places[node_destroy - 1] != r.places[node_destroy + 1]) {   //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
						check = false;
						vector<int> int_removed;
						//cout << "Nodo: " << node_destroy << endl;
						//r.print();
						int Min_From_Pass = node_destroy;
						int Max_To_Pass = node_destroy;
						for (int p = 0; p < r.passengers_in_route.size(); p++) {
							if (r.passengers_in_route[p].solution_to == node_destroy || r.passengers_in_route[p].solution_from == node_destroy) { // ho cambiato questa condizione
								if (r.passengers_in_route[p].solution_from < Min_From_Pass) Min_From_Pass = r.passengers_in_route[p].solution_from;
								if (r.passengers_in_route[p].solution_to > Max_To_Pass) Max_To_Pass = r.passengers_in_route[p].solution_to;
								int_removed.push_back(p);
								for (int t = r.passengers_in_route[p].solution_from; t < r.passengers_in_route[p].solution_to; t++) {
									r.capacity[t]--;
									r.weight[t] += r.passengers_in_route[p].weight;
									/*
									if (r.refueling[t] && r.quantity_fuel[t] < map_airplane[r.aircraft_code].max_fuel) {
									r.weight[t] -= min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight) - r.quantity_fuel[t];
									r.quantity_fuel[t] = min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight);
									}
									*/
								}

							}
						}




						//cout << " Sto lavorando sulla Route dell'Aereo " << r.aircraft_code << endl;
						//cout << " (sono dentro al codice del main ) Valore Minimo di From dei passeggieri ---> " << Min_From_Pass << endl;
						//cout << " (sono dentro al codice del main ) Valore Massimo di To dei passeggieri ---> " << Max_To_Pass << endl;
						for (int i = int_removed.size() - 1; i >= 0; i--) {
							// code for repair forbidden***********************************************************
							r.passengers_in_route[int_removed[i]].route_before = index;
							//*************************************************************************************


							passenger_removed.push_back(r.passengers_in_route[int_removed[i]]);
							vector<Passenger>::iterator it;
							it = r.passengers_in_route.begin();
							r.passengers_in_route.erase(it + int_removed[i]);
						}
						r.update_route_destroy(node_destroy, Min_From_Pass, Max_To_Pass, from_to, map_airplane, map_airstrip); //update of the time



						//QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA***************************************************************************************

						//double fuel_consumed1 = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[node_destroy - 1] + ";" + r.places[node_destroy]];
						/*double time_travel1 = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
						if (time_travel1 <= 1) fuel_consumed1 = map_airplane[r.aircraft_code].fuel_burn_first*time_travel1;
						else {
							fuel_consumed1 = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel1 - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/
						//double fuel_consumed2 = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[node_destroy] + ";" + r.places[node_destroy + 1]];
						/*
						double time_travel2 = from_to[r.places[node_destroy] + ";" + r.places[node_destroy + 1]] / map_airplane[r.aircraft_code].speed; //QUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
						if (time_travel2 <= 1) fuel_consumed2 = map_airplane[r.aircraft_code].fuel_burn_first*time_travel2;
						else {
							fuel_consumed2 = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel2 - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
						}
						*/


						int index_before = node_destroy - 1;
						//cout << " ************************* Ho finito  codice stampo route aggiornata gli devo ancora togliere nodo  **********************************" << endl;
						//r.print();
						//cout << " Adessos sto iniziando a sistemare i pedi perche togliero nodo " << endl;
						double diff = 0;
						//cout << " Index before: " << index_before << endl;
						for (int i = node_destroy + 1; i < r.index; i++) {
							//cout << " sono al i = " << i << endl;
							if (r.refueling[i]) break;
							//cout << "weight before: " << r.weight[i] << endl;
							if (index_before == (node_destroy - 1)) {
								//cout << " sono al primo giro faccio " << endl;
								//cout << "r.quantity_fuel[i] = r.quantity_fuel[index_before] - fuel_consumed " << r.quantity_fuel[i] <<"="<< r.quantity_fuel[index_before] <<"-"<< fuel_consumed;
								diff = r.quantity_fuel[i];
								//cout << " diff: " << diff << endl;
								r.quantity_fuel[i] = r.quantity_fuel[index_before] - fuel_consumed;
								diff = diff - r.quantity_fuel[i];
								//cout << " diff aggiornata: " << diff << endl;
								//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1 + (map_airplane[r.aircraft_code].max_fuel - r.quantity_fuel[node_destroy]);

							}
							else {
								//cout << " non sono al primo giro " << endl;
								r.quantity_fuel[i] = r.quantity_fuel[i] - diff;
								//cout << " Al fuel del nodo " << i << " tolgo " << diff << endl;
								//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;
							}

							if (r.refueling[node_destroy]) {
								//cout << " caso in cui facevo refuiling nel nodo distrutto " << endl;
								//cout << " al peso del nodo " << i << " aggiorno con fuel_consumed - fuel_consumed2 - (map_airplane[r.aircraft_code].max_fuel - r.quantity_fuel[node_destroy]); " << fuel_consumed << "- " << fuel_consumed2 << " - " << (map_airplane[r.aircraft_code].max_fuel - r.quantity_fuel[node_destroy]) << endl;
								//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - (map_airplane[r.aircraft_code].max_fuel - r.quantity_fuel[node_destroy]);
								r.weight[i] = r.weight[i] + diff;
								//cout << "a r.weight[i]=  " << r.weight[i]<<" tolgo questo valore  " <<diff << endl;
							}
							else {
								//cout << " caso odo che ho tolto non era un fuel " << endl;
								//cout << " al peso del nodo " << i << " aggiorno l'attuale " << r.weight[i]<<" con  + "<< fuel_consumed<<" - "<<fuel_consumed2<<" -"<< fuel_consumed1;
								//cout << " weight prima " << r.weight[i] << endl;
								r.weight[i] = r.weight[i] + diff;
								//cout << " weight dopo " << r.weight[i] << endl;
							}


							//cout << "weight after: " << r.weight[i] << endl;
							//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed1 - fuel_consumed2 - (map_airplane[r.aircraft_code].max_fuel - r.quantity_fuel[node_destroy]);
							//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;
							//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;	

							//r.weight[i] = r.weight[i] - fuel_consumed1 - fuel_consumed2;
							//cout << " inidce before = " << index_before << endl;
							index_before = i + 1;
							//cout << " inidce before = " << index_before << " riparto con un altro giro "<<  endl;
						}
						//*****************************************************************************************************************************************************************


						r.removePlace(node_destroy, map_airplane);
						//cout << " Aggiornamento in main qui ho gia rimosso il nodo adesso sistemo i weigth negativi " << endl;
						double add_fuel = 0;
						int index_weight_neg = -1;
						for (int j = 0; j < r.index; j++) {
							if (r.weight[j] < 0) {
								//cout << " Nodo " << j << " della route " << r.aircraft_code << " negativo " << r.weight[j] << endl;
								add_fuel = r.weight[j];
								index_weight_neg = j;
								int index_refueling = index_weight_neg;
								for (int i = index_weight_neg; i >= 0; i--) {
									if (r.refueling[i]) { //&& i != node_destroy
										index_refueling = i;
										break;
									}
								}
								//cout << " Aggiorno da " << index_refueling << endl;
								for (int t = index_refueling; t < r.index; t++) {
									//cout << " Nodo " << t << " controllo se sto dentro o devo uscire " << endl;
									if (r.refueling[t] && t != index_refueling) break;
									//cout << " Ho passato if aggiorno nodo " << t << endl;
									//cout << " Quantità fuel prima : " << r.quantity_fuel[t] << " Weigth prima " << r.weight[t] << endl;
									r.quantity_fuel[t] += add_fuel;
									r.weight[t] -= add_fuel;
									//cout << " Quantità fuel dopo : " << r.quantity_fuel[t] << " Weigth dopo " << r.weight[t] << endl;
								}
							}
						}

						//r.print();
					}
				}
				//cout << "  Si Esce quando Check = False in questo caso: " << check << endl;
				//cout << " la posizione " << first << " non va bene mi sposto.. " << endl;
				first++;
			} while (check);
		}
		index++;
	}
	return solution;
}

vector<Route> destroy_cluster(int num_passenger, vector<Passenger>& passenger_removed, vector<Route>& solution, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, vector<Passenger> all_passenegr, map<string, Passenger>& map_id_passenger) {
	int soglia_relateness = 100;
	vector<int> int_removed;
	vector<Route> route_destroyed;
	vector<Passenger> passengers;
	//srand(time(NULL));
	for (Route r : solution) route_destroyed.push_back(r);
	for (Passenger p : all_passenegr) passengers.push_back(p);
	unordered_map<string, double> CostTWPass;
	set<double, MyCOMP<double>> Myset;
	for (Passenger p : passengers) CostTWPass.insert(make_pair(p.pnr, 0));
	for (Route s : route_destroyed) {
		for (Passenger pass : s.passengers_in_route) {
			string Codpass = pass.pnr;
			CostTWPass[Codpass] += cost_time_windows_for_route_passenger(s, pass);
			Myset.insert(cost_time_windows_for_route_passenger(s, pass));
			//cout << " con un costo della TW ---> " << cost_time_windows_for_route_passenger(s, pass) << endl;
		}
	}
	vector<string> OrderVectore;
	for (auto x : Myset) {
		for (auto y : CostTWPass) {
			if (y.second == x) {
				OrderVectore.push_back(y.first + "|" + to_string(x));
			}
		}
	}

	for (auto x : OrderVectore) {
		string Codpass = split(x, '|')[0];
		//cout << " Adesso considero String CODPASS da passare alla relateness: " << Codpass << endl;
		for (int i = 0; i < passengers.size(); i++) {
			//cout << " Sto per chimare funzione relateness per il passeggiero " << i << endl;
			//passengers[i].print();
			// Qui adesso chimao la funzione Relateness !! 
			bool retrocedi = relateness_passenger(soglia_relateness, from_to, Codpass, passengers[i], i, passenger_removed, passengers, all_passenegr, map_id_passenger);
			//cout << " Ho appena finito la chiamata alla funzione relateness adesso ho insieme passeggieri " << passengers.size() << endl;
			if (retrocedi) i--;
		}
		//cout << " Fin'ora ho tolto numero odi passeggieri ----> " << passenger_removed.size() << " su " << num_passenger << endl;
		if (passenger_removed.size() >= num_passenger) break;
	}

	int NRimossi = 0;
	int Npass = 0;
	//for (Route r : route_destroyed) Npass += r.passengers_in_route.size();
	// Devo toglierli dalla route 
	for (Route& s : route_destroyed) {
		vector<int> int_removed;
		bool Update = false;
		int Min_From_Pass = s.index;
		int Max_To_Pass = -1;
		for (int p = 0; p < s.passengers_in_route.size(); p++) {
			for (Passenger pass : passenger_removed) {
				if (s.passengers_in_route[p].name == pass.name && s.passengers_in_route[p].surname == pass.surname && s.passengers_in_route[p].pnr == pass.pnr && s.passengers_in_route[p].code_flight == pass.code_flight && s.passengers_in_route[p].gender == pass.gender  && s.passengers_in_route[p].arrival_location == pass.arrival_location  && s.passengers_in_route[p].departure_location == pass.departure_location && s.passengers_in_route[p].weight == pass.weight) {
					Update = true;
					if (s.passengers_in_route[p].solution_from < Min_From_Pass) Min_From_Pass = s.passengers_in_route[p].solution_from;
					if (s.passengers_in_route[p].solution_to > Max_To_Pass) Max_To_Pass = s.passengers_in_route[p].solution_to;
					//cout << " devo rimuovere passeggiero dalla route dell'aereo " << s.aircraft_code << endl;
					//s.passengers_in_route[p].print();
					int_removed.push_back(p);
					for (int t = s.passengers_in_route[p].solution_from; t < s.passengers_in_route[p].solution_to; t++) {
						s.capacity[t]--;
						s.weight[t] += s.passengers_in_route[p].weight;
					}

				}
			}


		}
		for (int i = int_removed.size() - 1; i >= 0; i--) {
			//cout << int_removed[i] << endl;
			vector<Passenger>::iterator it;
			it = s.passengers_in_route.begin();
			s.passengers_in_route.erase(it + int_removed[i]);
			//cout << " Route adesso ha ---> " << s.passengers_in_route.size() << " passeggieri" << endl;
			//cout << " Stampo passeggieri dopo rimozione: " << endl;
			//for (Passenger passeggiero : s.passengers_in_route) passeggiero.print(); 
		}

		if (Update) {


			// Codice che da reduel ai nodi con refuel non massimo 
			int index_min_from = Min_From_Pass;
			for (int i = Min_From_Pass; i >= 0; i--) {
				if (s.refueling[i]) {
					index_min_from = i;
					break;
				}
			}
			for (int k = index_min_from; k < Max_To_Pass; k++) {
				if (s.refueling[k] && s.quantity_fuel[k] < map_airplane[s.aircraft_code].max_fuel) { //&& k!= node_destroy
				//cout << " Sto valutando il caso del nodo " << k << endl;
					int index_updating_from = k;
					int index_updating_to = s.index;
					int Node_min = k;
					double min_weight = s.weight[k];
					//appena aggiunto
					for (int i = Max_To_Pass; i < s.index; i++) {
						if (s.refueling[i]) break;
						Max_To_Pass = i;
					}

					for (int i = k + 1; i <= Max_To_Pass; i++) {
						//cout << " Sto guardando il nodo " << i << endl;
						//if (!(weight[i] > 0 && quantity_fuel[i] == 998)) {
						//cout << " Ho passato IF di controllo " << endl;
						if (s.refueling[i]) break;
						if (s.weight[i] < min_weight) {
							min_weight = s.weight[i];
							Node_min = i;
						}
						//}
					}
					if (Node_min >= 0) {
						for (int i = k + 1; i < s.index; i++) {
							if (s.refueling[i]) {  // && i != node_destroy ho tolto questo perchè se no se oltre quel nodo non c'è ne erano altri di fuell non trovavo un to
								index_updating_to = i;
								break;
							}
						}
						//cout << " Minimo trovato " << min_weight << endl;
						//cout << "Adesso che ho trovato il minimo devo aggiornare da ---> " << index_updating_from << endl;
						//cout << "Adesso che ho trovato il minimo devo aggiornare a ---> " << index_updating_to << endl;
						double Fuel_before = s.quantity_fuel[index_updating_from];
						//cout << " Quindi alla fine parto ad aggiornare " << index_updating_from << " dove prendo il minimo tra " << map_airplane[aircraft_code].max_fuel << " e " << quantity_fuel[index_updating_from] + min_weight << endl;
						s.quantity_fuel[index_updating_from] = min(map_airplane[s.aircraft_code].max_fuel, s.quantity_fuel[index_updating_from] + min_weight);
						s.weight[index_updating_from] -= (s.quantity_fuel[index_updating_from] - Fuel_before);
						for (int i = index_updating_from + 1; i < index_updating_to; i++) {
							s.quantity_fuel[i] += (s.quantity_fuel[index_updating_from] - Fuel_before);
							s.weight[i] -= (s.quantity_fuel[index_updating_from] - Fuel_before);
						}
					}

				}

			}




			int index_sup = s.index;
			for (int i = index_sup - 1; i > 1; i--) {

				if (s.capacity[i - 1] != 0) break;

				if (s.capacity[i - 1] == 0) {
					s.places.erase(s.places.begin() + i);
					s.time_arr.erase(s.time_arr.begin() + i);
					s.time_dep.erase(s.time_dep.begin() + i);
					s.refueling.erase(s.refueling.begin() + i);
					s.quantity_fuel.erase(s.quantity_fuel.begin() + i);
					s.weight.erase(s.weight.begin() + i);
					s.capacity.erase(s.capacity.begin() + i);
					s.index = s.index - 1;
					s.index_cap = s.index_cap - 1;

				}
			}


			if (s.index == 2 && s.capacity[0] == 0) {
				s.places.erase(s.places.begin() + 1);
				s.time_arr.erase(s.time_arr.begin() + 1);
				s.time_dep.erase(s.time_dep.begin() + 1);
				s.refueling.erase(s.refueling.begin() + 1);
				s.quantity_fuel.erase(s.quantity_fuel.begin() + 1);
				s.weight.erase(s.weight.begin() + 1);
				s.capacity.erase(s.capacity.begin() + 1);
				s.index = s.index - 1;
				s.index_cap = s.index_cap - 1;
			}

			// Questa parte qua forse si puo togliere
			//qua è la parte che ho aggiunto io (NELLI) per il problema del nodo al deposito che non si aggiorna
			if (s.places.size() == 1 && s.capacity[0] == 0) {
				s.quantity_fuel[0] = map_airplane[s.aircraft_code].max_fuel;
				s.weight[0] = map_airplane[s.aircraft_code].weight_fuel_people - map_airplane[s.aircraft_code].max_fuel;
			}


		}
	}




	Npass = 0;
	for (Route& s : route_destroyed) {
		Npass += (int)(s.passengers_in_route.size());
		if (s.passengers_in_route.size() == 0) s.primo_pass = false;
	}
	//cout << " Numero di passeggieri nella route dopo averli toglierli " << Npass << endl;



	return route_destroyed;

}






//ECCO I NOSTRI REPAIR
vector <Route> repair_one(double end_day, vector<Route> routes_destroyed, map <string, Airplane>& map_airplane, vector <Passenger> passengers_removed, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {

	bool case_first_passenger = false; //if false there are no passengers and only one node in the rotue, otherwise more nodes and no passengers
	bool move_c = false;
	bool routes_infeasible = false;

	for (Passenger p : passengers_removed) {
		//cout << endl;
		//p.print();
		int best_arc_from = -1;
		int best_arc_to = -1;
		int best_route = -1;
		double best_cost = DBL_MAX;
		bool move_c = false;
		//cout << "sto valutando il pass: ";
		//p.print();

		for (int r = 0; r < routes_destroyed.size(); r++) {
			//cout << "Route: " << r << endl;
			//routes_destroyed[r].print();
			if (routes_destroyed[r].primo_pass == false) {
				if (routes_destroyed[r].index == 1) {
					//c'è solo il deposito in questo caso
					double cost = from_to[routes_destroyed[r].places[0] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
					//cout << "------------------------------------------sono la route vuota, ho costo: " << cost << endl;
					//cout << "costo caso primo passeggero: " << cost << endl;
					if (cost < best_cost) {
						best_cost = cost;
						best_route = r;
						case_first_passenger = false;
					}
				}
			}
			else {
				int arc_from = -1;
				int arc_to = -1;
				double cost_route_before = cost_single_route(routes_destroyed[r], map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
				for (int n = 0; n < routes_destroyed[r].index - 1; n++) {
					if (p.departure_location != routes_destroyed[r].places[n] || n == 0) {
						for (int n1 = n; (n1 < routes_destroyed[r].index) && (n1 - n <= p.stop+1); n1++) {
							if (p.arrival_location != routes_destroyed[r].places[n1]) {
								//cout << "sto valutando l'inserzione in: " << n << " e " << n1 << endl;
								Route r_support = routes_destroyed[r];
								Route r_for_check = r_support;
								r_for_check.update_time_for_check_repair(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip);
								//cout << "route supporto" << endl;
								//r_support.print();
								//cout << "route per il check" << endl;
								//r_for_check.print();
								if (r_for_check.time_arr[r_for_check.index - 1] <= end_day) {
								r_support.update_route_rebuilt_one(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, p, from_to_FuelConsumed);
								if ( (p.solution_to - p.solution_from <= p.stop) && route_feasible(r_support, map_airplane, end_day, from_to, location_fuel, from_to_FuelConsumed)) {
									double cost = (cost_single_route(r_support, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) + cost_time_windows_for_route_passenger(r_support, p)) - cost_route_before;
									//cout << " costo fra archi: " << n << " - " << n1 << ", ha costo " << cost << endl;
									if (best_cost > cost) {
										best_arc_from = n;
										best_arc_to = n1;
										best_route = r;
										best_cost = cost;
										move_c = false;
									}
								}
								}
							}
						}
					}
				}
			}

			//for move C
			if (routes_destroyed[r].primo_pass) {
				//if there is at least one passenger inside the route, i evaluete the possibility to put him/her inside the route with the move C
				if (routes_destroyed[r].places[routes_destroyed[r].index - 1] == p.departure_location) {
					double dist = from_to[p.departure_location + ";" + p.arrival_location];
					double time = (from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60;
					//cout << "tempo di volo: " << time << endl;
					double fuel_consumed = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*if (time <= 60) {
						fuel_consumed += (time / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + ((time - 60) / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}*/

					double time_window_cost = 0.0;
					double t_arr_departure = routes_destroyed[r].time_arr[routes_destroyed[r].index - 1];
					double t_arr_arrival = routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time;
					if (t_arr_departure < p.early_departure) time_window_cost += p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) time_window_cost += t_arr_departure - p.late_departure;
					if (t_arr_arrival < p.early_arrival) time_window_cost += p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) time_window_cost += t_arr_arrival - p.late_arrival;

					double cost = dist + time_window_cost;
					//cout << "------------------------------------------sono la mossa c, ho costo: " << cost << endl;
					//cout << "cost for move c" << cost << endl;
					//cout << t_arr_arrival << " : tempo arrivo" << endl;
					if (best_cost > cost && routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time <= end_day && routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = r;
						move_c = true;
						best_arc_from = -2;
						best_arc_to = -2;
					}
				}
				else {
					// the departure is not equals to the last place of the route
					double cost = from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
					double TW_departure = 0.0;
					double t_arr_departure = routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + (((from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
					if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

					double TW_arrival = 0.0;
					double t_arr_arrival = t_arr_departure + map_airstrip[p.departure_location].ground_time + (((from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
					if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;
					cost += TW_departure + TW_arrival;

					//per il check sul fuel:
					//double travel_primo_tratto = (from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
					double fuel_consumed_primo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location];
					/*
					if (travel_primo_tratto <= 1) {
						fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_primo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}
					*/
					//****
					//double travel_secondo_tratto = (from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
					double fuel_consumed_secondo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*
					if (travel_secondo_tratto <= 1) {
						fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}
					*/

					//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
					//refuel
					double f_after_primo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto;
					double f_after_secondo_tratto = 0.0;
					if (map_airstrip[p.departure_location].fuel) {
						f_after_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
					}
					else {
						f_after_secondo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
					}

					//cout << "------------------------------------------sono la mossa c, ho costo: " << cost << endl;
					//cout << "cost for move c" << cost << endl;
					//cout << t_arr_arrival << " : tempo arrivo" << endl;
					if (best_cost > cost && t_arr_arrival <= end_day && f_after_primo_tratto >= map_airplane[routes_destroyed[r].aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = r;
						move_c = true;
						best_arc_from = -2;
						best_arc_to = -2;
					}
				}
			}

		}

		//cout << "ho scelto la mossa mossaC (1 si, 0 no) " << move_c << "route: " << best_route << " archi: " << best_arc_from << " : " << best_arc_to << " con costo: " << best_cost << " sono una route vuota 0 si, 1 no " << routes_destroyed[best_route].primo_pass << endl;

		if (best_route == -1) {
			//cout << "********************** ha queste possibilità******************************************" << endl;
			//for (Route c : routes_destroyed) c.print();
			routes_infeasible = true;
			break;
		}
		else {
			//cout << "la mossa C: " << move_c << endl;
			//cout << "size of the vector of places" << routes_destroyed[best_route].places.size() << endl;
			//cout << "index: "<< routes_destroyed[best_route].index << " index cap: " << routes_destroyed[best_route].index_cap << endl;
			//cout << best_route << " " << best_arc_from << "---" << best_arc_to << " la route ha passeggeri: " << to_string(routes_destroyed[best_route].primo_pass) << endl;
			//p.print();
			//routes_destroyed[best_route].print();


			if (!routes_destroyed[best_route].primo_pass) {
				//i have to do the new things, 
				if (case_first_passenger == false) {
					//c'è solo il depot
					routes_destroyed[best_route].primo_pass = true;
					routes_destroyed[best_route].add_update_only_one_node_first_passanger(p, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
					//cout << "caso primo passeggero" << endl;
					//routes_destroyed[best_route].print();
				}
				else {
					//ci sono più nodi
					routes_destroyed[best_route].primo_pass = true;
					routes_destroyed[best_route].add_update_only_few_node_first_passanger(p, best_arc_from, best_arc_to, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
				}
			}
			else {

				if (move_c) {
					//i have to do the move C
					//cout << "sto facendo la mossa C" << endl;
					routes_destroyed[best_route].move_c(p, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
					//cout << "caso mossa C" << endl;
					//routes_destroyed[best_route].print();

				}
				else {
					//cout << "prima dell'inserimento speciale" << endl;
					//cout << "route prima dell'inserimento" << endl;
					//routes_destroyed[best_route].print();
					//cout << "caso inserimento speciale ------>" << best_arc_from << " - " << best_arc_to << endl;
					routes_destroyed[best_route].update_route_rebuilt_one(best_arc_from, best_arc_to, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, p, from_to_FuelConsumed);
					//routes_destroyed[best_route].print();
				}
			}


			routes_destroyed[best_route].passengers_in_route.push_back(p);
		}
	}


	if (routes_infeasible) {
		vector<Route> route_vuote;
		return route_vuote;
	}
	else {
		return routes_destroyed;
	}
}

vector<Route> two_regret_repair_aggragati(double end_day, vector<Route> routes_destroyed, map <string, Airplane>& map_airplane, vector <Passenger> passengers_removed, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {

	bool routes_infeasible = false;
	vector<double> regret_diff;
	vector<int> regret_move_c; //1 move C, 0 no move C
	vector<int> regret_best_route;
	// if -1 = infeasible, passenger can insert in no-route
	// if 0...route.size() normal inserition with the function
	vector<int> regret_arc_from;
	vector<int> regret_arc_to;
	vector<int> regret_index_pass;

	map<string, int> map_pass_aggragati; //nella stringa, che è la chiave, ci sono from/to/timedep/timearr, nell'int c'è l'indicie di tutti i valori



	//cout << "ecco il numero di passeggeri rimossi " << passengers_removed.size();
	while (!passengers_removed.empty()) {
		int index_p = 0;
		for (Passenger p : passengers_removed) {
			//p.print();

			vector<double> costs;
			vector<int> route;
			vector<int> arc_from;
			vector<int> arc_to;
			vector<int> move_c;

			/*
			cout << "stampo la matrice dei passeggeri: " << endl;
			for (auto x : map_pass_aggragati) {
				cout << x.first << " ---> " << x.second << endl;
			}
			*/

			if (map_pass_aggragati.count(p.departure_location + "/" + p.arrival_location + "/" + to_string(p.departure_time) + "/" + to_string(p.arrival_time)) >= 1) {
				//cout << "ho gia calcolato un passeggero simile a lui" << endl;

				regret_diff.push_back(regret_diff[map_pass_aggragati[p.departure_location + "/" + p.arrival_location + "/" + to_string(p.departure_time) + "/" + to_string(p.arrival_time)]]);
				regret_move_c.push_back(regret_move_c[map_pass_aggragati[p.departure_location + "/" + p.arrival_location + "/" + to_string(p.departure_time) + "/" + to_string(p.arrival_time)]]);
				regret_best_route.push_back(regret_best_route[map_pass_aggragati[p.departure_location + "/" + p.arrival_location + "/" + to_string(p.departure_time) + "/" + to_string(p.arrival_time)]]);
				regret_arc_from.push_back(regret_arc_from[map_pass_aggragati[p.departure_location + "/" + p.arrival_location + "/" + to_string(p.departure_time) + "/" + to_string(p.arrival_time)]]);
				regret_arc_to.push_back(regret_arc_to[map_pass_aggragati[p.departure_location + "/" + p.arrival_location + "/" + to_string(p.departure_time) + "/" + to_string(p.arrival_time)]]);
				regret_index_pass.push_back(regret_index_pass[map_pass_aggragati[p.departure_location + "/" + p.arrival_location + "/" + to_string(p.departure_time) + "/" + to_string(p.arrival_time)]]);


			}
			else {



				for (int r = 0; r < routes_destroyed.size(); r++) {
					//cout << "nuova route-----------> " << r << endl;
					//routes_destroyed[r].print();
					if (routes_destroyed[r].primo_pass == false) {
						if (routes_destroyed[r].index == 1) {
							//c'è solo il deposito in questo caso
							double cost = from_to[routes_destroyed[r].places[0] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
							//cout << "costo caso primo passeggero: " << cost << endl;

							//cout << "cost: " << cost << " from: " << -1 << " to: " << -1 << " route: " << r << " mossa c: " << 0 << endl;
							costs.push_back(cost);
							route.push_back(r);
							arc_from.push_back(-1);
							arc_to.push_back(-1);
							move_c.push_back(0);
						}
					}
					else {
						int arc_from1 = -1;
						int arc_to1 = -1;
						double cost_route_before = cost_single_route(routes_destroyed[r], map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
						//cout << "inizio for" << endl;
						for (int n = 0; n < routes_destroyed[r].index - 1; n++) {
							if (p.departure_location != routes_destroyed[r].places[n] || n == 0) {
								for (int n1 = n; (n1 < routes_destroyed[r].index) && (n1 - n <= p.stop + 1); n1++) {
									if (p.arrival_location != routes_destroyed[r].places[n1]) {
										Route r_support = routes_destroyed[r];
										Route r_for_check = r_support;
										r_for_check.update_time_for_check_repair(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip);
										if (r_for_check.time_arr[r_for_check.index - 1] <= end_day) {
										r_support.update_route_rebuilt_one(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, p, from_to_FuelConsumed);
										//cout << "prima della condizione" << endl;
										if ((p.solution_to - p.solution_from <= p.stop) && route_feasible(r_support, map_airplane, end_day, from_to, location_fuel, from_to_FuelConsumed)) {
											//cout << "prima che calcolo il cost" << endl;
											double cost = (cost_single_route(r_support, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) + cost_time_windows_for_route_passenger(r_support, p)) - cost_route_before;
											//cout << "dopo che calcolo il cost" << endl;
											if (costs.size() == 0) {
												//cout << "cost: " << cost << " from: " << n << " to: " << n1 << " route: " << r << " mossa c: " << 0 << endl;
												costs.push_back(cost);
												arc_from.push_back(n);
												arc_to.push_back(n1);
												route.push_back(r);
												move_c.push_back(0);
											}

											if (costs.size() >= 1) {
												if (cost != costs[costs.size() - 1]) {
													costs.push_back(cost);
													arc_from.push_back(n);
													arc_to.push_back(n1);
													route.push_back(r);
													move_c.push_back(0);
													//cout << "cost: " << cost << " from: " << n << " to: " << n1 << " route: " << r << " mossa c: " << 0 << endl;
												}
											}
											//cout << "route " << r << "archi: " << arc_from1 << " _ " << n1 << endl;
										}
										}
									}
								}
							}
						}
						//cout << "fine for" << endl;
					}

					//for move C
					if (routes_destroyed[r].primo_pass) {
						//if there is at least one passenger inside the route, i evaluete the possibility to put him/her inside the route with the move C
						if (routes_destroyed[r].places[routes_destroyed[r].index - 1] == p.departure_location) {
							//cout << "sto considerando la mossa C" << endl;
							double dist = from_to[p.departure_location + ";" + p.arrival_location];
							double time = (from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60;
							double fuel_consumed = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
							/*if (time <= 60) {
								fuel_consumed += (time / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
							}
							else {
								fuel_consumed += map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + ((time - 60) / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
							}*/

							double time_window_cost = 0.0;
							double t_arr_departure = routes_destroyed[r].time_arr[routes_destroyed[r].index - 1];
							double t_arr_arrival = routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time;
							if (t_arr_departure < p.early_departure) time_window_cost += p.early_departure - t_arr_departure;
							if (t_arr_departure > p.late_departure) time_window_cost += t_arr_departure - p.late_departure;
							if (t_arr_arrival < p.early_arrival) time_window_cost += p.early_arrival - t_arr_arrival;
							if (t_arr_arrival > p.late_arrival) time_window_cost += t_arr_arrival - p.late_arrival;

							double cost = dist + time_window_cost;
							//cout << "cost for move c" << cost << endl;
							//cout << routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time << " <= " << end_day << " && " << routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed << " >= " << map_airplane[routes_destroyed[r].aircraft_code].min_fuel << endl;
							if (routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time <= end_day && routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
								costs.push_back(cost);
								route.push_back(r);
								move_c.push_back(1);
								arc_from.push_back(-2);
								arc_to.push_back(-2);

								//cout << "cost: " << cost << " from: " << -2 << " to: " << -2 << " route: " << r << " mossa c: " << 1 << endl;
							}
						}
						else {
							// the departure is not equals to the last place of the route
							double cost = from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
							double TW_departure = 0.0;
							double t_arr_departure = routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + (((from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
							if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
							if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

							double TW_arrival = 0.0;
							double t_arr_arrival = t_arr_departure + map_airstrip[p.departure_location].ground_time + (((from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
							if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
							if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;
							cost += TW_departure + TW_arrival;

							//per il check sul fuel:
							//double travel_primo_tratto = (from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
							double fuel_consumed_primo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location];
							/*if (travel_primo_tratto <= 1) {
								fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
							}
							else {
								fuel_consumed_primo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
							}*/
							//****
							//double travel_secondo_tratto = (from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
							double fuel_consumed_secondo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
							/*if (travel_secondo_tratto <= 1) {
								fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
							}
							else {
								fuel_consumed_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
							}*/

							//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
							//refuel
							double f_after_primo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto;
							double f_after_secondo_tratto = 0.0;
							if (map_airstrip[p.departure_location].fuel) {
								f_after_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
							}
							else {
								f_after_secondo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
							}

							//cout << "cost for move c" << cost << endl;
							//cout << t_arr_arrival << " <= " << end_day << " && " << f_after_primo_tratto << " >= " << map_airplane[routes_destroyed[r].aircraft_code].min_fuel << " && " << f_after_secondo_tratto << " >= " << map_airplane[routes_destroyed[r].aircraft_code].min_fuel << endl;
							if (t_arr_arrival <= end_day && f_after_primo_tratto >= map_airplane[routes_destroyed[r].aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
								costs.push_back(cost);
								move_c.push_back(1);
								arc_from.push_back(-2);
								arc_to.push_back(-2);
								route.push_back(r);

								//cout << "cost: " << cost << " from: " << -2 << " to: " << -2 << " route: " << r << " mossa c: " << 1 << endl;

							}
						}
					}

					//cout << "prima degli if" << endl;

				}



				if (costs.size() == 1) {

					//cout << "il passegero:";
					//p.print();
					//cout << " ha solo una mossa di inserimento possibile" << endl;


					//regret_diff.push_back(0);
					regret_diff.push_back(0);  //metto valore zero ma non dovrebbe succedere
					regret_best_route.push_back(route[0]);
					regret_move_c.push_back(move_c[0]);
					regret_arc_from.push_back(arc_from[0]);
					regret_arc_to.push_back(arc_to[0]);
					regret_index_pass.push_back(index_p);
				}
				else if (costs.size() > 1) {
					//qua lo posso ottimizzare****************************************************************************************************************************************
					//con il codice di TED per ordinare, guarda bene come salvare l'indice********************************************************************************************

					double best_cost = DBL_MAX;
					double best_cost_2 = DBL_MAX;
					double index_mosse = -1;
					for (int i = 0; i < costs.size(); i++) {
						//cout << "questi sono i costi" << costs[i] << endl;
						if (best_cost > costs[i]) {
							best_cost = costs[i];
							index_mosse = i;
						}
						if (best_cost_2 > costs[i] && costs[i] > best_cost) {
							best_cost_2 = costs[i];
						}

					}

					/*
					for (int i = 0; i < costs.size(); i++) {
						if (best_cost_2 > costs[i] && costs[i] > best_cost) {
							best_cost_2 = costs[i];
						}
					}
					*/
					//cout << "best cost: " << best_cost << endl;
					//cout << "best cost 2: " << best_cost_2 << endl;

					regret_diff.push_back(best_cost_2 - best_cost);
					regret_best_route.push_back(route[index_mosse]);
					regret_move_c.push_back(move_c[index_mosse]);
					regret_arc_from.push_back(arc_from[index_mosse]);
					regret_arc_to.push_back(arc_to[index_mosse]);
					regret_index_pass.push_back(index_p);
				}
				else {
					//caso in cui non ha trovato mosse per quella persona
					//in questo caso vuol dire che la solutione è infeasible
					cout << "LA SOLUZIONE E' INFEASIBLE" << endl;
					vector<Route> route_vuote;
					return route_vuote;

				}

				//cout << "regret.size() - 1 " << (regret_diff.size() - 1) << endl;
				int val = regret_diff.size() - 1;
				//cout << val << endl;
				string primo_val = p.departure_location + "/" + p.arrival_location + "/" + to_string(p.departure_time) + "/" + to_string(p.arrival_time);
				map_pass_aggragati.insert(make_pair(primo_val, val));
				//cout << map_pass_aggragati[primo_val] << endl;


				costs.clear();
				route.clear();
				arc_from.clear();
				arc_to.clear();
				move_c.clear();

			}

			index_p++;
		}

		//cout << "regret.size(): " << regret_best_route.size() << endl;




		int index = 0;
		int best = -10000;
		for (int i = 0; i < regret_diff.size(); i++) {
			//cout << "***********" << regret_diff[i] << endl;

			if (best < regret_diff[i]) {
				index = i;
				best = regret_diff[i];
			}
		}

		/*
		cout << "mossa scelta" << endl;
		cout << "index " << index << endl;
		cout << " - " << regret_diff[index] << endl;
		cout << " - " << regret_best_route[index] << endl;
		cout << " - " << regret_move_c[index] << endl;
		cout << " - " << regret_arc_from[index] << endl;
		cout << " - " << regret_arc_to[index] << endl;


		cout << "ecco tutti i valori" << endl;
		for (int i = 0; i < regret_best_route.size(); i++) {
			cout << "routes: " << regret_best_route[i] << endl;
			cout << " - " << regret_diff[i] << endl;
			cout << " - " << regret_move_c[i] << endl;
			cout << " - " << regret_arc_from[i] << endl;
			cout << " - " << regret_arc_to[i] << endl;
		}
		*/


		//cout << "ecco la route" << endl;
		//routes_destroyed[regret_best_route[index]].print();
		//cout << "condizione dell'IF grande: " << routes_destroyed[regret_best_route[index]].primo_pass << endl;

		//cout << "prima dell'inserimento" << endl;
		//cout << regret_best_route[index] << "index" << endl;
		//cout << best << endl;
		//cout << routes_destroyed[regret_best_route[index]].primo_pass << " primo pass" << endl;
		//cout << regret_move_c[index] << "move C" << endl;
		if (!routes_destroyed[regret_best_route[index]].primo_pass) {
			//c'è solo il depot
		//cout << "devo mettere il passeggero dentro" << endl;
			routes_destroyed[regret_best_route[index]].primo_pass = true;
			routes_destroyed[regret_best_route[index]].add_update_only_one_node_first_passanger(passengers_removed[regret_index_pass[index]], from_to, map_airplane, map_airstrip, from_to_FuelConsumed);

		}
		else {

			if (regret_move_c[index] == 1) {
				//i have to do the move C
				//cout << "devo mettere il passeggero dentro" << endl;
				routes_destroyed[regret_best_route[index]].move_c(passengers_removed[regret_index_pass[index]], passengers_removed[regret_index_pass[index]].departure_location, passengers_removed[regret_index_pass[index]].arrival_location, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
			}
			else {
				//cout << "devo mettere il passeggero dentro" << endl;
				routes_destroyed[regret_best_route[index]].update_route_rebuilt_one(regret_arc_from[index], regret_arc_to[index], passengers_removed[regret_index_pass[index]].departure_location, passengers_removed[regret_index_pass[index]].arrival_location, from_to, map_airplane, map_airstrip, passengers_removed[regret_index_pass[index]], from_to_FuelConsumed);
				//cout << "ho messo il passeggero dentro" << endl;
			}
		}


		routes_destroyed[regret_best_route[index]].passengers_in_route.push_back(passengers_removed[regret_index_pass[index]]);


		//QUA DEVO TOGLIERE IL PASSEGGERO CHE HO APPENA INSERITO DAL POOL DI PASSENGERS_REMOVED
		vector<Passenger>::iterator it;
		it = passengers_removed.begin();
		passengers_removed.erase(it + regret_index_pass[index]);



		regret_diff.clear();
		regret_move_c.clear(); //1 move C, 0 no move C
		regret_best_route.clear();
		regret_arc_from.clear();
		regret_arc_to.clear();
		regret_index_pass.clear();
		map_pass_aggragati.clear();


		//cout << "size dei passeggeri rimossi " << passengers_removed.size() << endl;
	}


	return routes_destroyed;

}

vector<Route> casual_choice_repair(double end_day, vector<Route> routes_destroyed, map <string, Airplane>& map_airplane, vector <Passenger> passengers_removed, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {

	bool routes_infeasible = false;



	for (Passenger p : passengers_removed) {
		//cout << "sto valutando il pass: ";
		//p.print();
		vector<double> costs;
		vector<int> move_c; //1 move C, 0 no move C
		vector<int> index_route;
		// if -1 = infeasible, passenger can insert in no-route
		// if 0...route.size() normal inserition with the function
		vector<int> arc_from;
		vector<int> arc_to;
		int check = 0;
		int index = -1;

		for (int r = 0; r < routes_destroyed.size(); r++) {
			if (routes_destroyed[r].primo_pass == false) {
				if (routes_destroyed[r].index == 1) {
					//c'è solo il deposito in questo caso
					double cost = from_to[routes_destroyed[r].places[0] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
					//cout << "costo caso primo passeggero: " << cost << endl;

					costs.push_back(cost);
					index_route.push_back(r);
					arc_from.push_back(-1);
					arc_to.push_back(-1);
					move_c.push_back(0);
				}
			}
			else {
				int arc_from1 = -1;
				int arc_to1 = -1;
				double cost_route_before = cost_single_route(routes_destroyed[r], map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
				//cout << "inizio for" << endl;
				for (int n = 0; n < routes_destroyed[r].index - 1; n++) {
					if (p.departure_location != routes_destroyed[r].places[n] || n == 0) {
						for (int n1 = n; (n1 < routes_destroyed[r].index) && (n1 - n <= p.stop + 1); n1++) {
							if (p.arrival_location != routes_destroyed[r].places[n1]) {
								Route r_support = routes_destroyed[r];
								Route r_for_check = r_support;
								r_for_check.update_time_for_check_repair(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip);
								if (r_for_check.time_arr[r_for_check.index - 1] <= end_day) {
								r_support.update_route_rebuilt_one(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, p, from_to_FuelConsumed);
								//cout << "prima della condizione" << endl;
								if ((p.solution_to - p.solution_from <= p.stop) && route_feasible(r_support, map_airplane, end_day, from_to, location_fuel, from_to_FuelConsumed)) {
									//cout << "prima che calcolo il cost" << endl;
									double cost = (cost_single_route(r_support, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) + cost_time_windows_for_route_passenger(r_support, p)) - cost_route_before;
									//cout << "dopo che calcolo il cost" << endl;
									if (costs.size() == 0) {
										costs.push_back(cost);
										arc_from.push_back(n);
										arc_to.push_back(n1);
										index_route.push_back(r);
										move_c.push_back(0);
									}
									if (costs.size() >= 1) {
										if (cost != costs[costs.size() - 1]) {
											costs.push_back(cost);
											arc_from.push_back(n);
											arc_to.push_back(n1);
											index_route.push_back(r);
											move_c.push_back(0);
										}
									}
									//cout << "route " << r << "archi: " << arc_from1 << " _ " << n1 << endl;
								}
								}
							}
						}

					}
				}
				//cout << "fine for" << endl;
			}

			//for move C
			if (routes_destroyed[r].primo_pass) {
				//if there is at least one passenger inside the route, i evaluete the possibility to put him/her inside the route with the move C
				if (routes_destroyed[r].places[routes_destroyed[r].index - 1] == p.departure_location) {
					double dist = from_to[p.departure_location + ";" + p.arrival_location];
					double time = (from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60;
					double fuel_consumed = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*if (time <= 60) {
						fuel_consumed += (time / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + ((time - 60) / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}*/

					double time_window_cost = 0.0;
					double t_arr_departure = routes_destroyed[r].time_arr[routes_destroyed[r].index - 1];
					double t_arr_arrival = routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time;
					if (t_arr_departure < p.early_departure) time_window_cost += p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) time_window_cost += t_arr_departure - p.late_departure;
					if (t_arr_arrival < p.early_arrival) time_window_cost += p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) time_window_cost += t_arr_arrival - p.late_arrival;

					double cost = dist + time_window_cost;
					//cout << "cost for move c" << cost << endl;
					if (routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time <= end_day && routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
						costs.push_back(cost);
						index_route.push_back(r);
						move_c.push_back(1);
						arc_from.push_back(-2);
						arc_to.push_back(-2);
					}
				}
				else {
					// the departure is not equals to the last place of the route
					double cost = from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
					double TW_departure = 0.0;
					double t_arr_departure = routes_destroyed[r].time_arr[routes_destroyed[r].index - 1] + map_airstrip[routes_destroyed[r].places[routes_destroyed[r].index - 1]].ground_time + (((from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
					if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

					double TW_arrival = 0.0;
					double t_arr_arrival = t_arr_departure + map_airstrip[p.departure_location].ground_time + (((from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
					if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;
					cost += TW_departure + TW_arrival;

					//per il check sul fuel:
					//double travel_primo_tratto = (from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
					double fuel_consumed_primo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location];
					/*
					if (travel_primo_tratto <= 1) {
						fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_primo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}
					*/
					//****
					//double travel_secondo_tratto = (from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
					double fuel_consumed_secondo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*if (travel_secondo_tratto <= 1) {
						fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}*/

					//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
					//refuel
					double f_after_primo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto;
					double f_after_secondo_tratto = 0.0;
					if (map_airstrip[p.departure_location].fuel) {
						f_after_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
					}
					else {
						f_after_secondo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
					}

					//cout << "cost for move c" << cost << endl;
					if (t_arr_arrival <= end_day && f_after_primo_tratto >= map_airplane[routes_destroyed[r].aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
						costs.push_back(cost);
						move_c.push_back(1);
						arc_from.push_back(-2);
						arc_to.push_back(-2);
						index_route.push_back(r);
					}
				}
			}

			//cout << "prima degli if" << endl;
		}


		bool infeasible_sol = false;

		if (costs.size() == 1) {
			//non posso pescare in modo random
			//cout << "ho solo una mossa possibile" << endl;
			//cout << "in teoria qui ho size 0" << endl;
			index = 0;
		}
		else if (costs.size() > 1) {
			//cout << "in teoria qui ho size maggiore di 0" << endl;
			//scelgo un numero random fra le mosse possibili per il passeggero
			if (costs.size() <= 3) {
				//cout << "ho meno di 3 mosse possibili" << endl;
				double f = (double)rand() / RAND_MAX;
				f = 0 + f * costs.size();
				index = floor(f);
				//cout << "index, caso minore di tre: " << index << endl;
			}
			else {
				//cout << "ho più di 3 mosse possibili" << endl;
				map<double, int> Node;
				map<int, int> NodeOrder;
				set<double, MyCOMP1<double>> Myset;

				for (int i = 0; i < costs.size(); i++) {
					Node.insert(make_pair(costs[i], i));
					Myset.insert(costs[i]);
				}

				//stampo per check
				/*
				cout << "nodi con costi ordinati" << endl;
				for (auto x : Node) {
					cout << "cost: " << x.first << " ---> " << x.second << endl;
				}


				cout << "indici  ordinati" << endl;
				*/
				int i = 0;
				for (auto setval : Myset) {
					NodeOrder.insert(make_pair(i, Node[setval]));
					i++;
				}

				/*
				for (auto x : NodeOrder) {
					cout << "index: " << x.first << " ---> " << x.second << endl;
				}
				*/


				double f = (double)rand() / RAND_MAX;
				f = 0 + f * 3;
				int t = floor(f);
				index = NodeOrder[t];

				/*
				cout << "numero random generato: " << t << endl;
				cout << "index, caso maggiore di tre: " << index << endl;
				cout << "quindi...." << endl;
				cout << "la route ha indice: " << index_route[index] << endl;
				cout << "ha costo " << costs[index] << endl;
				cout << "con arco from: " << arc_from[index] << endl;
				cout << "con arco to: " << arc_to[index] << endl;
				cout << " mossa C (1 si, 0 no)" << move_c[index] << endl;
				*/
				/*
				cout << endl;
				cout << "la route ha indice: " << index_route.size() << endl;
				cout << "ha costo " << costs.size() << endl;
				cout << "con arco from: " << arc_from.size() << endl;
				cout << "con arco to: " << arc_to.size() << endl;
				cout << " mossa C (1 si, 0 no)" << move_c.size() << endl;
				*/
			}

		}
		else {
			//caso in cui non ha trovato mosse per quella route
			//cout << "in teoria qui ho size 0" << endl; 
			infeasible_sol = true;

		}




		if (infeasible_sol) {
			//cout << "********************** ha queste possibilità******************************************" << endl;
			//p.print();
			//cout << endl;
			//for (Route c : routes_destroyed) c.print();
			routes_infeasible = true;
			break;
		}
		else {
			//cout << "index_route.size() = " << index_route.size() << endl;
			//cout << "index: " << index << endl;
			//cout << index_route[index] << " :index_route" << endl;
			if (!routes_destroyed[index_route[index]].primo_pass) {
				//c'è solo il depot
			//cout << "devo mettere il passeggero dentro" << endl;
				routes_destroyed[index_route[index]].primo_pass = true;
				routes_destroyed[index_route[index]].add_update_only_one_node_first_passanger(p, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);

			}
			else {

				if (move_c[index] == 1) {
					//i have to do the move C
					//cout << "devo mettere il passeggero dentro" << endl;
					routes_destroyed[index_route[index]].move_c(p, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
				}
				else {
					//cout << "devo mettere il passeggero dentro" << endl;
					routes_destroyed[index_route[index]].update_route_rebuilt_one(arc_from[index], arc_to[index], p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, p, from_to_FuelConsumed);
					//cout << "ho messo il passeggero dentro" << endl;
				}
			}


			routes_destroyed[index_route[index]].passengers_in_route.push_back(p);
		}




		costs.clear();
		index_route.clear();
		arc_from.clear();
		arc_to.clear();
		move_c.clear();


	}


	if (routes_infeasible) {
		vector<Route> route_vuote;
		return route_vuote;
	}
	else {
		return routes_destroyed;
	}
}

vector <Route> repair_forbidden(double end_day, vector<Route> routes_destroyed, map <string, Airplane>& map_airplane, vector <Passenger> passengers_removed, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {

	bool case_first_passenger = false; //if false there are no passengers and only one node in the rotue, otherwise more nodes and no passengers
	bool move_c = false;
	bool routes_infeasible = false;

	for (Passenger p : passengers_removed) {
		//p.print();
		int best_arc_from = -1;
		int best_arc_to = -1;
		int best_route = -1;
		double best_cost = DBL_MAX;
		bool move_c = false;
		//cout << "sto valutando il pass: ";
		//p.print();

		for (int r = 0; r < routes_destroyed.size(); r++) {
			if (routes_destroyed[r].primo_pass == false) {
				if (routes_destroyed[r].index == 1) {
					//c'è solo il deposito in questo caso
					double cost = from_to[routes_destroyed[r].places[0] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
					//cout << "------------------------------------------sono la route vuota, ho costo: " << cost << endl;
					//cout << "costo caso primo passeggero: " << cost << endl;
					//cout << r << " != " << p.route_before << endl;
					if (cost < best_cost && r != p.route_before) {
						best_cost = cost;
						best_route = r;
						case_first_passenger = false;
					}
				}
			}
			else {
				int arc_from = -1;
				int arc_to = -1;
				if (r != p.route_before) {
					double cost_route_before = cost_single_route(routes_destroyed[r], map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
					for (int n = 0; n < routes_destroyed[r].index - 1; n++) {
						if (p.departure_location != routes_destroyed[r].places[n] || n == 0) {
							for (int n1 = n; (n1 < routes_destroyed[r].index) && (n1 - n <= p.stop + 1); n1++) {
								if (p.arrival_location != routes_destroyed[r].places[n1]) {
									Route r_support = routes_destroyed[r];
									Route r_for_check = r_support;
									r_for_check.update_time_for_check_repair(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip);
									if (r_for_check.time_arr[r_for_check.index - 1] <= end_day) {
									r_support.update_route_rebuilt_one(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, p, from_to_FuelConsumed);
									if ((p.solution_to - p.solution_from <= p.stop) && route_feasible(r_support, map_airplane, end_day, from_to, location_fuel, from_to_FuelConsumed)) {
										double cost = (cost_single_route(r_support, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) + cost_time_windows_for_route_passenger(r_support, p)) - cost_route_before;
										if (best_cost > cost) {
											best_arc_from = n;
											best_arc_to = n1;
											best_route = r;
											best_cost = cost;
											move_c = false;
										}
									}
									}
								}
							}
						}
					}
				}
			}

			//for move C
			if (routes_destroyed[r].primo_pass && r != p.route_before) {
				//if there is at least one passenger inside the route, i evaluete the possibility to put him/her inside the route with the move C
				if (routes_destroyed[r].places[routes_destroyed[r].index - 1] == p.departure_location) {
					double dist = from_to[p.departure_location + ";" + p.arrival_location];
					double time = (from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60;
					//cout << "tempo di volo: " << time << endl;
					double fuel_consumed = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*if (time <= 60) {
						fuel_consumed += (time / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + ((time - 60) / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}*/

					double time_window_cost = 0.0;
					double t_arr_departure = routes_destroyed[r].time_arr[routes_destroyed[r].index - 1];
					double t_arr_arrival = routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time;
					if (t_arr_departure < p.early_departure) time_window_cost += p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) time_window_cost += t_arr_departure - p.late_departure;
					if (t_arr_arrival < p.early_arrival) time_window_cost += p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) time_window_cost += t_arr_arrival - p.late_arrival;

					double cost = dist + time_window_cost;
					//cout << "------------------------------------------sono la mossa c, ho costo: " << cost << endl;
					//cout << "cost for move c" << cost << endl;
					//cout << t_arr_arrival << " : tempo arrivo" << endl;
					//cout << r << " != " << p.route_before << endl;
					if (best_cost > cost && routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time <= end_day && routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = r;
						move_c = true;
						best_arc_from = -2;
						best_arc_to = -2;
					}
				}
				else {
					// the departure is not equals to the last place of the route
					double cost = from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
					double TW_departure = 0.0;
					double t_arr_departure = routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + (((from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
					if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

					double TW_arrival = 0.0;
					double t_arr_arrival = t_arr_departure + map_airstrip[p.departure_location].ground_time + (((from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
					if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;
					cost += TW_departure + TW_arrival;

					//per il check sul fuel:
					//double travel_primo_tratto = (from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
					double fuel_consumed_primo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location];
					/*if (travel_primo_tratto <= 1) {
						fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_primo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}*/
					//****
					//double travel_secondo_tratto = (from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
					double fuel_consumed_secondo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*if (travel_secondo_tratto <= 1) {
						fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}*/

					//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
					//refuel
					double f_after_primo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto;
					double f_after_secondo_tratto = 0.0;
					if (map_airstrip[p.departure_location].fuel) {
						f_after_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
					}
					else {
						f_after_secondo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
					}

					//cout << "------------------------------------------sono la mossa c, ho costo: " << cost << endl;
					//cout << "cost for move c" << cost << endl;
					//cout << t_arr_arrival << " : tempo arrivo" << endl;
					//cout << r << " != " << p.route_before << endl;
					if (best_cost > cost && t_arr_arrival <= end_day && f_after_primo_tratto >= map_airplane[routes_destroyed[r].aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = r;
						move_c = true;
						best_arc_from = -2;
						best_arc_to = -2;
					}
				}
			}

		}

		//cout << "ho scelto la mossa mossaC (1 si, 0 no) " << move_c << "route: " << best_route << " archi: " << best_arc_from << " : " << best_arc_to << " con costo: " << best_cost << " sono una route vuota 0 si, 1 no " << routes_destroyed[best_route].primo_pass << endl;

		if (best_route == -1) {
			//cout << "********************** ha queste possibilità******************************************" << endl;
			//for (Route c : routes_destroyed) c.print();
			routes_infeasible = true;
			break;
		}
		else {
			//cout << "la mossa C: " << move_c << endl;
			//cout << "size of the vector of places" << routes_destroyed[best_route].places.size() << endl;
			//cout << "index: "<< routes_destroyed[best_route].index << " index cap: " << routes_destroyed[best_route].index_cap << endl;
			//cout << best_route << " " << best_arc_from << "---" << best_arc_to << " la route ha passeggeri: " << to_string(routes_destroyed[best_route].primo_pass) << endl;
			//p.print();
			//routes_destroyed[best_route].print();


			if (!routes_destroyed[best_route].primo_pass) {
				//i have to do the new things, 
				if (case_first_passenger == false) {
					//c'è solo il depot
					routes_destroyed[best_route].primo_pass = true;
					routes_destroyed[best_route].add_update_only_one_node_first_passanger(p, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
				}
				else {
					//ci sono più nodi
					routes_destroyed[best_route].primo_pass = true;
					routes_destroyed[best_route].add_update_only_few_node_first_passanger(p, best_arc_from, best_arc_to, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
				}
			}
			else {

				if (move_c) {
					//i have to do the move C
					//cout << "sto facendo la mossa C" << endl;
					routes_destroyed[best_route].move_c(p, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
					//cout << "dopo la mossa C" << endl;
				}
				else {
					//cout << "prima dell'inserimento speciale" << endl;
					routes_destroyed[best_route].update_route_rebuilt_one(best_arc_from, best_arc_to, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, p, from_to_FuelConsumed);
					//cout << "dopo dell'inserimento speciale" << endl;
				}
			}


			routes_destroyed[best_route].passengers_in_route.push_back(p);
		}
	}


	if (routes_infeasible) {
		vector<Route> route_vuote;
		return route_vuote;
	}
	else {
		return routes_destroyed;
	}
}

vector <Route> repair_perturbation(double end_day, vector<Route> routes_destroyed, map <string, Airplane>& map_airplane, vector <Passenger> passengers_removed, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {

	bool case_first_passenger = false; //if false there are no passengers and only one node in the rotue, otherwise more nodes and no passengers
	bool move_c = false;
	bool routes_infeasible = false;

	for (Passenger p : passengers_removed) {
		//p.print();
		int best_arc_from = -1;
		int best_arc_to = -1;
		int best_route = -1;
		double best_cost = DBL_MAX;
		bool move_c = false;
		//cout << "sto valutando il pass: ";
		//p.print();

		for (int r = 0; r < routes_destroyed.size(); r++) {
			if (routes_destroyed[r].primo_pass == false) {
				if (routes_destroyed[r].index == 1) {
					//c'è solo il deposito in questo caso
					double cost = from_to[routes_destroyed[r].places[0] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
					//cout << "------------------------------------------sono la route vuota, ho costo: " << cost << endl;
					//cout << "costo caso primo passeggero: " << cost << endl;

					//code for casual number [0.8;1.2]*****************************************************
					double f = (double)rand() / RAND_MAX;
					f = 0.8 + (f * 0.4);
					cost = cost * f;
					//**************************************************************************************

					if (cost < best_cost) {
						best_cost = cost;
						best_route = r;
						case_first_passenger = false;
					}
				}
			}
			else {
				int arc_from = -1;
				int arc_to = -1;
				double cost_route_before = cost_single_route(routes_destroyed[r], map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
				for (int n = 0; n < routes_destroyed[r].index - 1; n++) {
					if (p.departure_location != routes_destroyed[r].places[n] || n == 0) {
						for (int n1 = n; (n1 < routes_destroyed[r].index) && (n1 - n <= p.stop + 1); n1++) {
							if (p.arrival_location != routes_destroyed[r].places[n1]) {
								Route r_support = routes_destroyed[r];
								Route r_for_check = r_support;
								r_for_check.update_time_for_check_repair(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip);
								if (r_for_check.time_arr[r_for_check.index - 1] <= end_day) {
								r_support.update_route_rebuilt_one(n, n1, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, p, from_to_FuelConsumed);
								if ((p.solution_to - p.solution_from <= p.stop) && route_feasible(r_support, map_airplane, end_day, from_to, location_fuel, from_to_FuelConsumed)) {
									double cost = (cost_single_route(r_support, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) + cost_time_windows_for_route_passenger(r_support, p)) - cost_route_before;

									//code for casual number [0.8;1.2]*****************************************************
									double f = (double)rand() / RAND_MAX;
									f = 0.8 + (f * 0.4);
									cost = cost * f;
									//*************************************************************************************

									if (best_cost > cost) {
										best_arc_from = n;
										best_arc_to = n1;
										best_route = r;
										best_cost = cost;
										move_c = false;
									}
								}
								}
							}
						}
					}
				}
			}

			//for move C
			if (routes_destroyed[r].primo_pass) {
				//if there is at least one passenger inside the route, i evaluete the possibility to put him/her inside the route with the move C
				if (routes_destroyed[r].places[routes_destroyed[r].index - 1] == p.departure_location) {
					double dist = from_to[p.departure_location + ";" + p.arrival_location];
					double time = (from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60;
					//cout << "tempo di volo: " << time << endl;
					double fuel_consumed = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*if (time <= 60) {
						fuel_consumed += (time / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed += map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + ((time - 60) / 60)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}*/

					double time_window_cost = 0.0;
					double t_arr_departure = routes_destroyed[r].time_arr[routes_destroyed[r].index - 1];
					double t_arr_arrival = routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time;
					if (t_arr_departure < p.early_departure) time_window_cost += p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) time_window_cost += t_arr_departure - p.late_departure;
					if (t_arr_arrival < p.early_arrival) time_window_cost += p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) time_window_cost += t_arr_arrival - p.late_arrival;

					double cost = dist + time_window_cost;

					//code for casual number [0.8;1.2]*****************************************************
					double f = (double)rand() / RAND_MAX;
					f = 0.8 + (f * 0.4);
					cost = cost * f;
					//**************************************************************************************


					if (best_cost > cost && routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + time <= end_day && routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = r;
						move_c = true;
						best_arc_from = -2;
						best_arc_to = -2;
					}
				}
				else {
					// the departure is not equals to the last place of the route
					double cost = from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];
					double TW_departure = 0.0;
					double t_arr_departure = routes_destroyed[r].time_dep[routes_destroyed[r].index - 1] + (((from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
					if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

					double TW_arrival = 0.0;
					double t_arr_arrival = t_arr_departure + map_airstrip[p.departure_location].ground_time + (((from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed) * 60);
					if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;
					cost += TW_departure + TW_arrival;

					//per il check sul fuel:
					//double travel_primo_tratto = (from_to[routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
					double fuel_consumed_primo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + routes_destroyed[r].places[routes_destroyed[r].index - 1] + ";" + p.departure_location];
					/*if (travel_primo_tratto <= 1) {
						fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_primo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}*/
					//****
					//double travel_secondo_tratto = (from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[routes_destroyed[r].aircraft_code].speed;
					double fuel_consumed_secondo_tratto = from_to_FuelConsumed[routes_destroyed[r].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*if (travel_secondo_tratto <= 1) {
						fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[routes_destroyed[r].aircraft_code].fuel_burn_second;
					}*/

					//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
					//refuel
					double f_after_primo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto;
					double f_after_secondo_tratto = 0.0;
					if (map_airstrip[p.departure_location].fuel) {
						f_after_secondo_tratto = map_airplane[routes_destroyed[r].aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
					}
					else {
						f_after_secondo_tratto = routes_destroyed[r].quantity_fuel[routes_destroyed[r].index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
					}


					//code for casual number [0.8;1.2]*****************************************************
					double f = (double)rand() / RAND_MAX;
					f = 0.8 + (f * 0.4);
					cost = cost * f;
					//**************************************************************************************


					if (best_cost > cost && t_arr_arrival <= end_day && f_after_primo_tratto >= map_airplane[routes_destroyed[r].aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[routes_destroyed[r].aircraft_code].min_fuel + location_fuel[routes_destroyed[r].aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = r;
						move_c = true;
						best_arc_from = -2;
						best_arc_to = -2;
					}
				}
			}

		}

		//cout << "ho scelto la mossa mossaC (1 si, 0 no) " << move_c << "route: " << best_route << " archi: " << best_arc_from << " : " << best_arc_to << " con costo: " << best_cost << " sono una route vuota 0 si, 1 no " << routes_destroyed[best_route].primo_pass << endl;

		if (best_route == -1) {
			//cout << "********************** ha queste possibilità******************************************" << endl;
			//for (Route c : routes_destroyed) c.print();
			routes_infeasible = true;
			break;
		}
		else {
			//cout << "la mossa C: " << move_c << endl;
			//cout << "size of the vector of places" << routes_destroyed[best_route].places.size() << endl;
			//cout << "index: "<< routes_destroyed[best_route].index << " index cap: " << routes_destroyed[best_route].index_cap << endl;
			//cout << best_route << " " << best_arc_from << "---" << best_arc_to << " la route ha passeggeri: " << to_string(routes_destroyed[best_route].primo_pass) << endl;
			//p.print();
			//routes_destroyed[best_route].print();


			if (!routes_destroyed[best_route].primo_pass) {
				//i have to do the new things, 
				if (case_first_passenger == false) {
					//c'è solo il depot
					routes_destroyed[best_route].primo_pass = true;
					routes_destroyed[best_route].add_update_only_one_node_first_passanger(p, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
				}
				else {
					//ci sono più nodi
					routes_destroyed[best_route].primo_pass = true;
					routes_destroyed[best_route].add_update_only_few_node_first_passanger(p, best_arc_from, best_arc_to, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
				}
			}
			else {

				if (move_c) {
					//i have to do the move C
					//cout << "sto facendo la mossa C" << endl;
					routes_destroyed[best_route].move_c(p, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, from_to_FuelConsumed);
					//cout << "dopo la mossa C" << endl;
				}
				else {
					//cout << "prima dell'inserimento speciale" << endl;
					routes_destroyed[best_route].update_route_rebuilt_one(best_arc_from, best_arc_to, p.departure_location, p.arrival_location, from_to, map_airplane, map_airstrip, p, from_to_FuelConsumed);
					//cout << "dopo dell'inserimento speciale" << endl;
				}
			}


			routes_destroyed[best_route].passengers_in_route.push_back(p);
		}
	}


	if (routes_infeasible) {
		vector<Route> route_vuote;
		return route_vuote;
	}
	else {
		return routes_destroyed;
	}
}








//************************************************************************************** Local Search **************************************************************
void destroy_ls(int index, int node_destroy, vector<Passenger>& passenger_removed, Route& r, map<string, Airplane> map_airplane, map<string, Airstrip> map_airstrip, map<string, double> from_to) {
	//cout << " Stampo la route prima di toccarla: " << endl;
	//r.print();
	if (r.index > 1) {
		bool check = true;
		double fuel_consumed_check = 0.0;
		if ((node_destroy + 2) < r.index) {
			//double time_travel = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy - 1]] / map_airplane[r.aircraft_code].speed; 
			double time_travel = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy + 2]] / map_airplane[r.aircraft_code].speed;
			if (time_travel <= 1) fuel_consumed_check = map_airplane[r.aircraft_code].fuel_burn_first*time_travel;
			else {
				fuel_consumed_check = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
			}
			//cout << " Deve valere che: " << fuel_consumed_check << " + " << map_airplane[r.aircraft_code].min_fuel << " <= " << r.quantity_fuel[node_destroy - 1] << endl;
		}
		if ((fuel_consumed_check + map_airplane[r.aircraft_code].min_fuel) <= r.quantity_fuel[node_destroy - 1]) {
			check = false;
			int number_initial_node = r.index;
			for (int i = 0; i < 2; i++) {
				//cout << " Sono al giro i -> " << i << endl;
				if (i == 1 && (number_initial_node - r.index) > 1) break;
				//cout << " devo distruggere il nodo -> " << node_destroy << endl;
				double fuel_consumed = 0.0;
				double time_travel = from_to[r.places[node_destroy - 1] + ";" + r.places[node_destroy + 1]] / map_airplane[r.aircraft_code].speed;
				if (time_travel <= 1) fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first*time_travel;
				else {
					fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (time_travel - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
				}
				vector<int> int_removed;
				int Min_From_Pass = node_destroy;
				int Max_To_Pass = node_destroy;
				for (int p = 0; p < r.passengers_in_route.size(); p++) {
					if (r.passengers_in_route[p].solution_to == node_destroy || r.passengers_in_route[p].solution_from == node_destroy) { // ho cambiato questa condizione
						if (r.passengers_in_route[p].solution_from < Min_From_Pass) Min_From_Pass = r.passengers_in_route[p].solution_from;
						if (r.passengers_in_route[p].solution_to > Max_To_Pass) Max_To_Pass = r.passengers_in_route[p].solution_to;
						//cout << " Aggiungo alla lista dei passegggieri il passeggiero ";
						//r.passengers_in_route[p].print();
						int_removed.push_back(p);
						for (int t = r.passengers_in_route[p].solution_from; t < r.passengers_in_route[p].solution_to; t++) {
							r.capacity[t]--;
							r.weight[t] += r.passengers_in_route[p].weight;
							/*
							if (r.refueling[t] && r.quantity_fuel[t] < map_airplane[r.aircraft_code].max_fuel) {
							r.weight[t] -= min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight) - r.quantity_fuel[t];
							r.quantity_fuel[t] = min(map_airplane[r.aircraft_code].max_fuel, r.quantity_fuel[t] + r.passengers_in_route[p].weight);
							}
							*/
						}

					}
				}

				for (int i = int_removed.size() - 1; i >= 0; i--) {
					// code for repair forbidden***********************************************************
					r.passengers_in_route[int_removed[i]].route_before = index;
					//*************************************************************************************
					passenger_removed.push_back(r.passengers_in_route[int_removed[i]]);
					vector<Passenger>::iterator it;
					it = r.passengers_in_route.begin();
					r.passengers_in_route.erase(it + int_removed[i]);
				}
				//cout << " Sono alla riga 5946 dentro al detroy ho numero di passeggieri rimossi pari a " << passenger_removed.size() << endl;
				r.update_route_destroy(node_destroy, Min_From_Pass, Max_To_Pass, from_to, map_airplane, map_airstrip); //update of the time
				//r.print();
				int index_before = node_destroy - 1;
				//cout << " ************************* Ho finito  codice stampo route aggiornata gli devo ancora togliere nodo  **********************************" << endl;
				//r.print();
				//cout << " Adessos sto iniziando a sistemare i pesi perche togliero nodo del aereo " << r.aircraft_code << endl;
				double diff = 0;
				//cout << " Index before: " << index_before << endl;
				for (int i = node_destroy + 1; i < r.index; i++) {
					//cout << " sono al i = " << i << endl;
					if (r.refueling[i]) break;
					//cout << "weight before: " << r.weight[i] << endl;
					if (index_before == (node_destroy - 1)) {
						//cout << " sono al primo giro faccio " << endl;
						diff = r.quantity_fuel[i];
						//cout << " diff: " << diff << endl;
						r.quantity_fuel[i] = r.quantity_fuel[index_before] - fuel_consumed;
						diff = diff - r.quantity_fuel[i];
						//cout << " diff aggiornata: " << diff << endl;

					}
					else {
						//cout << " non sono al primo giro " << endl;
						r.quantity_fuel[i] = r.quantity_fuel[i] - diff;
						//cout << " Al fuel del nodo " << i << " tolgo " << diff << endl;
						//r.weight[i] = r.weight[i] + fuel_consumed - fuel_consumed2 - fuel_consumed1;
					}
					//cout << " weight prima " << r.weight[i] << endl;
					r.weight[i] = r.weight[i] + diff;
					index_before = i + 1;
					//cout << " inidce before = " << index_before << " riparto con un altro giro "<<  endl;
				}
				//*****************************************************************************************************************************************************************

				//cout << " Sono dentro al codice del destroy della ricerca locale sto per fare remove place " << endl;
				//cout << " Devo togliere nodo " << r.places[node_destroy] << endl;
				//r.print();
				r.removePlace(node_destroy, map_airplane);
				//cout << " Ho finito rimozione " << endl;
				//r.print();
				//cout << " Aggiornamento in main qui ho gia rimosso il nodo adesso sistemo i weigth negativi " << endl;
				double add_fuel = 0;
				int index_weight_neg = -1;
				for (int j = 0; j < r.index; j++) {
					if (r.weight[j] < 0) {
						//cout << " Nodo " << j << " della route " << r.aircraft_code << " negativo " << r.weight[j] << endl;
						add_fuel = r.weight[j];
						index_weight_neg = j;
						int index_refueling = index_weight_neg;
						for (int i = index_weight_neg; i >= 0; i--) {
							if (r.refueling[i]) { //&& i != node_destroy
								index_refueling = i;
								break;
							}
						}
						//cout << " Aggiorno da " << index_refueling << endl;
						for (int t = index_refueling; t < r.index; t++) {
							//cout << " Nodo " << t << " controllo se sto dentro o devo uscire " << endl;
							if (r.refueling[t] && t != index_refueling) break;
							//cout << " Ho passato if aggiorno nodo " << t << endl;
							//cout << " Quantità fuel prima : " << r.quantity_fuel[t] << " Weigth prima " << r.weight[t] << endl;
							r.quantity_fuel[t] += add_fuel;
							r.weight[t] -= add_fuel;
							//cout << " Quantità fuel dopo : " << r.quantity_fuel[t] << " Weigth dopo " << r.weight[t] << endl;
						}
					}
				}

			}
			//r.print();
		}

		if (check) {
			r.index = -1;
			//cout << " Attenzione è il caso che non puo toglire il nodo quello dove prima si bloccava " << endl;
			//cout << " Nelle prossime stampe questo giro di A lo devo saltare devo comparire al prossimo A " << endl;
			//system("pause");
		}
	}
	//cout << "passengers removed" << endl;
	//for (Passenger p : passenger_removed) p.print();
}

int sequential_same_node(Route r) {
	int node = -1;
	for (int i = 0; i < r.places.size() - 1; i++) {
		if (r.places[i] == r.places[i + 1]) {
			node = i;
			break;
		}
	}
	return node;
}

void aggregate_same_nodes(Route& r, int node) {
	// La modicfica del form e to del passeggiero non funziona
	for (Passenger& p : r.passengers_in_route) {
		if (p.solution_from == (1 + node)) p.solution_from = node;
		if (p.solution_to == (1 + node)) p.solution_to = node;
		if (p.solution_from > (1 + node)) p.solution_from--;
		if (p.solution_to > (1 + node))	p.solution_to--;
	}

	// Now, we remove the node
	if ((node + 1) == (r.index - 1)) {
		//cout << " Nodo doppio che devo eliminare risiede nell'ultima posizione" << endl;
		r.time_dep[node + 1] = r.time_dep[node];
		r.time_arr[node + 1] = r.time_arr[node];
		r.index--;
		r.index_cap--;
		r.places.erase(r.places.begin() + node);
		r.time_arr.erase(r.time_arr.begin() + node);
		r.time_dep.erase(r.time_dep.begin() + node);
		r.refueling.erase(r.refueling.begin() + node);
		r.quantity_fuel.erase(r.quantity_fuel.begin() + node);
		r.weight.erase(r.weight.begin() + node);
		r.capacity.erase(r.capacity.begin() + node);
	}
	else {
		//cout << " Nodo doppio che devo eliminare NON risiede nell'ultima posizione" << endl;
		// I remove the extra time that was considered
		double time_to_remove = r.time_dep[node + 1] - r.time_dep[node];
		for (int i = node + 1; i < r.index; i++) {
			r.time_dep[i] -= time_to_remove;
			r.time_arr[i] -= time_to_remove;
		}
		r.index--;
		r.index_cap--;
		r.places.erase(r.places.begin() + node);
		r.time_arr.erase(r.time_arr.begin() + node);
		r.time_dep.erase(r.time_dep.begin() + node);
		r.refueling.erase(r.refueling.begin() + node);
		r.quantity_fuel.erase(r.quantity_fuel.begin() + node);
		r.weight.erase(r.weight.begin() + node);
		r.capacity.erase(r.capacity.begin() + node);
	}



}

void aggregate_same_nodes_inter_ls(Route& r, int node) {
	// La modicfica del form e to del passeggiero non funziona
	for (Passenger& p : r.passengers_in_route) {
		if (p.solution_from == (1 + node)) p.solution_from = node;
		if (p.solution_to == (1 + node)) p.solution_to = node;
		if (p.solution_from > (1 + node)) p.solution_from--;
		if (p.solution_to > (1 + node))	p.solution_to--;
	}

	// Now, we remove the node
	if ((node + 1) == (r.index - 1)) {
		//cout << " Nodo doppio che devo eliminare risiede nell'ultima posizione" << endl;
		r.time_dep[node + 1] = r.time_dep[node];
		r.time_arr[node + 1] = r.time_arr[node];
		r.index--;
		r.index_cap--;
		r.places.erase(r.places.begin() + node);
		r.time_arr.erase(r.time_arr.begin() + node);
		r.time_dep.erase(r.time_dep.begin() + node);
		r.refueling.erase(r.refueling.begin() + node);
		r.quantity_fuel.erase(r.quantity_fuel.begin() + node);
		r.weight.erase(r.weight.begin() + node);
		r.capacity.erase(r.capacity.begin() + node);
	}
	else {
		//cout << " Nodo doppio che devo eliminare NON risiede nell'ultima posizione" << endl;
		// I remove the extra time that was considered
		double time_to_remove = r.time_dep[node + 1] - r.time_dep[node];
		for (int i = node + 1; i < r.index; i++) {
			if (i == node + 1) {
				r.time_dep[i] = r.time_dep[node];
				r.time_arr[i] = r.time_arr[node];
			}
			else {
				r.time_dep[i] -= time_to_remove;
				r.time_arr[i] -= time_to_remove;
			}

		}
		r.index--;
		r.index_cap--;
		r.places.erase(r.places.begin() + node);
		r.time_arr.erase(r.time_arr.begin() + node);
		r.time_dep.erase(r.time_dep.begin() + node);
		r.refueling.erase(r.refueling.begin() + node);
		r.quantity_fuel.erase(r.quantity_fuel.begin() + node);
		r.weight.erase(r.weight.begin() + node);
		r.capacity.erase(r.capacity.begin() + node);
	}



}

int swap_from(int node, Route r) {

	int swap_from = 0;

	for (Passenger p : r.passengers_in_route) {
		if (p.solution_to == node) {
			if (p.solution_from > swap_from) swap_from = p.solution_from;
		}
	}


	return swap_from;

}

int swap_to(int node, Route r) {
	int swap_to = 1000;

	for (Passenger p : r.passengers_in_route) {
		if (p.solution_from == node) {
			if (p.solution_to < swap_to) swap_to = p.solution_to;
		}

	}


	return swap_to;
}


bool swap_is_allowed(int A, int B, Route r) {
	bool swap = false;
	if (B < swap_to(A, r) && swap_from(B, r) < A) swap = true;
	return swap;
}

// Questo codice dello swap è aggiornato
Route update_route_after_swap(int A, int B, Route r, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& from_to_FuelConsumed) {
	Route r_new;
	r_new.aircraft_code = r.aircraft_code;
	r_new.primo_pass = r.primo_pass;

	//cout << "sto inserendo i vari posti nella nuova route" << endl;
	r_new.addPlace(r.places[0], r.refueling[0], map_airplane[r.aircraft_code].max_fuel, 0.0, 0, r.time_arr[0], r.time_dep[0]);
	for (int i = 1; i < r.index; i++) {
		if (i == A) {
			//in questo posto ci devo mettere B
			r_new.addPlace(r.places[B], r.refueling[B], r.quantity_fuel[B], 0.0, 0, r.time_arr[B], r.time_dep[B]);
		}
		else if (i == B) {
			//in questo posto ci devo mettere A
			r_new.addPlace(r.places[A], r.refueling[A], r.quantity_fuel[A], 0.0, 0, r.time_arr[A], r.time_dep[A]);
		}
		else {
			//in questo posto ci devo mettere normalmente i
			r_new.addPlace(r.places[i], r.refueling[i], r.quantity_fuel[i], 0.0, 0, r.time_arr[i], r.time_dep[i]);
		}
	}
	//cout << "ho finito di inserire i vari posti nella nuova route" << endl;


	//cout << "aggiorno i tempi e il fuel" << endl;
	//aggiorno i tempi e fuel senza aver considerato il probabile peso negativo, il paso qua è come se lo inizializzassi
	for (int i = 0; i < r_new.index; i++) {
		if (i > 0) {
			//cout << "from: " << r_new.places[i - 1] << endl;
			//cout << "to: " << r_new.places[i] << endl;
			//cout << "from to: " << (from_to[r_new.places[i - 1] + ";" + r_new.places[i]]) << endl;
			r_new.time_arr[i] = r_new.time_dep[i - 1] + (((from_to[r_new.places[i - 1] + ";" + r_new.places[i]]) / map_airplane[r_new.aircraft_code].speed) * 60);
			r_new.time_dep[i] = r_new.time_arr[i] + map_airstrip[r_new.places[i]].ground_time;

			//double time_fly = (((from_to[r_new.places[i - 1] + ";" + r_new.places[i]]) / map_airplane[r_new.aircraft_code].speed) * 60);
			double fuel_consumed = from_to_FuelConsumed[r_new.aircraft_code + ";" + r_new.places[i - 1] + ";" + r_new.places[i]];
			/*
			if (time_fly <= 60) {
				fuel_consumed += (time_fly / 60)*map_airplane[r_new.aircraft_code].fuel_burn_first;
			}
			else {
				fuel_consumed += map_airplane[r_new.aircraft_code].fuel_burn_first + ((time_fly - 60) / 60)*map_airplane[r_new.aircraft_code].fuel_burn_second;
			}
			*/
			//cout << "fuel consumed: " << fuel_consumed << endl;

			if (r_new.refueling[i]) {
				r_new.quantity_fuel[i] = map_airplane[r_new.aircraft_code].max_fuel;
			}
			else {
				r_new.quantity_fuel[i] = r_new.quantity_fuel[i - 1] - fuel_consumed;
			}
			r_new.weight[i] = map_airplane[r_new.aircraft_code].weight_fuel_people - r_new.quantity_fuel[i];
		}
		else {
			r_new.quantity_fuel[i] = map_airplane[r_new.aircraft_code].max_fuel;
			r_new.weight[i] = map_airplane[r_new.aircraft_code].weight_fuel_people - r_new.quantity_fuel[i];
		}
	}
	//cout << "ho finito di aggiornare i tempi e il fuel" << endl;

	//cout << "aggiorno i i passeggeri" << endl;
	//aggiorno capacita e peso e indici dei passeggeri
	//ora devo cambiare gli indici dei passeggeri spostati
	for (Passenger p : r.passengers_in_route) {
		if (p.solution_from == A) p.solution_from = B;
		else if (p.solution_to == A) p.solution_to = B;
		else if (p.solution_from == B) p.solution_from = A;
		else if (p.solution_to == B) p.solution_to = A;
		r_new.passengers_in_route.push_back(p);

		for (int t = p.solution_from; t < p.solution_to; t++) {
			r_new.capacity[t] ++;
			r_new.weight[t] -= p.weight;
		}
	}
	//cout << "finito" << endl;

	//cout << "aggiorno il fuel se peso negativo" << endl;
	//aggiorno fuel se il peso è negatico
	for (int i = 0; i < r_new.index; i++) {
		//cout << " Sono all inizio del For valutabdo il nodo " << i << endl;
		if (r_new.weight[i] < 0) {
			//	cout << " Trovato nodo con peso negativo in --> " << i << endl;
			int index_refueling = i;
			for (int t = i; t >= 0; t--) {
				if (r_new.refueling[t]) {
					index_refueling = t;
					//	cout << " Index dove si fa refuel prima o coincidente a valore di peso negativo " << index_refueling<<  endl;
					break;
				}
			}
			double Update_value = r_new.weight[i];
			//cout << " r_new.quantity_fuel[index_refueling] : " << r_new.quantity_fuel[index_refueling] << " +=  r_new.weight[i] : " << r_new.weight[i] << endl;
			r_new.quantity_fuel[index_refueling] += r_new.weight[i];
			//cout << " r_new.weight[index_refueling] : " << r_new.weight[index_refueling] << " -=  r_new.weight[i] : " << r_new.weight[i] << endl;
			r_new.weight[index_refueling] -= r_new.weight[i];
			//cout << " Adesso tolgo ai nodi senza possibilità di fare refuel successvi " << endl;
			for (int j = index_refueling + 1; j < r_new.index; j++) {
				if (r_new.refueling[j]) break;
				else {
					r_new.quantity_fuel[j] += Update_value;
					//cout << " Dopo Fuel era = " << r_new.quantity_fuel[j] << endl;
					//cout << " Prima Weight era = " << r_new.weight[j] << endl;
					r_new.weight[j] -= Update_value;
					//cout << " Dopo Weight era = " << r_new.weight[j] << endl;
				}
			}

			//r_new.weight[i] = 0;

		}
	}
	


	return r_new;
}

vector <Route> swap(vector<Route> routes, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, double end_day, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {
	vector<Route> routes_after_swap;

	for (Route r : routes) {
		//cout << " sto provando a fare lo swap in questa route: " << endl;
		//r.print();
		Route r_support = r;
		for (int A = 1; A < r_support.index - 1; A++) {
			for (int B = A + 1; B < r_support.index; B++) {

				if (swap_is_allowed(A, B, r_support)) {
					//cout << "******************************************************Sto provando a fare lo swap fra " << A << " e " << B << endl;
					Route r_new = update_route_after_swap(A, B, r_support, map_airplane, map_airstrip, from_to, from_to_FuelConsumed);
					//cout << "ho finito l'update" << endl;
					//r_new.print();
					double cost_route_support = cost_single_route(r_support, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
					double cost_route_new = cost_single_route(r_new, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
					//cout << cost_route_support << " c_supp > c_new " << cost_route_new << " &&  route feasible: " << route_feasible(r_new, map_airplane, end_day, from_to) << endl;
					if (cost_route_support > cost_route_new &&	route_feasible(r_new, map_airplane, end_day, from_to, location_fuel, from_to_FuelConsumed)) {
						//cout << " OK ! dopo move Migliora ------- Ma prima devo controllare che non sia con nodi doppi " << endl;
						int node = sequential_same_node(r_new);
						bool fatto = false;
						while (node != -1) {
							/*
							cout << " !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ERROR STESSI NODI !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! " << endl;
							r_new.print();
							// i have two airports close to each other
							cout << " Nodo dove inizia coppia --> " << node << endl;
							system("pause");
							*/
							aggregate_same_nodes(r_new, node);
							//r_new.print();
							cost_route_new = cost_single_route(r_new, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
							//cout << " Deve valere ANCORA che " << cost_route_support << "  >  " << cost_route_new << " &&  route feasible: " << route_feasible(r_new, map_airplane, end_day, from_to) << endl;
							
							fatto = true;
							node = sequential_same_node(r_new);
						}
						//cout << " Ok non aveva nodi doppi ! " << endl;
						if (fatto == false) {
							r_support = r_new;
							A = 1;
							B = A + 1;
						}
						else {
							if (cost_route_support > cost_route_new &&	route_feasible(r_new, map_airplane, end_day, from_to, location_fuel, from_to_FuelConsumed)) {
								r_support = r_new;
								A = 1;
								B = A + 1;
								cost_route_support = cost_route_new;
							}
						}
					}

				}

			}
		}
		//Modifico Fuel quando non massimo
		for (int k = 0; k < r_support.index; k++) {
			if (r_support.refueling[k] && r_support.quantity_fuel[k] < map_airplane[r_support.aircraft_code].max_fuel) { //&& k!= node_destroy
			//cout << " Sto valutando il caso del nodo " << k << endl;
				int Node_min = k;
				double min_weight = r_support.weight[k];
				int index_updating_from = k;
				int index_updating_to = r_support.index;  //qua prima c'era -1
				for (int i = k + 1; i < r_support.index; i++) {
					//cout << " Sto guardando il nodo " << i << endl;
					//if (!(r.weight[i] > 0 && r.quantity_fuel[i] == map_airplane[r.aircraft_code].max_fuel)) {
					//cout << " Ho passato IF di controllo " << endl;
					if (r_support.refueling[i]) break;
					if (r_support.weight[i] < min_weight) {
						min_weight = r_support.weight[i];
						Node_min = i;
					}
					//}
				}
				//cout << " Nodo di minimo ---> " << Node_min << endl;
				//cout << " Valore di minimi --> " << min_weight << endl;
				if (Node_min >= 0) {
					/*
					for (int i = Node_min; i >= 0; i--) {
					if (r.refueling[i] && i != node_destroy) {
					index_updating_from = i;
					break;
					}
					}
					*/
					for (int i = k + 1; i < r_support.index; i++) {
						if (r_support.refueling[i]) {   // && i != node_destroy ho tolto questo perchè se no se oltre quel nodo non c'è ne erano altri di fuell non trovavo un to
							index_updating_to = i;
							break;
						}
					}
					//cout << "Adesso che ho trovato il minimo devo aggiornare da ---> " << index_updating_from << endl;
					//cout << "Adesso che ho trovato il minimo devo aggiornare a ---> " << index_updating_to << endl;
					double Fuel_before = r_support.quantity_fuel[index_updating_from];
					//cout << " Valore Fuel Before ------> " << Fuel_before << endl;
					//cout << " Quindi alla fine parto ad aggiornare " << index_updating_from << " dove prendo il minimo tra " << map_airplane[r.aircraft_code].max_fuel << " e " << r.quantity_fuel[index_updating_from] + min_weight << endl;
					r_support.quantity_fuel[index_updating_from] = min(map_airplane[r_support.aircraft_code].max_fuel, r_support.quantity_fuel[index_updating_from] + min_weight);
					//cout << " Valore Fuel After ------> " << r.quantity_fuel[index_updating_from] << endl;
					//cout << " Valore Weigth Before ------> " << r.weight[index_updating_from] << endl;
					r_support.weight[index_updating_from] -= (r_support.quantity_fuel[index_updating_from] - Fuel_before);
					//cout << " Valore Weigth After ------> " << r.weight[index_updating_from] << endl;
					for (int i = index_updating_from + 1; i < index_updating_to; i++) {
						r_support.quantity_fuel[i] += (r_support.quantity_fuel[index_updating_from] - Fuel_before);
						r_support.weight[i] -= (r_support.quantity_fuel[index_updating_from] - Fuel_before);
					}
				}
			}

		}
		routes_after_swap.push_back(r_support);
	}

	return routes_after_swap;
}

int move_from(int node, Route r) {

	int swap_from = 0;

	for (Passenger p : r.passengers_in_route) {
		if (p.solution_to == node) {
			if (p.solution_from > swap_from) swap_from = p.solution_from;
		}
	}


	return swap_from;

}

int move_to(int node, Route r) {
	int swap_to = 1000;

	for (Passenger p : r.passengers_in_route) {
		if (p.solution_from == node) {
			if (p.solution_to < swap_to) swap_to = p.solution_to;
		}

	}


	return swap_to;
}

bool move_is_allowed(int A, int B, Route r) {
	bool move = false;
	if (B > A && B < move_to(A, r))move = true;
	if (B < A && move_from(A, r) < B) move = true;
	return move;
}

bool move_flightleg_is_allowed(int A, Route r) {
	bool move = true;
	//cout << " Sono dentro al controllo per sapere se è consentito " << endl;
	//cout << " sto guardando la route" << r.aircraft_code << " con il nodo " << A << endl;
	for (Passenger p : r.passengers_in_route) {
		//cout << " sto facendo il passeggiero: ";
		//p.print();
		if ((p.solution_from == A) && (p.solution_to != (A + 1))) {
			move = false;
			break;
		}
		if ((p.solution_from != A) && (p.solution_to == (A + 1))) {
			move = false;
			break;
		}
		if ((p.solution_to == A) || (p.solution_from == (A + 1))) {
			move = false;
			break;
		}
		//cout << " Move = " << move << endl;
	}
	return move;
}


Route update_route_after_move(int A, int B, Route r, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, map<string, double>& from_to_FuelConsumed) {
	Route r_new;
	r_new.aircraft_code = r.aircraft_code;
	r_new.primo_pass = r.primo_pass;
	/*cout << " Questa è la vecchia routes: " << endl;
	//r.print();
	*/
	//cout << "dentro a route after move -- A -> " << A << " B --> " << B << endl;
	//cout << "sto inserendo i vari posti nella nuova route" << endl;
	
	r_new.addPlace(r.places[0], r.refueling[0], map_airplane[r.aircraft_code].max_fuel, 0.0, 0, r.time_arr[0], r.time_dep[0]);
	if (B > A) {
		//cout << " Sono nel caso in cui B > A " << endl;
		for (int i = 1; i < r.index; i++) {
			//cout << " Sono nel indice i --> " << i << endl;
			if ((i < A) || (i > B)) {
				//cout << " caso (i < A) || (i > B) in questo casorimane come prima devo mettere normalmente quello che c'è in i " << endl;
				//cout << r.places[i] << endl;
				// Caso in cui rimane come prima
				r_new.addPlace(r.places[i], r.refueling[i], r.quantity_fuel[i], 0.0, 0, r.time_arr[i], r.time_dep[i]);
			}
			else if ((i >= A) && (i < B)) {
				//cout << " caso (i >= A) && (i < B) in questo caso devo metterquello che c'è in i+1 " << endl;
				//cout << r.places[i+1] << endl;
				//cout << "stampo nel caso indicato dal bed allocator i+1" << endl;
				//cout << "i+1: " << i+1 << " r.places[i+1]: " << r.places[i+1] << endl;
				r_new.addPlace(r.places[i + 1], r.refueling[i + 1], r.quantity_fuel[i + 1], 0.0, 0, r.time_arr[i + 1], r.time_dep[i + 1]);
			}
			else if (i == B) {
				//cout << " caso i = (B) in questo caso devo mettere normalmente A " << endl;
				//cout << r.places[A] << endl;
				r_new.addPlace(r.places[A], r.refueling[A], r.quantity_fuel[A], 0.0, 0, r.time_arr[A], r.time_dep[A]);
			}
		}
	}
	else {
		//cout << " Sono nel caso in cui B < A " << endl;
		for (int i = 1; i < r.index; i++) {
			//cout << " Sono nel indice i --> " << i << endl;
			if (i < (B + 1)) {
				//cout << " caso i < (B + 1) in questo caso devo mettere normalmente quello che c'è in i " << endl;
				//cout << r.places[i] << endl;
				//in questo posto ci devo mettere normalmente i
				r_new.addPlace(r.places[i], r.refueling[i], r.quantity_fuel[i], 0.0, 0, r.time_arr[i], r.time_dep[i]);
			}
			else if (i == (B + 1)) {
				//cout << " caso i = (B + 1) in questo caso devo mettere normalmente A " << endl;
				//cout << r.places[A] << endl;
				//in questo posto ci devo mettere A
				//cout << "stampo nel caso indicato dal bed allocator A" << endl;
				//cout << "ecco l'index: " << r.index << endl;
				//cout << "indice i: " << i << endl;
				//cout << "A: " << A << " r.places[A]: " << r.places[A] << endl;
				r_new.addPlace(r.places[A], r.refueling[A], r.quantity_fuel[A], 0.0, 0, r.time_arr[A], r.time_dep[A]);
			}
			else if (i >= A + 1) {
				//in questo posto ci devo mettere normalmente i-1
				//cout << " caso (i >= A +1) in questo caso devo mettere normalmente quello che c'è in i" << endl;
				//cout << r.places[i-1] << endl;
				//cout << "stampo nel caso indicato dal bed allocator" << endl;
				//cout << "i: " << i << " r.places[i]: " << r.places[i] << endl;
				r_new.addPlace(r.places[i], r.refueling[i], r.quantity_fuel[i], 0.0, 0, r.time_arr[i], r.time_dep[i]);
			}
			else {
				//cout << " caso i > (B + 1) in questo caso devo mettere normalmente quello che c'è in i - 1" << endl;
				//cout << r.places[i - 1] << endl;
				r_new.addPlace(r.places[i - 1], r.refueling[i - 1], r.quantity_fuel[i - 1], 0.0, 0, r.time_arr[i - 1], r.time_dep[i - 1]);
			}
		}
	}
	//cout << "ho finito di inserire i vari posti nella nuova route" << endl;
	//r_new.print();
	//cout << "aggiorno i tempi e il fuel" << endl;
	//aggiorno i tempi e fuel senza aver considerato il probabile peso negativo, il paso qua è come se lo inizializzassi
	for (int i = 0; i < r_new.index; i++) {
		if (i > 0) {
			//cout << "from: " << r_new.places[i - 1] << endl;
			//cout << "to: " << r_new.places[i] << endl;
			//cout << "from to: " << (from_to[r_new.places[i - 1] + ";" + r_new.places[i]]) << endl;
			r_new.time_arr[i] = r_new.time_dep[i - 1] + (((from_to[r_new.places[i - 1] + ";" + r_new.places[i]]) / map_airplane[r_new.aircraft_code].speed) * 60);
			r_new.time_dep[i] = r_new.time_arr[i] + map_airstrip[r_new.places[i]].ground_time;

			//double time_fly = (((from_to[r_new.places[i - 1] + ";" + r_new.places[i]]) / map_airplane[r_new.aircraft_code].speed) * 60);
			double fuel_consumed = from_to_FuelConsumed[r_new.aircraft_code + ";" + r_new.places[i - 1] + ";" + r_new.places[i]];
			/*if (time_fly <= 60) {
				fuel_consumed += (time_fly / 60)*map_airplane[r_new.aircraft_code].fuel_burn_first;
			}
			else {
				fuel_consumed += map_airplane[r_new.aircraft_code].fuel_burn_first + ((time_fly - 60) / 60)*map_airplane[r_new.aircraft_code].fuel_burn_second;
			}*/

			//cout << "fuel consumed: " << fuel_consumed << endl;

			if (r_new.refueling[i]) {
				r_new.quantity_fuel[i] = map_airplane[r_new.aircraft_code].max_fuel;
			}
			else {
				r_new.quantity_fuel[i] = r_new.quantity_fuel[i - 1] - fuel_consumed;
			}
			r_new.weight[i] = map_airplane[r_new.aircraft_code].weight_fuel_people - r_new.quantity_fuel[i];
		}
		else {
			r_new.quantity_fuel[i] = map_airplane[r_new.aircraft_code].max_fuel;
			r_new.weight[i] = map_airplane[r_new.aircraft_code].weight_fuel_people - r_new.quantity_fuel[i];
		}
	}
	//cout << "ho finito di aggiornare i tempi e il fuel" << endl;
	//r_new.print();
	//cout << "aggiorno i i passeggeri" << endl;
	//aggiorno capacita e peso e indici dei passeggeri
	//ora devo cambiare gli indici dei passeggeri 
	//cout << " A -> " << A << " B --> " << B << endl;
	for (Passenger p : r.passengers_in_route) {
		//cout << " Ho preso il passeggiero: " << endl;
		//cout << " Nome : " << p.name << " che ha from: " << p.solution_to << " e to: " << p.solution_to << endl;
		if (p.solution_from == A && A > B) {
			//cout << " Modifico from = B+1 pperche A > B " << endl;
			p.solution_from = B + 1;
		}
		else if (p.solution_to == A && A > B) {
			//cout << " Modifico to = B+1 pperche A > B " << endl;
			p.solution_to = B + 1;
		}
		else if (p.solution_to == A && A < B) {
			//cout << " Modifico to = B perchè A < B " << endl;
			p.solution_to = B;
		}
		else if (p.solution_from == A && A < B) {
			//cout << " Modifico from = B perchè A < B  " << endl;
			p.solution_from = B;
		}
		else if (p.solution_from <= B && B < p.solution_to && A > p.solution_to) {
			//cout << " Incremento il to di 1  caso A > B" << endl;
			p.solution_to++;
		}
		else if (p.solution_from <= B && B < p.solution_to && A < p.solution_from) {
			//cout << " Decremento il from di 1  caso A < B" << endl;
			p.solution_from--;
		}
		else if (p.solution_from > B &&  A > p.solution_to) {
			//cout << " Terza casistica A era dopo richiesta adesso va orima" << endl;
			p.solution_from++;
			p.solution_to++;

		}
		else if (p.solution_from < A &&  A < p.solution_to && B < p.solution_from) {
			//cout << " Quarta casistica A" << endl;
			p.solution_from++;
		}
		else if (p.solution_from < A &&  A < p.solution_to && B >= p.solution_to && A < B) {
			//cout << " Quarta casistica B" << endl;
			p.solution_to--;
		}
		else if (p.solution_from > A &&  A < p.solution_to && B >= p.solution_to) {
			//cout << " Quinta casistica Nodo va da prima della richiesta a dopo" << endl;
			p.solution_to--;
			p.solution_from--;
		}
		r_new.passengers_in_route.push_back(p);

		for (int t = p.solution_from; t < p.solution_to; t++) {
			r_new.capacity[t] ++;
			r_new.weight[t] -= p.weight;
		}
		//cout << " Nome : " << p.name << " che ha from AGGIORNATO: " << p.solution_from << " e to AGGIORNATO: " << p.solution_to << endl;
	}
	/*cout << "finito" << endl;
	r_new.print();
	cout << "aggiorno il fuel se peso negativo" << endl;
	//aggiorno fuel se il peso è negatico */
	for (int i = 0; i < r_new.index; i++) {
		//cout << " Sono all inizio del For valutabdo il nodo " << i << endl;
		if (r_new.weight[i] < 0) {
			//	cout << " Trovato nodo con peso negativo in --> " << i << endl;
			int index_refueling = i;
			for (int t = i; t >= 0; t--) {
				if (r_new.refueling[t]) {
					index_refueling = t;
					//	cout << " Index dove si fa refuel prima o coincidente a valore di peso negativo " << index_refueling<<  endl;
					break;
				}
			}
			double Update_value = r_new.weight[i];
			//cout << " r_new.quantity_fuel[index_refueling] : " << r_new.quantity_fuel[index_refueling] << " +=  r_new.weight[i] : " << r_new.weight[i] << endl;
			r_new.quantity_fuel[index_refueling] += r_new.weight[i];
			//cout << " r_new.weight[index_refueling] : " << r_new.weight[index_refueling] << " -=  r_new.weight[i] : " << r_new.weight[i] << endl;
			r_new.weight[index_refueling] -= r_new.weight[i];
			//cout << " Adesso tolgo ai nodi senza possibilità di fare refuel successvi " << endl;
			for (int j = index_refueling + 1; j < r_new.index; j++) {
				if (r_new.refueling[j]) break;
				else {
					r_new.quantity_fuel[j] += Update_value;
					//cout << " Dopo Fuel era = " << r_new.quantity_fuel[j] << endl;
					//cout << " Prima Weight era = " << r_new.weight[j] << endl;
					r_new.weight[j] -= Update_value;
					//cout << " Dopo Weight era = " << r_new.weight[j] << endl;
				}
			}

			//r_new.weight[i] = 0;

		}
	}
	//cout << "finito" << endl;
	
	//stampo_caso_strano_single(r, from_to, map_airplane);

	return r_new;
}

vector <Route> move(vector<Route> routes, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, double end_day, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {
	vector<Route> routes_after_move;

	for (Route r : routes) {
		//cout << " sto provando a fare il move in questa route: " <<r.aircraft_code <<  endl;
		//r.print();
		Route r_support = r;
		for (int A = 1; A < r_support.index; A++) {
			//cout << " Considero di spostare nodo -> " << A << endl;
			// we have to move the Node A form its position to th enext after B
			for (int B = 1; B < r_support.index; B++) {
				if (A != B && B != (A - 1) && B != (A - 2)) {    //Il caso B != (A-1) || B!= (A-2) sono casi che valutiamo gia quando sposriamo avanti
				//cout << " Nella posizione -> " << B << endl;
					if (move_is_allowed(A, B, r_support)) {
						//cout << " CONSENTITO sono nel main -----> provo a fare move da " << A << " e " << B << endl;
						Route r_new = update_route_after_move(A, B, r_support, map_airplane, map_airstrip, from_to, from_to_FuelConsumed);
						//cout << "ho finito l'update" << endl;
						//r_new.print();
						double cost_route_support = cost_single_route(r_support, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
						double cost_route_new = cost_single_route(r_new, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
						//cout << " Deve valere che " << cost_route_support << "  >  " << cost_route_new << " &&  route feasible: " << route_feasible(r_new, map_airplane, end_day, from_to,location_fuel) << endl;
						if (cost_route_support > cost_route_new &&	route_feasible(r_new, map_airplane, end_day, from_to, location_fuel, from_to_FuelConsumed)) {
							//cout << " OK ! dopo move Migliora ------- Ma prima devo controllare che non sia con nodi doppi " << endl;
							int node = sequential_same_node(r_new);
							//cout << "node fuori dal while: " << node << endl;
							//r_new.print();
							bool fatto = false;
							int num_aggregazioni = 0;
							while (node != -1) {
								/* cout << " !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ERROR STESSI NODI !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! " << endl;
								//r_new.print();
								// i have two airports close to each other
								cout << " Nodo dove inizia coppia --> " << node << endl;
								system("pause");
								*/
								//cout << "******* Aggrego nodo in posizione **********" << node << endl;
								aggregate_same_nodes(r_new, node);
								if(A > node) num_aggregazioni++;
								//cout << " Ho finito codice di aggregazione " << endl;
								cost_route_new = cost_single_route(r_new, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
								//cout << " Deve valere ANCORA che " << cost_route_support << "  >  " << cost_route_new << " &&  route feasible: " << route_feasible(r_new, map_airplane, end_day, from_to, location_fuel) << endl;
								//system("pause");
								node = sequential_same_node(r_new);
								//cout << "node dentro al while: " << node << endl;
								//r_new.print();
								fatto = true;
							}

							//cout << " Ok non aveva nodi doppi ! " << endl;
							if (fatto == false) r_support = r_new;
							else {
								if (cost_route_support > cost_route_new &&	route_feasible(r_new, map_airplane, end_day, from_to, location_fuel, from_to_FuelConsumed)) {
									r_support = r_new;
									cost_route_support = cost_route_new;
									//cout << " Ho finito while di aggregazione ma devo aggiornare A tolgo " << num_aggregazioni << endl;
									A -= num_aggregazioni;
									if (A <= 0) A = 1;
								}
							}
						}
					}
				}

			}
		}
		//Modifico Fuel quando non massimo
		for (int k = 0; k < r_support.index; k++) {
			if (r_support.refueling[k] && r_support.quantity_fuel[k] < map_airplane[r_support.aircraft_code].max_fuel) { //&& k!= node_destroy
			//cout << " Sto valutando il caso del nodo " << k << endl;
				int Node_min = k;
				double min_weight = r_support.weight[k];
				int index_updating_from = k;
				int index_updating_to = r_support.index;  //qua prima c'era -1
				for (int i = k + 1; i < r_support.index; i++) {  // SECONDO ME QUA NON CI VA <=
					//cout << " Sto guardando il nodo " << i << endl;
					//if (!(r.weight[i] > 0 && r.quantity_fuel[i] == map_airplane[r.aircraft_code].max_fuel)) {
					//cout << " Ho passato IF di controllo " << endl;
					if (r_support.refueling[i]) break;
					if (r_support.weight[i] < min_weight) {
						min_weight = r_support.weight[i];
						Node_min = i;
					}
					//}
				}
				//cout << " Nodo di minimo ---> " << Node_min << endl;
				//cout << " Valore di minimi --> " << min_weight << endl;
				if (Node_min >= 0) {
					/*
					for (int i = Node_min; i >= 0; i--) {
					if (r.refueling[i] && i != node_destroy) {
					index_updating_from = i;
					break;
					}
					}
					*/
					for (int i = k + 1; i < r_support.index; i++) {
						if (r_support.refueling[i]) {   // && i != node_destroy ho tolto questo perchè se no se oltre quel nodo non c'è ne erano altri di fuell non trovavo un to
							index_updating_to = i;
							break;
						}
					}
					//cout << "Adesso che ho trovato il minimo devo aggiornare da ---> " << index_updating_from << endl;
					//cout << "Adesso che ho trovato il minimo devo aggiornare a ---> " << index_updating_to << endl;
					double Fuel_before = r_support.quantity_fuel[index_updating_from];
					//cout << " Valore Fuel Before ------> " << Fuel_before << endl;
					//cout << " Quindi alla fine parto ad aggiornare " << index_updating_from << " dove prendo il minimo tra " << map_airplane[r.aircraft_code].max_fuel << " e " << r.quantity_fuel[index_updating_from] + min_weight << endl;
					r_support.quantity_fuel[index_updating_from] = min(map_airplane[r_support.aircraft_code].max_fuel, r_support.quantity_fuel[index_updating_from] + min_weight);
					//cout << " Valore Fuel After ------> " << r.quantity_fuel[index_updating_from] << endl;
					//cout << " Valore Weigth Before ------> " << r.weight[index_updating_from] << endl;
					r_support.weight[index_updating_from] -= (r_support.quantity_fuel[index_updating_from] - Fuel_before);
					//cout << " Valore Weigth After ------> " << r.weight[index_updating_from] << endl;
					for (int i = index_updating_from + 1; i < index_updating_to; i++) {
						r_support.quantity_fuel[i] += (r_support.quantity_fuel[index_updating_from] - Fuel_before);
						r_support.weight[i] -= (r_support.quantity_fuel[index_updating_from] - Fuel_before);
					}
				}
			}

		}
		routes_after_move.push_back(r_support);
	}

	return routes_after_move;
}

vector <Route> inter_move(vector<Route> routes, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, double end_day, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {
	vector<Route> routes_after_move;
	int n_route = -1;
	//cout << " Stampo le route prima di cominciare " << endl;
	//for (Route r : routes) r.print();
	//cout << "************************************************** INCOMINCIO ********************************************************************************************* " << endl;
	//for (Route r : routes) {
	for (int r = 0; r < routes.size(); r++) {
		n_route += 1;
		vector<Route> routes_destroyed;
		//cout << " Adesso anallizzo la route numero " << r << " dell'aereo " << routes[r].aircraft_code << endl;
		//Route distrutte sono uguali tranne quella a cui sto togliendo la coppia
		//for (Route s : routes) if (s.aircraft_code != r.aircraft_code) routes_destroyed.push_back(s);
		for (Route s : routes) if (s.aircraft_code != routes[r].aircraft_code) routes_destroyed.push_back(s);
		Route r_support = routes[r];
		for (int A = 1; A < (r_support.index - 1); A++) {
			//cout << " Sto guardando Nodo A: " << A << " di " << r_support.aircraft_code << " size: " << r_support.index <<  endl;
			// Solution Rebuilt è come se fosse il nostro best improvement
			vector<Route> solution_rebuilt;
			vector<Passenger> passenger_removed;
			//cout << " Considero di spostare nodo -> " << A << " e nodo " << A+1 << endl;
			// Ora devo eliminare i nodi solo se sono allowed
			if (move_flightleg_is_allowed(A, r_support)) {
				//cout << " CONSENTITO sono nel main -----> provo a fare move di " << A << " e " << A+1 << " da " << r_support.aircraft_code << " un altra route " << endl;
				Route r_new = r_support;
				//cout << " La route adesso ha numero di nodi: " << r_new.index << endl;
				string NomeA1 = r_new.places[A + 1];
				//cout << " La route da distruggere inizialmente ha: " << r_new.passengers_in_route.size() << endl;
				destroy_ls(n_route, A, passenger_removed, r_new, map_airplane, map_airstrip, from_to);
				//cout << " La route adesso ha numero di nodi: " << r_new.index << " con numero di passeggieri rimossi " << passenger_removed.size() << endl;
				//cout << " Stampo la  route distrutta " << endl;
				//r_new.print();
				if (r_new.index != -1) {
					/*if (A != (r_new.index - 1) && r_new.places[A] == NomeA1 && r_new.index > 1) {
						//cout << " Ok vado a togliere anche il nodo A " << endl;
						destroy_ls(n_route, A, passenger_removed, r_new, map_airplane, map_airstrip, from_to);
						//for (Passenger p : passenger_removed) p.print();
						//r_new.print();
					}*/
					if (r_new.index != -1) {
						solution_rebuilt = repair_one(end_day, routes_destroyed, map_airplane, passenger_removed, map_airstrip, from_to, location_fuel, from_to_FuelConsumed);
						if (solution_rebuilt.size() != 0) {
							int Npass = 0;
							for (Route p : solution_rebuilt) Npass += p.passengers_in_route.size();
							//cout << " Numero Passeggeri dopo  repair dentro alla ricerca locale riga 6799 : " << Npass << " Sono i passeggieri senza route distrutta " << endl;
							//cout << " Numero Passegger nella route distrutta: " << r_new.passengers_in_route.size() << endl;
							solution_rebuilt.push_back(r_new);
							double before = calculate_ObjectiveFunction(routes, map_airstrip, map_airplane, from_to, from_to_FuelConsumed); // Qui non va bene devi considerare che dopo un primo miglioramneto cambi la route
							double after = calculate_ObjectiveFunction(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
							if (before > after) {
								//cout << " OK ! dopo mossa MIGLIORAAAAAAAAAAAAAAA di " << before <<" - "<<after << "------ Ma prima devo controllare che non sia con nodi doppi " << endl;
								// Qui sto usando tutto solution_rebuilt.back() ma in realta potrei usare r_new e poi un volta che la ho istemanta switcharla con solution_rebuilt.back()
								int node = sequential_same_node(solution_rebuilt.back());
								//cout << "node fuori dal while: " << node << endl;
								//r_new.print();
								bool fatto = false;
								int num_aggregazioni = 0;
								while (node != -1) {
									//cout << " !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ERROR STESSI NODI !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! " << solution_rebuilt.back().aircraft_code<< endl;
									solution_rebuilt.back().print();
									// i have two airports close to each other
									//cout << " Nodo dove inizia coppia --> " << node << endl;
									if (node == 1) solution_rebuilt.back().print();
									//system("pause");
									//cout << "******* Aggrego nodo in posizione **********" << node << endl;
									//cout << " Numero nodi prima:  " << solution_rebuilt.back().index << endl;
									aggregate_same_nodes_inter_ls(solution_rebuilt.back(), node);
									//cout << " Numero nodi dopo:  " << solution_rebuilt.back().index << endl;
									if (A > node) num_aggregazioni++;
									//cout << " Ho finito codice di aggregazione " << endl;
									after = calculate_ObjectiveFunction(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
									//cout << " Deve valere ANCORA che " << cost_route_support << "  >  " << cost_route_new << " &&  route feasible: " << route_feasible(r_new, map_airplane, end_day, from_to, location_fuel) << endl;
									//system("pause");
									node = sequential_same_node(solution_rebuilt.back());
									//solution_rebuilt.back().print();
									fatto = true;
								}

								if (fatto == false) {
									//cout << " Ok non aveva nodi doppi ! " << endl;
									//cout << " Il for degli A prima andava fino a " << r_support.index  << endl;
									r_support = r_new;
									//cout << " Il for degli A adesso va fino a " << r_support.index  << endl;
									routes_after_move = solution_rebuilt;
									routes = solution_rebuilt;
									// Sicuramente sopra devo tenere conto che ho due vertici in meno nell'arco che sto considerando
									routes_destroyed.clear();
									routes_destroyed.shrink_to_fit();
									for (int s = 0; s < solution_rebuilt.size() - 1; s++) routes_destroyed.push_back(solution_rebuilt[s]);
									A = 1;
									r--;
									if (A >= (r_support.index - 1)) {
										//cout << " caso Loop " << endl;
									}
								}
								else {
									if (before > after) {
										// bisognerebbe mettere l'aggiornamento una cosa del tipo
										//cout << " Ok MIGLIORAAAAAAAAAAAAAAA aveva nodi doppi ! " << endl;
										//system("pause");
										//cout << " Il for degli A prima andava fino a " << r_support.index  << endl;
										r_support = r_new;
										//cout << " Il for degli A adesso va fino a " << r_support.index  << endl;
										routes_after_move = solution_rebuilt;
										routes = solution_rebuilt;
										//cout << " Ho finito while di aggregazione ma devo aggiornare A tolgo " << num_aggregazioni << endl;
										// Sicuramente sopra devo tenere conto che ho due vertici in meno nell'arco che sto considerando
										routes_destroyed.clear();
										routes_destroyed.shrink_to_fit();
										for (int s = 0; s < solution_rebuilt.size() - 1; s++) routes_destroyed.push_back(solution_rebuilt[s]);
										A = 1;
										r--;
									}
								}
							}
						}
					}
				}
			}



		}



	}




	for (Route r_support : routes_after_move) {
		//Modifico Fuel quando non massimo
		for (int k = 0; k < r_support.index; k++) {
			if (r_support.refueling[k] && r_support.quantity_fuel[k] < map_airplane[r_support.aircraft_code].max_fuel) { //&& k!= node_destroy
			//cout << " Sto valutando il caso del nodo " << k << endl;
				int Node_min = k;
				double min_weight = r_support.weight[k];
				int index_updating_from = k;
				int index_updating_to = r_support.index;  //qua prima c'era -1
				for (int i = k + 1; i < r_support.index; i++) {  // SECONDO ME QUA NON CI VA <=
					//cout << " Sto guardando il nodo " << i << endl;
					//if (!(r.weight[i] > 0 && r.quantity_fuel[i] == map_airplane[r.aircraft_code].max_fuel)) {
					//cout << " Ho passato IF di controllo " << endl;
					if (r_support.refueling[i]) break;
					if (r_support.weight[i] < min_weight) {
						min_weight = r_support.weight[i];
						Node_min = i;
					}
					//}
				}
				//cout << " Nodo di minimo ---> " << Node_min << endl;
				//cout << " Valore di minimi --> " << min_weight << endl;
				if (Node_min >= 0) {
					/*
					for (int i = Node_min; i >= 0; i--) {
					if (r.refueling[i] && i != node_destroy) {
					index_updating_from = i;
					break;
					}
					}
					*/
					for (int i = k + 1; i < r_support.index; i++) {
						if (r_support.refueling[i]) {   // && i != node_destroy ho tolto questo perchè se no se oltre quel nodo non c'è ne erano altri di fuell non trovavo un to
							index_updating_to = i;
							break;
						}
					}
					//cout << "Adesso che ho trovato il minimo devo aggiornare da ---> " << index_updating_from << endl;
					//cout << "Adesso che ho trovato il minimo devo aggiornare a ---> " << index_updating_to << endl;
					double Fuel_before = r_support.quantity_fuel[index_updating_from];
					//cout << " Valore Fuel Before ------> " << Fuel_before << endl;
					//cout << " Quindi alla fine parto ad aggiornare " << index_updating_from << " dove prendo il minimo tra " << map_airplane[r.aircraft_code].max_fuel << " e " << r.quantity_fuel[index_updating_from] + min_weight << endl;
					r_support.quantity_fuel[index_updating_from] = min(map_airplane[r_support.aircraft_code].max_fuel, r_support.quantity_fuel[index_updating_from] + min_weight);
					//cout << " Valore Fuel After ------> " << r.quantity_fuel[index_updating_from] << endl;
					//cout << " Valore Weigth Before ------> " << r.weight[index_updating_from] << endl;
					r_support.weight[index_updating_from] -= (r_support.quantity_fuel[index_updating_from] - Fuel_before);
					//cout << " Valore Weigth After ------> " << r.weight[index_updating_from] << endl;
					for (int i = index_updating_from + 1; i < index_updating_to; i++) {
						r_support.quantity_fuel[i] += (r_support.quantity_fuel[index_updating_from] - Fuel_before);
						r_support.weight[i] -= (r_support.quantity_fuel[index_updating_from] - Fuel_before);
					}
				}
			}

		}
	}
	if (routes_after_move.size() == 0) return routes;
	else {
		if (calculate_ObjectiveFunction(routes, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) != calculate_ObjectiveFunction(routes_after_move, map_airstrip, map_airplane, from_to, from_to_FuelConsumed)) {
			cout << " Costo Routes: " << calculate_ObjectiveFunction(routes, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
			cout << " Costo routes_after_move: " << calculate_ObjectiveFunction(routes_after_move, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
			//cin.get();
		}
		return routes_after_move;
	}
}

//************************************************************************************************************************************************************************





void heuristic_costructive_first_fase_secIter(vector<Route>& solution, vector<Airplane> airplanes, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, double start_day, double end_day, vector<Passenger> passengers, int number_of_aircraft, map<string, double>& from_to, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {

	//cout << " ----------------- Sono al secondo giro adesso ho gia soddisfatto alcuni passeggieri me ne mancano alcuni -----------------" << endl;
	string situation = "Error";
	int cont = 0;
	string AereiUsati = "";
	for (Route r : solution) AereiUsati += r.aircraft_code + "/";
	//cout << "  Stringa: " << AereiUsati << endl;
	do {
		vector<Passenger> pass_in_solution;
		size_t found = AereiUsati.find(airplanes[cont].code);
		if (found == std::string::npos) {
			//cout << " Sto guardando aereo " << airplanes[cont].code << endl;
			Route r(airplanes[cont].code, pass_in_solution);
			r.addPlace(airplanes[cont].depot, map_airstrip[airplanes[cont].depot].fuel, map_airplane[r.aircraft_code].max_fuel, 0.0, 0, 0.0, 0.0);
			//cout << " Ho cerato un aroute per l'aereo " << r.aircraft_code << endl;
			solution.push_back(r);
		}
		cont++;
	} while (cont < number_of_aircraft);
	//cout << " ---------------------Check: Adesso dovrei avere a disposizione 20 route ---------------  = " << solution.size() << endl;

	for (auto p : passengers) {
		string situation = "Error";
		int best_route = -1; //index of the best route where can i put my passenger
		int best_from = -1;
		int best_to = -1;
		double best_cost = DBL_MAX;
		int i = 0;
		//cout << "- sto calcolando dove metttere il passeggero: " << p.name << endl;
		//qui calcolo solo dove mettere il passeggero
		for (auto r : solution) {
			if (r.primo_pass == false) {
				if (r.places[r.index - 1] == p.departure_location) {
					//in questo caso c'è solo lui nella route, il costo è dato dalla sua inserzione, quindi, chilometri, costo fisso per uso aereo e fuel
					double cost = map_airplane[r.aircraft_code].fixed_cost + from_to[p.departure_location + ";" + p.arrival_location];
					//double travel_time = from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[r.aircraft_code].speed;
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*
					if (travel_time <= 1) {
						fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/

					cost += fuel_consumed;
					//per il check sul fuel:
					double fuel_after_trip = 0.0;
					fuel_after_trip = r.quantity_fuel[r.index - 1] - fuel_consumed;
					if (best_cost > cost && fuel_after_trip >= (map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = i;
						situation = "A";
					}
				}
				else {
					//qui c'è solo lui nell'aereo ma deve fare un pezzo vuoto all'inizio dal deposito alla partenza per il cliente, devo aggiungere più kilometri e un landing stop
					//non considero le time windows, faccio una partenza mirata per loro visto che sono i primi
					double cost = map_airplane[r.aircraft_code].fixed_cost + from_to[p.departure_location + ";" + p.arrival_location] + from_to[r.places[r.index - 1] + ";" + p.departure_location];
					//double travel_time = (from_to[p.departure_location + ";" + p.arrival_location] + from_to[r.places[r.index - 1] + ";" + p.departure_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + p.departure_location + ";" + p.arrival_location] + from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + p.departure_location];
					/*
					if (travel_time <= 1) {
						fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					cost += fuel_consumed;

					//per il check sul fuel
					//double travel_primo_tratto = (from_to[r.places[r.index - 1] + ";" + p.departure_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed_primo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + p.departure_location];
					/*
					if (travel_primo_tratto <= 1) {
						fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_primo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					//****
					double travel_secondo_tratto = (from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed_secondo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*
					if (travel_secondo_tratto <= 1) {
						fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_secondo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
					//refuel
					double f_after_primo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto;
					double f_after_secondo_tratto = 0.0;
					if (map_airstrip[p.departure_location].fuel) {
						f_after_secondo_tratto = map_airplane[r.aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
					}
					else {
						f_after_secondo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
					}

					if (best_cost > cost && f_after_primo_tratto >= map_airplane[r.aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = i;
						situation = "B";
					}
				}
			}
			else {
				//nella route c'è almeno un altro passeggero, devo fare le considerazioni riguardo alla fisibilità della route
				//prendo tutte le coppie FROM-TO che ci sono nella route, se non c'è il FROM, non cerco il TO
				vector<int> FROM;
				vector<int> TO;
				for (int t = 0; t < r.index; t++) {
					if (r.places[t] == p.departure_location) FROM.push_back(t);
				}

				if (FROM.size() != 0) {
					//dentro questo abbiamo trovato dei FROM 
					for (int t = FROM[0]; t < r.index; t++) {
						if (r.places[t] == p.arrival_location) TO.push_back(t);
					}

					if (TO.size() != 0) {
						for (auto from : FROM) {
							for (auto to : TO) {
								if (from < to && to - from <= p.stop) {
									//se sono qua dentro il to è maggiore del from e gli stop intermedi sono minori di tre
									//per prima cosa guardo se ci sto con la capacità, altrimenti break sul primo for
									bool capacity_satisfy = true;
									for (int c = from; c < to; c++) {
										if ((r.capacity[c] + 1) > map_airplane[r.aircraft_code].capacity) capacity_satisfy = false;

										//double travel_time = (from_to[r.places[c] + ";" + r.places[c + 1]]) / map_airplane[r.aircraft_code].speed;
										double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[c] + ";" + r.places[c + 1]];
										/*
										if (travel_time <= 1) {
											fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
										}
										else {
											fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
										}
										*/
										double fuel_i_j = fuel_consumed + map_airplane[r.aircraft_code].min_fuel;

										//aggiunto questa parte per l'ultimo tratto che deve prevedere l'andare da almeno un'altra parte con il fuel
										if (c == to - 1) fuel_i_j += location_fuel[r.aircraft_code + "/" + p.arrival_location];

										if (!r.refueling[c] && r.weight[c] - p.weight + (r.quantity_fuel[c] - fuel_i_j) < 0) capacity_satisfy = false;

									}
									//se non soddisfa la capacità non guardo neanche e passo al TO successivo
									if (!capacity_satisfy) break; //check also for the fuel;





									//se sorpasso il break vuol dire che soddisfo la capacità, in questo caso il solo costo che considerò per l'aggiunta del passeggero qui
									//è la time windows, se calcolo la time windows qua vuol dire che sfrutto il tempo in cui mi trovo in queste posizioni

									double TW_departure = 0.0;
									double t_arr_departure = r.time_arr[from];
									if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
									if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

									double TW_arrival = 0.0;
									double t_arr_arrival = r.time_arr[to];
									if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
									if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;

									double cost = TW_departure + TW_arrival;
									if (best_cost > cost) {
										best_cost = cost;
										best_route = i;
										situation = "D";
										best_from = from;
										best_to = to;
									}
								}
							}
						}
					}
					//da qui in giu considero il caso in cui non ci sono TO ma anche se ci sono ma non mi conviene farlo fermare li 
					//quindi il for per tutti i from ma al di fuori della route e poi considero anche il costo di aggiungerlo a parte il pezzetto che manca
					if (r.places[r.index - 1] != p.arrival_location) {
						for (auto from : FROM) {
							bool capacity_satisfy = true;
							for (int c = from; c < r.index; c++) {
								if ((r.capacity[c] + 1) > map_airplane[r.aircraft_code].capacity) capacity_satisfy = false;

								if (c < r.index - 1) {
									//double travel_time = (from_to[r.places[c] + ";" + r.places[c + 1]]) / map_airplane[r.aircraft_code].speed;
									double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[c] + ";" + r.places[c + 1]];
									/*
									if (travel_time <= 1) {
										fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
									}
									else {
										fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
									}
									*/
									double fuel_i_j = fuel_consumed + map_airplane[r.aircraft_code].min_fuel;

									if (!r.refueling[c] && r.weight[c] - p.weight + (r.quantity_fuel[c] - fuel_i_j) < 0) capacity_satisfy = false;
								}
							}
							//se non soddisfa la capacità non guardo neanche e passo al TO successivo
							//cout << p.stop<< endl;
							if (capacity_satisfy && (r.index - from) <= p.stop) {

								double TW_departure = 0.0;
								double t_arr_departure = r.time_arr[from];
								if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
								if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

								double cost = TW_departure;
								// ora ci metto chilometri e fuel dell'ultimo pezzo;
								cost += from_to[r.places[r.index - 1] + ";" + p.arrival_location];
								double travel_time = (from_to[r.places[r.index - 1] + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed;
								double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + p.arrival_location];
								/*
								if (travel_time <= 1) {
									fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
								}
								else {
									fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
								}
								*/
								cost += fuel_consumed;

								bool fuel_ok = true;
								if (!r.refueling[r.index - 1]) {
									double fuel_i_j = fuel_consumed + map_airplane[r.aircraft_code].min_fuel;
									if (r.weight[r.index - 1] - p.weight + (r.quantity_fuel[r.index - 1] - fuel_i_j) < 0) fuel_ok = false;
								}

								double TW_arrival = 0.0;
								double t_arr_arrival = 0.0;
								t_arr_arrival = r.time_arr[r.index - 1] + travel_time * 60 + map_airstrip[r.places[r.index - 1]].ground_time;
								if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
								if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;
								cost += TW_arrival;

								if (fuel_ok && best_cost > cost && t_arr_arrival <= end_day && r.quantity_fuel[r.index - 1] - fuel_consumed >= (map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code + "/" + p.arrival_location])) {
									best_cost = cost;
									best_route = i;
									best_from = from;
									situation = "E";
								}
							}
						}
					}
					//guardo il costo di aggiungere un pezzo alla fine
					//double travel_time = (from_to[r.places[r.index - 1] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + p.departure_location] + from_to_FuelConsumed[r.aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*
					if (travel_time <= 1) {
						fuel_consumed = travel_time * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (travel_time - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					double cost = fuel_consumed + from_to[r.places[r.index - 1] + ";" + p.departure_location] + from_to[p.departure_location + ";" + p.arrival_location];

					double TW_departure = 0.0;
					double t_arr_departure = r.time_arr[r.index - 1] + (map_airstrip[r.places[r.index - 1]].ground_time + (from_to[r.places[r.index - 1] + ";" + p.departure_location]) / map_airplane[r.aircraft_code].speed) * 60;
					if (t_arr_departure < p.early_departure) TW_departure = p.early_departure - t_arr_departure;
					if (t_arr_departure > p.late_departure) TW_departure = t_arr_departure - p.late_departure;

					double TW_arrival = 0.0;
					double t_arr_arrival = t_arr_departure + map_airstrip[p.departure_location].ground_time + ((from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed) * 60;
					if (t_arr_arrival < p.early_arrival) TW_arrival = p.early_arrival - t_arr_arrival;
					if (t_arr_arrival > p.late_arrival) TW_arrival = t_arr_arrival - p.late_arrival;
					cost += TW_departure + TW_arrival;

					//per il check sul fuel:
					//double travel_primo_tratto = (from_to[r.places[r.index - 1] + ";" + p.departure_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed_primo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + r.places[r.index - 1] + ";" + p.departure_location];
					/*
					if (travel_primo_tratto <= 1) {
						fuel_consumed_primo_tratto = travel_primo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_primo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_primo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}
					*/
					//****
					//double travel_secondo_tratto = (from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[r.aircraft_code].speed;
					double fuel_consumed_secondo_tratto = from_to_FuelConsumed[r.aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];
					/*if (travel_secondo_tratto <= 1) {
						fuel_consumed_secondo_tratto = travel_secondo_tratto * map_airplane[r.aircraft_code].fuel_burn_first;
					}
					else {
						fuel_consumed_secondo_tratto = map_airplane[r.aircraft_code].fuel_burn_first + (travel_secondo_tratto - 1)*map_airplane[r.aircraft_code].fuel_burn_second;
					}*/

					//ora fisso le vairabili che mi servono, questo lo faccio perchè nella departure per il passeggero potrebbe esserci il caso in cui l'aero possa fare 
					//refuel
					double f_after_primo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto;
					double f_after_secondo_tratto = 0.0;
					if (map_airstrip[p.departure_location].fuel) {
						f_after_secondo_tratto = map_airplane[r.aircraft_code].max_fuel - fuel_consumed_secondo_tratto;
					}
					else {
						f_after_secondo_tratto = r.quantity_fuel[r.index - 1] - fuel_consumed_primo_tratto - fuel_consumed_secondo_tratto;
					}



					if (best_cost > cost && t_arr_arrival <= end_day && f_after_primo_tratto >= map_airplane[r.aircraft_code].min_fuel && f_after_secondo_tratto >= (map_airplane[r.aircraft_code].min_fuel + location_fuel[r.aircraft_code + "/" + p.arrival_location])) {
						best_cost = cost;
						best_route = i;
						situation = "C";
					}

				}
			}
			i++;
		}

		//cout << " caso : " << situation << " for the passeger:" << endl;
		//p.print();
		//ora devo aggiungere il passeggero nel posto migliore, quindi serve valutare in che caso sono A,B,C,D
		if (situation == "A") {
			solution[best_route].primo_pass = true;
			//time
			solution[best_route].time_dep[solution[best_route].index - 1] = p.early_departure + map_airstrip[p.departure_location].ground_time;
			solution[best_route].time_arr[solution[best_route].index - 1] = p.early_departure; // in questo caso anche l'arrivo in quanto è la partenza dal depot

			p.solution_from = solution[best_route].index - 1;
			solution[best_route].capacity[solution[best_route].index_cap - 1]++;

			//for the weight
			solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
				solution[best_route].quantity_fuel[solution[best_route].index_cap - 1] - p.weight;  //here i put max_fuel because at the beginnig in the depot all the airplane have full fuel
			if (solution[best_route].weight[solution[best_route].index_cap - 1] < 0) {
				solution[best_route].quantity_fuel[solution[best_route].index_cap - 1] += solution[best_route].weight[solution[best_route].index_cap - 1];
				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					solution[best_route].quantity_fuel[solution[best_route].index_cap - 1] - p.weight;
			}
			//end for weight




			double travel_time = ((from_to[p.departure_location + ";" + p.arrival_location]) / map_airplane[solution[best_route].aircraft_code].speed) * 60;
			double time_from = solution[best_route].time_dep[solution[best_route].index - 1];
			double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + p.departure_location + ";" + p.arrival_location];

			if (map_airstrip[p.arrival_location].fuel) {
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 0, time_from + travel_time, time_from + travel_time + map_airstrip[p.arrival_location].ground_time);
				//for the weight
				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people - map_airplane[solution[best_route].aircraft_code].max_fuel;
				//end for weight
			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];

				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time_from + travel_time, time_from + travel_time + map_airstrip[p.arrival_location].ground_time);
				//for the weight
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] + fuel_consumed + p.weight;
				//end for weight

			}
			p.solution_to = solution[best_route].index - 1;
			solution[best_route].passengers_in_route.push_back(p);





		}
		if (situation == "B") {
			solution[best_route].primo_pass = true;
			solution[best_route].time_arr[solution[best_route].index - 1] = p.early_departure - (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60 -
				map_airstrip[solution[best_route].places[solution[best_route].index - 1]].ground_time;
			solution[best_route].time_dep[solution[best_route].index - 1] = p.early_departure - (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;

			//for the weight
			solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
				solution[best_route].quantity_fuel[solution[best_route].index_cap - 1];  //here i put max_fuel because at the beginnig in the depot all the airplane have full fuel
			//end for weight

			double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location];

			if (map_airstrip[p.departure_location].fuel) {
				solution[best_route].addPlace(p.departure_location, map_airstrip[p.departure_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 1, p.early_departure, p.early_departure + map_airstrip[p.departure_location].ground_time);

				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel - p.weight;
			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];

				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;

				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.departure_location, map_airstrip[p.departure_location].fuel, fuel_before - fuel_consumed, 0.0, 1, p.early_departure, p.early_departure + map_airstrip[p.departure_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] - p.weight + fuel_consumed;

			}
			p.solution_from = solution[best_route].index - 1;
			double time = p.early_departure + map_airstrip[p.departure_location].ground_time + (from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;




			if (map_airstrip[p.arrival_location].fuel) {
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);

				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel;
			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];
				double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location];
				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;
				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] + p.weight + fuel_consumed;

			}
			p.solution_to = solution[best_route].index - 1;
			solution[best_route].passengers_in_route.push_back(p);




		}
		if (situation == "C") {

			if (map_airstrip[p.departure_location].fuel) {
				solution[best_route].addPlace(p.departure_location, map_airstrip[p.departure_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 1,
					solution[best_route].time_dep[solution[best_route].index - 1] +
					(from_to[solution[best_route].places[solution[best_route].index - 1] + ";" +
						p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60,
					solution[best_route].time_dep[solution[best_route].index - 1] + (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" +
						p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60 + map_airstrip[p.departure_location].ground_time);

				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel - p.weight;


			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];
				double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location];
				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;

				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.departure_location, map_airstrip[p.departure_location].fuel, fuel_before - fuel_consumed, 0.0, 1, solution[best_route].time_dep[solution[best_route].index - 1] +
					(from_to[solution[best_route].places[solution[best_route].index - 1] + ";" +
						p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60,
					solution[best_route].time_dep[solution[best_route].index - 1] + (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" +
						p.departure_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60 + map_airstrip[p.departure_location].ground_time);

				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] - p.weight + fuel_consumed;

			}
			p.solution_from = solution[best_route].index - 1;
			double time = solution[best_route].time_dep[solution[best_route].index - 1] + (from_to[p.departure_location + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;





			if (map_airstrip[p.arrival_location].fuel) {
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel;

			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];
				double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location];
				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;

				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] + fuel_consumed;

			}


			p.solution_to = solution[best_route].index - 1;
			solution[best_route].passengers_in_route.push_back(p);
		}
		if (situation == "D") {



			for (int h = best_from; h < best_to; h++) {
				solution[best_route].capacity[h]++;
				solution[best_route].weight[h] -= p.weight;
			}

			//**************************************************************************
			double add_fuel = 0;
			int index_weight_neg = -1;
			for (int j = best_from; j < solution[best_route].index; j++) {
				//cout << " Sono nel rapeir devo aggiunger fuel linea 1015 devo guardare da " << node_add_from << " a " << node_add_to << endl;
				if (solution[best_route].weight[j] < 0) {
					//cout << " Weigth negativo in " << j << weight[j] << endl;
					add_fuel = solution[best_route].weight[j];
					index_weight_neg = j;
					int index_refueling = index_weight_neg;
					for (int i = index_weight_neg; i >= 0; i--) {
						if (solution[best_route].refueling[i]) {
							index_refueling = i;
							break;
						}
					}
					//cout << " Paro ad aggiornare in index refule " << index_refueling << endl;
					for (int t = index_refueling; t < solution[best_route].index; t++) {
						if (solution[best_route].refueling[t] && t != index_refueling) break;
						//cout << " Aggiorno nodo " << t << endl;
						solution[best_route].quantity_fuel[t] += add_fuel;
						solution[best_route].weight[t] -= add_fuel;
						//cout << " Weight dopo " << weight[t] << endl;
					}
				}
			}
			//**************************************************************************




			p.solution_from = best_from;
			p.solution_to = best_to;
			solution[best_route].passengers_in_route.push_back(p);
		}
		if (situation == "E") {


			for (int h = best_from; h < solution[best_route].index; h++) {
				solution[best_route].capacity[h]++;
				solution[best_route].weight[h] -= p.weight;


			}

			//******************************************************************************
			double add_fuel = 0;
			int index_weight_neg = -1;
			for (int j = best_from; j < solution[best_route].index; j++) {
				//cout << " Sono nel rapeir devo aggiunger fuel linea 1015 devo guardare da " << node_add_from << " a " << node_add_to << endl;
				if (solution[best_route].weight[j] < 0) {
					//cout << " Weigth negativo in " << j << weight[j] << endl;
					add_fuel = solution[best_route].weight[j];
					index_weight_neg = j;
					int index_refueling = index_weight_neg;
					for (int i = index_weight_neg; i >= 0; i--) {
						if (solution[best_route].refueling[i]) {
							index_refueling = i;
							break;
						}
					}
					//cout << " Paro ad aggiornare in index refule " << index_refueling << endl;
					for (int t = index_refueling; t < solution[best_route].index; t++) {
						if (solution[best_route].refueling[t] && t != index_refueling) break;
						//cout << " Aggiorno nodo " << t << endl;
						solution[best_route].quantity_fuel[t] += add_fuel;
						solution[best_route].weight[t] -= add_fuel;
						//cout << " Weight dopo " << weight[t] << endl;
					}
				}
			}
			//******************************************************************************

			p.solution_from = best_from;
			string place_1 = solution[best_route].places[solution[best_route].index - 1];
			double aircraft_speed = map_airplane[solution[best_route].aircraft_code].speed;
			double time = solution[best_route].time_dep[solution[best_route].index - 1] + (from_to[place_1 + ";" + p.arrival_location] / aircraft_speed) * 60;

			if (map_airstrip[p.arrival_location].fuel) {
				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, map_airplane[solution[best_route].aircraft_code].max_fuel, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = map_airplane[solution[best_route].aircraft_code].weight_fuel_people -
					map_airplane[solution[best_route].aircraft_code].max_fuel;

			}
			else {
				double fuel_before = solution[best_route].quantity_fuel[solution[best_route].index - 1];
				double fuel_consumed = from_to_FuelConsumed[solution[best_route].aircraft_code + ";" + solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location];
				//double travel_time = (from_to[solution[best_route].places[solution[best_route].index - 1] + ";" + p.arrival_location] / map_airplane[solution[best_route].aircraft_code].speed) * 60;
				/*
				if (travel_time <= 60) {
					fuel_consumed += (travel_time / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_first;
				}
				else {
					fuel_consumed += map_airplane[solution[best_route].aircraft_code].fuel_burn_first + ((travel_time - 60) / 60)*map_airplane[solution[best_route].aircraft_code].fuel_burn_second;
				}
				*/

				solution[best_route].addPlace(p.arrival_location, map_airstrip[p.arrival_location].fuel, fuel_before - fuel_consumed, 0.0, 0, time, time + map_airstrip[p.arrival_location].ground_time);
				solution[best_route].weight[solution[best_route].index_cap - 1] = solution[best_route].weight[solution[best_route].index_cap - 2] + fuel_consumed + p.weight;

			}

			p.solution_to = solution[best_route].index - 1;
			solution[best_route].passengers_in_route.push_back(p);

		}
		//if (situation == "Error") cout << " il passeggero: " << p.name << " non trova sistemazione" << endl;
	}


	//cout << " -------------- Ho finito euristico seconda fase adesso devo cancellare le route in eccesso  ----------- " << endl;
	//cout << " -- Alla fine in questa fase vado a cancellare le route che non sono state prese ma che eranoo state create -------" << endl;
	//cout << " ------------------------- Ne ho prima di cancellarne:  --------------------- " << solution.size() << endl;
	vector<int> Elimina;
	for (int s = 0; s < solution.size(); s++) {
		if (solution[s].index <= 1) {
			Elimina.push_back(s);
		}
	}

	for (int i = (int)(Elimina.size()) - 1; i >= 0; i--) {
		solution.erase(solution.begin() + Elimina[i]);
	}


	//cout << " ------------------------- Ne ho dopo la cancellazione:  --------------------- " << solution.size() << endl;

}


vector<Route> repairSP(vector<Route> route_destroy, vector<Passenger> passenger_removed, map<string, Airplane>& map_airplane, map<string, Airstrip>& map_airstrip, map<string, double>& from_to, vector<Airplane>& airplanes, double start_day, double end_day, vector<Passenger> passengers, int number_of_aircraft, map<string, double>& location_fuel, map<string, double>& from_to_FuelConsumed) {
	vector<vector<Route>> solutionAllSub;
	int NAirplane = 20;
	/* cout << " Stampo Le route distrutte: " << endl;
	int Npass = 0;
	for (Route r : route_destroy) {
		r.print();
		Npass += r.passengers_in_route.size();
	}
	cout << " Dopo la distruzione ho " << Npass << endl;
	*/
	double dividendo = (double)(number_of_aircraft * passenger_removed.size());
	double denominatore = (double)(passengers.size());
	int number_of_aircraft_subset = 10 + (int)(round(dividendo / denominatore));
	if (number_of_aircraft_subset > number_of_aircraft)  number_of_aircraft_subset = number_of_aircraft;
	int iteration_subset = 0;
	int iteration_max_subset = (int)(passenger_removed.size()) / 3;
	//cout << " Numero di Itearazioni per questa distruzione: " << iteration_max_subset << endl;
	int Best_iteration = 0;
	double Best_cost = std::numeric_limits<double>::max();
	do {
		//cout << " ------------------ Sono al Itarzione del sottoinsime numero = " << iteration << " Di: " << iteration_max << " ---------------- " << endl;
		//cout << " ------------------ Sono al Itarzione del Sort numero = " << iteration_subset << " Di: " << iteration_max_subset << " ---------------- " << endl;
		// Lo ordino in modo random
		auto rng2 = default_random_engine{};
		shuffle(passenger_removed.begin(), passenger_removed.end(), rng2);
		vector<Route> solution;
		vector<Route> Route_to_fix = route_destroy;
		//cout << " Route da dare al costruittivo = "<< Route_to_fix.size() << endl;
		heuristic_costructive_first_fase_secIter(Route_to_fix, airplanes, map_airplane, map_airstrip, start_day, end_day, passenger_removed, number_of_aircraft, from_to, location_fuel, from_to_FuelConsumed);
		double cost_objectiveFunction_fisrt_fase = calculate_ObjectiveFunction(Route_to_fix, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
		//cout << "The cost of the objective function first fase is: " << cost_objectiveFunction_fisrt_fase << endl;
		//cout << "***********************SOLUTION SECOND FASE***********************" << endl;
		solution = heuristic_costructive_second_fase_SP(Route_to_fix, end_day);
		double cost_objectiveFunction_second_fase = calculate_ObjectiveFunction(solution, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
		/*if (cost_objectiveFunction_second_fase < Best_cost) {
			Best_cost = cost_objectiveFunction_second_fase;
			Best_iteration = iteration_subset;
		}
		//cout << "The cost of the objective function second fase is: " << cost_objectiveFunction_second_fase << endl;
		//cout << " Passo al modello una soluzione di route numero " << solution.size();
		*/
		solutionAllSub.push_back(solution);
		iteration_subset++;
	} while (iteration_subset < iteration_max_subset);
	//cout << " CHECK -----> Passo al modello un numero di soluzioni ---> " << solutionAllSub.size() << endl;
	//cout << " CHECK -----> Passo al modello un numero di passeggieri ---> " << passengers.size() << endl;
	//cout << " CHECK -----> La migliore iterazione e la numero ---> " << Best_iteration << endl;
	//cout << " CHECK -----> Costo migliore iterazione  ---> " << Best_cost << endl;
	//Mi preparo per chiamare il modello con il Pool di route generato
	vector<Airplane> airplanes_model;
	for (auto k : map_airplane) {
		airplanes_model.push_back(k.second);
	}
	map<string, vector<Route>> airplane_routes;
	for (Airplane a : airplanes_model) {
		vector<Route> routes;
		airplane_routes.insert(make_pair(a.code, routes));
	}
	for (auto solution : solutionAllSub) {
		for (Route r : solution) {
			airplane_routes[r.aircraft_code].push_back(r);
		}
	}

	//finito di fissare gli aerei
	map<string, int> contPass;
	for (Passenger p : passengers) {
		contPass.insert(make_pair(p.name + p.surname + p.pnr
			+ p.code_flight + p.gender + p.arrival_location
			+ p.departure_location + to_string(p.weight), 0));
	}
	map<string, int> ContNomi;
	for (Passenger p : passengers) {
		ContNomi.insert(make_pair(p.name + "/" + p.surname, 0));
	}
	for (Passenger p : passengers) ContNomi[p.name + p.surname + p.pnr
		+ p.code_flight + p.gender + p.arrival_location
		+ p.departure_location + to_string(p.weight)]++;
	//for (auto x : ContNomi) {
		//cout << x.first << " --- " << x.second << endl;
	//}



	vector<vector<vector<int>>> A3;  //matrix A
	vector<vector<double>> C;  //cost
	vector<Route> routes;
	for (auto airplane : airplanes_model) {
		//cout << "Airplane: " << airplane.code << endl;
		vector<double> c;
		vector<vector<int>> A2;
		for (Route r : airplane_routes[airplane.code]) {
			//r.print();
			routes.push_back(r);
			vector<int> A1;
			for (Passenger p : passengers) {
				auto it = find_if(r.passengers_in_route.begin(), r.passengers_in_route.end(),
					[=](Passenger p_)
				{
					return p.pnr == p_.pnr;
				});
				if (it != r.passengers_in_route.end())
				{
					A1.push_back(1);
					contPass[p.name + p.surname + p.pnr
						+ p.code_flight + p.gender + p.arrival_location
						+ p.departure_location + to_string(p.weight)]++;

				}
				else {
					A1.push_back(0);
				}
			}
			A2.push_back(A1);
			//cout << "Costo: " << r.cost << endl;
			c.push_back(r.cost);
		}
		A3.push_back(A2);
		C.push_back(c);
	}
	//cout << "..................Finish to build all the structure for the Model.................." << endl;
	//cout << " Al modello sto passando un numero di Route generate: " << routes.size() << endl;
	//Creating model with gurobi
	//Create new Model object
	//Mi preparo a ricere le route scelte dal modello
	vector<Route> solution_model;
	Model *model = new Model(A3, C, airplanes_model, airplane_routes, routes, (int)(passengers.size()), passengers, solution_model, map_airplane);
	//Create and solve model with gurobi
	model->create_Model_grb_for_SP(NAirplane);
	// adesso vettore delle Route non è piu vuoto
	// Non ho piu tutti gli aerei disponibili cout<<endl
	//cout << " Ho finito con il modello ---- Copio le Ruoute --- che sono: " << model->solution_model.size() << endl;
	int n = 0;
	for (Route r : model->solution_model) n += (int)r.passengers_in_route.size();
	//cout << " Numero passeggieri della soluzione del modello: " << n << endl;
	if (model->solution_model.size() > 0 && (n == passengers.size())) {
		for (Route s : model->solution_model) solution_model.push_back(s);
		//for (auto x : contPass) cout << x.first << " --- " << x.second << " In realta = " << (x.second / ContNomi[x.first]) << endl;
		return solution_model;
	}
	else {
		//cout << " Modello mi ha dato Infeassible stampo soluzione con costo ----> " << calculate_ObjectiveFunction(solutionAllSub[Best_iteration], map_airstrip, map_airplane, from_to,from_to_FuelConsumed) << endl;
		//for (auto x : contPass) cout << x.first << " --- " << x.second << " In realta = " << (x.second / ContNomi[x.first]) << endl;
		n = 0;
		for (Route r : solutionAllSub[Best_iteration]) n += (int)r.passengers_in_route.size();
		//cout << " Numero di passeggieri della best solution " << n << endl;
		//cout << " Mentre dovrebbero essere: " << passengers.size() << endl;
		if (n == passengers.size())  return solutionAllSub[Best_iteration];
		else {
			vector<Route> vuoto(0);
			//cout << " Ritorno Vettore vuoto " << endl;
			return vuoto;
		}
	}

	delete model;
}



double costo_senza_time_windows(vector<Route>& solution, map<string, Airstrip>& map_airstrip, map<string, Airplane>& map_airplane, map<string, double>& from_to, map<string, double>& from_to_FuelConsumed) {
	double cost = 0.0;

	for (auto& r : solution) {
		double cost_route = 0.0;
		//cout << "Route-----" << endl;
		//first of all calculate the fixed cost of use the aircraft and the landing cost;
		cost += map_airplane[r.aircraft_code].fixed_cost;
		cost_route += map_airplane[r.aircraft_code].fixed_cost;
		//cout << "costo fisso: " << cost << endl;
		for (int i = 1; i < r.index; i++) {
			cost += map_airstrip[r.places[i]].landing_cost;
			cost_route += map_airstrip[r.places[i]].landing_cost;
		}
		//cout << "costo landing: " << cost << endl;



		//second of all calculate the cost of the Km and the fuel burn
		double mileage = 0.0;
		//double first_hour = 0.0;
		//double second_hour = 0.0;
		double fuel_consumed = 0.0;
		for (int i = 0; i < r.index - 1; i++) {
			//double time_travel = 0.0;
			if (i == 0 && r.capacity[i] == 0) {
				mileage = 0.0;
			}
			else {
				mileage += from_to[r.places[i] + ";" + r.places[i + 1]];
				fuel_consumed = from_to_FuelConsumed[r.aircraft_code+";"+r.places[i] + ";" + r.places[i + 1]] ;
			}

			/*if (time_travel <= 1) {
				first_hour += time_travel;
			}
			else {
				first_hour += 1;
				second_hour += (time_travel - 1);
			}
			*/
		}
		//now i add the mileage and the fuel consumption to the objective function
		cost += mileage;
		cost_route += mileage;
		//cout << "costo milege: " << cost << endl;
		cost += fuel_consumed;
		cost_route += fuel_consumed;
		//cout << "costo fuel: " << cost << endl;
		//now i have to calculate the penalitis regarding the time windows for each passeger
	}

	return cost;


};

double costo_time_windows(vector<Route>& solution, map<string, Airstrip> map_airstrip, map<string, Airplane> map_airplane, map<string, double> from_to) {
	double cost = 0.0;

	for (auto& r : solution) {

		for (auto p : r.passengers_in_route) {
			double time_departure = r.time_arr[p.solution_from];
			double time_arrival = r.time_arr[p.solution_to];

			double TW_departure = 0.0;
			if (time_departure < p.early_departure) TW_departure = p.early_departure - time_departure;
			if (time_departure > p.late_departure) TW_departure = time_departure - p.late_departure;

			double TW_arrival = 0.0;
			if (time_arrival < p.early_arrival) TW_arrival = p.early_arrival - time_arrival;
			if (time_arrival > p.late_arrival) TW_arrival = time_arrival - p.late_arrival;

			cost += TW_departure + TW_arrival;
		}
	}

	return cost;
}


//data una location mi restituisce la location più vicina
string location_closest_with_fuel(string location, map<string, double> from_to, map<string, Airstrip>& map_airstrip) {
	string result = "";
	double value = DBL_MAX;

	for (auto x : from_to) {
		if (split(x.first, ';')[0] == location && x.second < value && x.second != 0 &&  map_airstrip[split(x.first, ';')[1]].fuel ) {
			result = split(x.first, ';')[1];
			value = x.second;
		}
	}


	return result;

}



//per il tratto finale
map<string, double> fillLocation_fuel(vector<Airstrip> airstrips, vector<Airplane> airplanes, map<string, double>& from_to, map<string, Airstrip>& map_airstrip) {

	map <string, double> risultato;
	for (Airplane f : airplanes) {
		for (Airstrip a : airstrips) {
			if (a.fuel) {
				risultato.insert(make_pair(f.code + "/" + a.code, 0.0));
			}
			else {
				double fuel_needed = 0;
				double time_fly = from_to[a.code + ";" + location_closest_with_fuel(a.code, from_to, map_airstrip)] / f.speed;
				if (time_fly <= 1) {
					fuel_needed = time_fly * f.fuel_burn_first;
				}
				else {
					fuel_needed = f.fuel_burn_first + (time_fly - 1)*f.fuel_burn_second;
				}
				risultato.insert(make_pair(f.code + "/" + a.code, fuel_needed));
			}
		}
	}


	return risultato;

}



//funzione che TUTTI GLI ERRORI
void stampo_caso_strano(vector<Route> routes, map<string, double>& from_to, map<string, Airplane> map_airplane ) {

	for (Route r : routes) {
		
		if (r.index > r.places.size()) {
			cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON L'INDICE MASSIMO:" << endl;
			r.print();
			system("pause");
		}


		for (Passenger p : r.passengers_in_route) {
			if (r.places[p.solution_from] != p.departure_location || r.places[p.solution_to] != p.arrival_location) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON IL PASSEGGERO:" << endl;
				p.print();
				cout << "nella route: " << endl;
				r.print();
				system("pause");
			}

			if (p.solution_from >= p.solution_to) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON IL PASSEGGERO, INVERSIONE DEL FROM E DEL TO:" << endl;
				p.print();
				cout << "nella route: " << endl;
				r.print();
				system("pause");
			}

		}


		
		for (int i = 1; i < r.index; i++) {

			if (r.time_arr[i] <= (((from_to[r.places[i - 1] + ";" + r.places[i]] / map_airplane[r.aircraft_code].speed) * 60) + r.time_dep[i - 1] - 1) || r.time_arr[i] >= (((from_to[r.places[i - 1] + ";" + r.places[i]] / map_airplane[r.aircraft_code].speed) * 60) + r.time_dep[i - 1] + 1)) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON i TEMPIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII nell arco " << (i - 1) << endl;
				cout << "dovrebbe essere: " << (((from_to[r.places[i - 1] + ";" + r.places[i]] / map_airplane[r.aircraft_code].speed) * 60) + r.time_dep[i - 1]) << " mentre invece è " << r.time_arr[i] << endl;
				r.print();
				system("pause");
			}


			double fly_time = (from_to[r.places[i - 1] + ";" + r.places[i]] / map_airplane[r.aircraft_code].speed);
			double fuel_consumed = 0.0;
			if (fly_time <= 1) {
				fuel_consumed = fly_time * map_airplane[r.aircraft_code].fuel_burn_first;
			}
			else {
				fuel_consumed = map_airplane[r.aircraft_code].fuel_burn_first + (fly_time - 1)* map_airplane[r.aircraft_code].fuel_burn_second;
			}

			if (!r.refueling[i]) {
				if ((r.quantity_fuel[i-1] - r.quantity_fuel[i]) <= (fuel_consumed - 1) || (r.quantity_fuel[i-1] - r.quantity_fuel[i]) >= (fuel_consumed + 1)) {
					cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON IL FUEL nell arco DA " << (i - 1) << " A " << i << endl;
					cout << "dovrebbe essere: " << fuel_consumed << " mentre invece è " << (r.quantity_fuel[i-1] - r.quantity_fuel[i]) << endl;
					r.print();
					system("pause");
				}
			}






		}
		
		
		for (int i = 0; i < r.index - 1; i++) {
			if (r.quantity_fuel[i] < r.quantity_fuel[i + 1] && !r.refueling[i + 1] || r.weight[i] < -0.005) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' IL PROBLEMA O DEL FUEL CHE NON CALA O DEL PESO NEGATIVO" << endl;
				r.print();
				system("pause");
			}


			if (r.places[i] == r.places[i + 1]) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' IL PROBLEMA DI PIu' POSTI UGUALI " << endl;
				r.print();
				system("pause");
			}


		}




		for (int i = 0; i < r.index; i++) {
			double peso_arco_passeggeri = 0.0;
			for (Passenger p : r.passengers_in_route) {
				if (p.solution_from <= i && p.solution_to > i) {
					peso_arco_passeggeri += p.weight;
				}
			}

			if ( (r.quantity_fuel[i] + r.weight[i] + peso_arco_passeggeri) <= (map_airplane[r.aircraft_code].weight_fuel_people - 1) || (r.quantity_fuel[i] + r.weight[i] + peso_arco_passeggeri) >= (map_airplane[r.aircraft_code].weight_fuel_people + 1)) {
				cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' UN PROBLEMA CON IL PESO TOTALE NEL NODO " << i << " CON PESO TOTALE --> "+ to_string(r.quantity_fuel[i] + r.weight[i] + peso_arco_passeggeri) << endl;
				r.print();
				system("pause");
			}
		}

		
			for (int i = 0; i < r.index - 1; i++) {
				double minimo_peso = r.weight[i];
				if (r.quantity_fuel[i] < map_airplane[r.aircraft_code].max_fuel && r.refueling[i]) {
					for (int j = i + 1; j < r.index; j++) {
						if (r.refueling[j]) break;
						if (r.weight[j] < minimo_peso) minimo_peso = r.weight[j];
					}
					if (minimo_peso >= 1) {
						cout << "ATTENTOOOOOOOOOOOOOOOOO C'E' IL PROBLEMA DEL FUEL NON MASSIMO *************************" << endl;
						r.print();
						system("pause");
					}

				}
			}

		
	




	}




}

vector <Route> aggrezione_simple_after_model(vector<Route> solution_model, map<string, Airplane>& map_airplane, map<string, double>& from_to) {
	vector <Route> solution_after;

	cout << "*****************************SOLUTION PRIMA DELL'AGGREAGZIONE********************************" << endl;
	for (Route r : solution_model) {
		r.print();
	}
	cout << "****************************************ora faccio aggregazione con l'ultimo pezzo che si attacca solo se i due posti fine e inizio sono uguali***************" << endl;
	//cerco di collegare le route se è possibile
	//vector <Route> solution_after;
	string index_not = ";";
	for (int r = 0; r < solution_model.size(); r++) {
		for (int r1 = 0; r1 < solution_model.size(); r1++) {
			string val = to_string(r) + ";";
			string val1 = to_string(r1) + ";";

			if (r != r1 && solution_model[r].places[solution_model[r].index - 1] == solution_model[r1].places[0] &&
				solution_model[r].time_dep[solution_model[r].index - 1] <= solution_model[r1].time_arr[0] &&
				map_airplane[solution_model[r].aircraft_code].model == map_airplane[solution_model[r1].aircraft_code].model
				&& index_not.find(val, 0) > index_not.size() && index_not.find(val1, 0) > index_not.size()) {

				index_not += to_string(r) + ";" + to_string(r1) + ";";
				Route r_add(solution_model[r].aircraft_code, solution_model[r].passengers_in_route);
				r_add.primo_pass = true;
				for (int i = 0; i < solution_model[r].index - 1; i++) {
					if (i == solution_model[r].index - 2) {
						r_add.addPlace(solution_model[r].places[i], solution_model[r].refueling[i], solution_model[r].quantity_fuel[i], solution_model[r].weight[i],
							solution_model[r].capacity[i], solution_model[r].time_arr[i], (solution_model[r1].time_arr[0] - (((from_to[solution_model[r].places[i] + ";" + solution_model[r1].places[0]]) / map_airplane[solution_model[r].aircraft_code].speed) * 60)));
					}
					else {
						r_add.addPlace(solution_model[r].places[i], solution_model[r].refueling[i], solution_model[r].quantity_fuel[i], solution_model[r].weight[i],
							solution_model[r].capacity[i], solution_model[r].time_arr[i], solution_model[r].time_dep[i]);
					}
				}

				for (int i = 0; i < solution_model[r1].index; i++) {
					r_add.addPlace(solution_model[r1].places[i], solution_model[r1].refueling[i], solution_model[r1].quantity_fuel[i], solution_model[r1].weight[i],
						solution_model[r1].capacity[i], solution_model[r1].time_arr[i], solution_model[r1].time_dep[i]);
				}
				for (Passenger p : solution_model[r1].passengers_in_route) {
					p.solution_from += (solution_model[r].index - 1);
					p.solution_to += (solution_model[r].index - 1);
					r_add.passengers_in_route.push_back(p);

				}

				solution_after.push_back(r_add);
			}
		}
	}

	for (int r = 0; r < solution_model.size(); r++) {
		string val = ";" + to_string(r) + ";";
		if (index_not.find(val, 0) > index_not.size()) {
			solution_after.push_back(solution_model[r]);
		}
	}





	cout << "*****************************SOLUTION MODEL -POSTERIORI- ********************************" << endl;
	cout << " Numero di soluzioni aggregate: " << solution_after.size() << endl;
	//for (Route r : solution_after) {
		//r.print();
	//}

	return solution_after;



}

vector <Route> aggrezione_complex_after_model(vector<Route> solution_model, map<string, Airplane>& map_airplane, map<string, double>& from_to, map<string, double>& from_to_FuelConsumed) {
	vector <Route> solution_after;

	//cout << "****************************************ora faccio aggregazione complessa***************" << endl;
	//cerco di collegare le route se è possibile
	//vector <Route> solution_after;
	string index_not = ";";
	for (int r = 0; r < solution_model.size(); r++) {
		for (int r1 = 0; r1 < solution_model.size(); r1++) {
			string val = to_string(r) + ";";
			string val1 = to_string(r1) + ";";
			double time_trascorso = (from_to[solution_model[r].places[solution_model[r].index - 1] + ";" + solution_model[r1].places[0]] / map_airplane[solution_model[r].aircraft_code].speed) * 60;
			double fuel_consumed = from_to_FuelConsumed[solution_model[r].aircraft_code +";"+ solution_model[r].places[solution_model[r].index - 1] + ";" + solution_model[r1].places[0]];

			double costo_aggiunta = fuel_consumed + from_to[solution_model[r].places[solution_model[r].index - 1] + ";" + solution_model[r1].places[0]];
			//READ ME: non è importante fare il check se i due posti (finale di una route, inziale della seconda) siano uguali, questa casistica viene eliminata dall'aggregazione semplice
			//non devo nemmeno fare il check sul fuel per andare in un altro posto in quanto vado sicuramente in un deposito dato che tutte le route partono in un depot
			//CONSIDERAZIONE, SI POTREBBE VALUTARE DI TOGLIERE IL PRIMO ARCO DAL DEPOT ALLA PRIMA LOCATION NEL CASO QUESTO SIA VUOTO, MA QUESTO PORTEREBBE ALLA CREAZIONE DI SCENARI DIFFERENTI:
			//		-posso arrivare a tutte le altre locazioni se tolgo il refuel al depot???????????????????????????????????????????????????????????????????????????
			// ho aggiunto il fatto che il costo del tratto aggiuntivo deve essere minore o uguale al costo fisso dell'aereo
			if (r != r1 &&
				solution_model[r].time_dep[solution_model[r].index - 1] + time_trascorso <= solution_model[r1].time_arr[0] &&
				solution_model[r].quantity_fuel[solution_model[r].index - 1] - fuel_consumed >= map_airplane[solution_model[r].aircraft_code].min_fuel &&
				map_airplane[solution_model[r].aircraft_code].model == map_airplane[solution_model[r1].aircraft_code].model
				&& index_not.find(val, 0) > index_not.size() && index_not.find(val1, 0) > index_not.size()
				&& costo_aggiunta <= solution_model[r1].cost
				) {

				index_not += to_string(r) + ";" + to_string(r1) + ";";
				Route r_add(solution_model[r].aircraft_code, solution_model[r].passengers_in_route);
				r_add.primo_pass = true; //N.B. commentare questa riga se si vuole vedere quelle che aggrega
				for (int i = 0; i <= solution_model[r].index - 1; i++) {
					if (i == solution_model[r].index - 1) {
						r_add.addPlace(solution_model[r].places[i], solution_model[r].refueling[i], solution_model[r].quantity_fuel[i], solution_model[r].weight[i],
							solution_model[r].capacity[i], solution_model[r].time_arr[i], (solution_model[r1].time_arr[0] - (((from_to[solution_model[r].places[i] + ";" + solution_model[r1].places[0]]) / map_airplane[solution_model[r].aircraft_code].speed) * 60)));
					}
					else {
						r_add.addPlace(solution_model[r].places[i], solution_model[r].refueling[i], solution_model[r].quantity_fuel[i], solution_model[r].weight[i],
							solution_model[r].capacity[i], solution_model[r].time_arr[i], solution_model[r].time_dep[i]);
					}
				}

				for (int i = 0; i < solution_model[r1].index; i++) {
					r_add.addPlace(solution_model[r1].places[i], solution_model[r1].refueling[i], solution_model[r1].quantity_fuel[i], solution_model[r1].weight[i],
						solution_model[r1].capacity[i], solution_model[r1].time_arr[i], solution_model[r1].time_dep[i]);
				}
				for (Passenger p : solution_model[r1].passengers_in_route) {
					p.solution_from += (solution_model[r].index);
					p.solution_to += (solution_model[r].index);
					r_add.passengers_in_route.push_back(p);

				}

				solution_after.push_back(r_add);
			}
		}
	}

	for (int r = 0; r < solution_model.size(); r++) {
		string val = ";" + to_string(r) + ";";
		if (index_not.find(val, 0) > index_not.size()) {
			solution_after.push_back(solution_model[r]);
		}
	}





	cout << "*****************************SOLUTION MODEL -POSTERIORI- ********************************" << endl;
	for (Route r : solution_after) {
		r.print();
	}

	return solution_after;



}


//***********************************MAIN****************************
int main() {


	//**************************INPUT***********************************
	//reading of AIRPLANE.CSV and creation VECTOR OF AIRPLANES
	vector<Airplane> airplanes = fillAirplane("NewAirplaneAll.csv");
	//cout << "***********************Print airplane***********************" << endl;
	//for (auto f : airplanes) f.print();
	//reading of AIRSTRIP.CSV and creation VECTOR OF AIRSTRIPS
	vector<Airstrip> airstrips = fillAirstrip("NewAirstrip.csv");
	//cout << "***********************Print airstrips***********************" << endl;
	//for (auto f : airstrips) f.print();
	//reading of INSTANCE.CSV and creation VECTOR OF PASSENGER
	vector<Passenger> passengers = fillPassenger("19_07_18_ISTANZA.csv");
	//cout << "***********************Print passengers***********************" << endl;
	//for (auto f : passengers) f.print();
	//system("pause");
	map<string, Passenger> map_id_passenger = fillMapPassenger(passengers);
	/*for (auto x : map_id_passenger) {
		cout << x.first << " ----- > ";
		x.second.print();
		cout << endl;
	}*/
	//bulding of hashmap from_to reading the file Matrix.txt
	map<string, double> from_to = fillMatrix("Matrix.csv", airstrips);

	vector<Passenger> passengers_solution = passengers;
	double Company_Solution = calculationCostCompany("19_07_18_AEREI.txt", "PassengerLuglio.txt", airstrips, airplanes, passengers_solution, from_to);
	cout << " Costo della soluzione della compagnia = " << Company_Solution << endl;
	map<string, Airplane> map_airplane;
	for (auto f : airplanes) map_airplane.insert(make_pair(f.code, f));
	map<string, Airstrip> map_airstrip;
	for (auto f : airstrips) map_airstrip.insert(make_pair(f.code, f));
	//ora faccio la mappa che mi permette di avere come chiave ogni aereo/aeroporto, come valore il fuel necessario, dato quell'aereo per andare nell'aereoporto più vicino con quel fuel
	map<string, double> location_fuel = fillLocation_fuel(airstrips, airplanes, from_to, map_airstrip);
	//ora faccio la mappa che ha chiave codiceAereo;from-to --> fuel consumed per quel tratto con quell'aereo
	map<string, double> from_to_FuelConsumed = fill_from_to_fuel_consumed(from_to, airplanes);
	//cout << "check per la mappa dei consumi" << endl;
	//
	/*
	for (auto x : from_to_FuelConsumed) {
		cout << x.first << " ----- > " << x.second << endl;
	}
	system("pause");*/
	cout << "***********************End reading input quindi comincio a contare il tempo***********************" << endl;

	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	// *******************************************************DA QUA INCOMINCIA IL CODICE DEL MAIN, PRIMA CI SONO SOLO STRUTTURE DATI***********************************
	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	//******************************************************************************************************************************************************************
	double time_spent_model = 0.0;
	double tempo_finale;
	time_t time_now = time(NULL);
	//input heuristic
	int number_airplane = 14; // Per Modello
	int Iter_FirstDo = 0;
	int iterMAX_FirstDo = 1;
	//double best_solution_ever = DBL_MAX;
	int NDestroy = 4;
	int NRepair = 5;
	int NHeuristic = 2;
	int initial_weigth = 5;
	vector<double> Weigth_destroy;
	vector<double> Weigth_repair;
	vector<double> Weigth_heuristic(NHeuristic);
	for (int i = 0; i < NDestroy; i++) Weigth_destroy.push_back(initial_weigth);
	for (int i = 0; i < NRepair; i++) Weigth_repair.push_back(initial_weigth);
	Weigth_heuristic[0] = 0.00;
	Weigth_heuristic[1] = 1.00;
	for (double i : Weigth_destroy) cout << i << " || ";
	cout << endl;
	for (double i : Weigth_repair) cout << i << " || ";
	cout << endl;
	vector<vector<Route>> solutionAll;
	vector<Route> best_solution_route_ever;
	srand(time(NULL));
	int NumeroSA = 0;
	double start_day = 360.0;
	double end_day = 1110.0;
	int number_of_aircraft = 20;
	vector<Route> start_solution_route;
	double start_solution = 0.0;
	int start_route_bs = 0;
	int size_route_bs = 0;
	do {
		cout << " ************************************************************ Inizio un altro giro nel ciclo grande ************************************************************ " << endl;
		double r;
		double best_solution = DBL_MAX;
		int best_iteration = 0;
		int iteration = 0;
		int iteration_max = 15; //35 se vuopi fare un solo giro 
		int T = 20000;
		int Tmin = 50;    //50 un solo giro 
		int k = 0;
		double MinLevel = 2;
		double MaxLevel = 6;
		// Valore che puo variare 0.8 a 0.99
		double alpha = 0.995; // 0.9955 un solo giro
		int DeltaK = 25;      // 35 un solo giro
		int choosen_heuristic = -1;
		if (Iter_FirstDo > 0) {
		  T = 1000;        // Almeno 2000
		  alpha = 0.995; // Almeno 0.997
		  DeltaK = 30; //Almeno 50
			Tmin = 5;
		}
		if (Iter_FirstDo == 0) {
			auto rng1 = default_random_engine{};
			shuffle(begin(passengers), end(passengers), rng1);
			double heuristic_choice = (double)rand() / RAND_MAX;
			//cout << " heuristic_choice =  " << heuristic_choice << endl;
			//for (int i = 0; i < NHeuristic; i++) cout << Accumulated(i, Weigth_heuristic) << " || ";
			//cout << endl;
			if (heuristic_choice < Accumulated(0, Weigth_heuristic)) {
				cout << "*************** I am using the Parallel Heuristic ************" << endl;
				start_solution_route = heuristic_costructive_first_fase(airplanes, map_airplane, map_airstrip, start_day, end_day, passengers, number_of_aircraft, from_to, location_fuel, from_to_FuelConsumed);
				choosen_heuristic = 0;
			}
			else {
				cout << "*************** I am using the Sequential Heuristic ************" << endl;
				start_solution_route = heuristic_costructive_first_fase_sequential(airplanes, map_airplane, map_airstrip, start_day, end_day, passengers, number_of_aircraft, from_to, location_fuel, from_to_FuelConsumed);
				choosen_heuristic = 1;
			}
			start_solution = calculate_ObjectiveFunction(start_solution_route, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
			//cout << "ho appena fatto il costruttivo" << endl;
			//stampo_caso_strano(start_solution_route, from_to, map_airplane);
			solutionAll.push_back(start_solution_route);
		}

		cout << "Costo Starting Greedy Solution: " << start_solution << endl;
		vector<Route> best_solution_route = start_solution_route;
		best_solution = start_solution;
		// SI INIZI IL CILCO CON LA RICERCA LOCALE E SIMULATING ANNEALING
		do {
			NumeroSA++;
			//*************************************heuristic costructive***************************************************************************************
			//cout << "Iteration number: " << iteration << endl;
			//cout << "Temperatura: " << T << endl;
			//cout << "K: " << k << endl;
			cout << "The cost of the best solution X* is: " << best_solution << endl;
			cout << "The cost of the current X is: " << start_solution << endl;
			double random = (double)rand() / RAND_MAX;
			double percentage_route_destroy = (MinLevel + (random * (MaxLevel - MinLevel)));
			//cout << "---> Percentuale di distruzione " << percentage_route_destroy << endl;
			int choosen_destroy = -1;
			int choosen_repair = -1;
			vector<Passenger> passenger_removed;
			// REMOVING OF A RANDOM NODE
			vector<Route> Input_destroy = start_solution_route;
			cout << "***************************DISTRUCTION*******************" << endl;
			double destroy_choice = (double)rand() / RAND_MAX;
			vector<Route> route_destroy;
			//double starting_range = (Weigth_destroy[0]) / (Sum(Weigth_destroy));
			//cout << " destroy_choice =  " << destroy_choice << endl;
			//for (int i = 0; i < Weigth_destroy.size(); i++) cout << Accumulated(i, Weigth_destroy) << " || ";
			//cout << endl;
			//using namespace std::chrono;
			auto start = chrono::high_resolution_clock::now();
			if (destroy_choice < Accumulated(0, Weigth_destroy)) {
				cout << "*************** I am using the Cluster Destroy ************" << endl;
				int num_passenger_cluster = (int)((passengers.size()*0.14) + (random * ((passengers.size()*0.24) - (passengers.size()*0.14))));
				route_destroy = destroy_cluster(num_passenger_cluster, passenger_removed, Input_destroy, map_airplane, map_airstrip, from_to, passengers, map_id_passenger);
				choosen_destroy = 0;
			}
			else if (destroy_choice < Accumulated(1, Weigth_destroy)) {
				cout << "*************** I am using the Worst Destroy ************" << endl;
				route_destroy = destroy_worst(percentage_route_destroy, passenger_removed, Input_destroy, map_airplane, map_airstrip, from_to, from_to_FuelConsumed);
				choosen_destroy = 1;
			}
			else if (destroy_choice < Accumulated(2, Weigth_destroy)) {
				cout << "*************** I am using the Casual Destroy ************" << endl;
				route_destroy = destroy_casual(percentage_route_destroy, passenger_removed, Input_destroy, map_airplane, map_airstrip, from_to, from_to_FuelConsumed);
				choosen_destroy = 2;
			}
			else {
				cout << "*************** I am using the Thanos Destroy ************" << endl;
				route_destroy = destroy_thanos(percentage_route_destroy, passenger_removed, Input_destroy, map_airplane, map_airstrip, from_to, from_to_FuelConsumed);
				choosen_destroy = 3;
			}
			auto stop = chrono::high_resolution_clock::now();
			auto duration = chrono::duration_cast<chrono::seconds>(stop - start);
			double time_spent = Time_Spend((double)duration.count());
			//cout << " Tempo Destroy vero: " << duration.count() << " ma corrisponde al valore trasformato in double = " << time_spent << endl;
			cout << "***************************END DISTRUCTION*******************" << endl;
			//cout << "ho appena fatto la distruzione" << endl;
			//stampo_caso_strano(route_destroy, from_to, map_airplane);
			//for (Route p : route_destroy) p.print();
			//for(Route p : route_destroy) p.print();
			//cout << "ecco i passeggeri da reinserire: " << endl;
			//for (Passenger p : passenger_removed) p.print();
			cout << "********************************REBUILT***************************" << endl;
			vector <Route> solution_rebuilt;
			double repair_choice = (double)rand() / RAND_MAX;
			//cout << " repair_choice =  " << repair_choice << endl;
			//for (int i = 0; i < Weigth_repair.size(); i++) cout << Accumulated(i, Weigth_repair) << " || ";
			//cout << endl;
			auto start_r = chrono::high_resolution_clock::now();
			if (repair_choice < Accumulated(0, Weigth_repair)) {
				cout << "*************** I am using the Repair One ************" << endl;
				solution_rebuilt = repair_one(end_day, route_destroy, map_airplane, passenger_removed, map_airstrip, from_to, location_fuel, from_to_FuelConsumed);
				choosen_repair = 0;
			}
			else if (repair_choice < Accumulated(1, Weigth_repair)) {
				cout << "*************** I am using the Repair SP ************" << endl;
				solution_rebuilt = repairSP(route_destroy, passenger_removed, map_airplane, map_airstrip, from_to, airplanes, start_day, end_day, passengers, number_of_aircraft, location_fuel, from_to_FuelConsumed);
				choosen_repair = 1;
			}
			else if (repair_choice < Accumulated(2, Weigth_repair)) {
				cout << "*************** I am using the Repair 2 Regret ************" << endl;
				solution_rebuilt = two_regret_repair_aggragati(end_day, route_destroy, map_airplane, passenger_removed, map_airstrip, from_to, location_fuel, from_to_FuelConsumed);
				choosen_repair = 2;
			}
			else if (repair_choice < Accumulated(3, Weigth_repair)) {
				cout << "*************** I am using the Repair Forbidden ************" << endl;
				solution_rebuilt = repair_forbidden(end_day, route_destroy, map_airplane, passenger_removed, map_airstrip, from_to, location_fuel, from_to_FuelConsumed);
				choosen_repair = 3;
			}
			else {
				cout << "*************** I am using the Repair Perturbation ************" << endl;
				solution_rebuilt = repair_perturbation(end_day, route_destroy, map_airplane, passenger_removed, map_airstrip, from_to, location_fuel, from_to_FuelConsumed);
				choosen_repair = 4;
			}
			auto stop_r = chrono::high_resolution_clock::now();
			auto duration_r = chrono::duration_cast<chrono::seconds>(stop_r - start_r);
			double time_spent_r = Time_Spend((double)duration_r.count());
			//cout << " Tempo Repair vero: " << duration_r.count() << " ma corrisponde al valore trasformato in double conn rapporto = " << time_spent_r << endl;
			cout << "***********************END REBUILT***********************" << endl;
			//cout << "ho appena fatto la riparazione" << endl;
			//stampo_caso_strano(solution_rebuilt, from_to, map_airplane);
			//for(Route p : solution_rebuilt) p.print();
			//cout << " ******** SIZE DI SOLUTION REBUILD ******* " << solution_rebuilt.size() << endl;
			if (solution_rebuilt.size() > 0) {
				double initial_cost = calculate_ObjectiveFunction(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
				cout << "Cost of the solution rebuilt: " << initial_cost << endl;
				//vector<Route> solution_rebuilt_without_LS = solution_rebuilt;
				//cout << "sto iniziando il move" << endl;
				solution_rebuilt = move(solution_rebuilt, map_airplane, map_airstrip, end_day, from_to, location_fuel, from_to_FuelConsumed);
				//cout << "ho appena fatto il move" << endl;
				//stampo_caso_strano(solution_rebuilt, from_to, map_airplane);
				//cout << "Cost of the solution rebuilt after Move: " << calculate_ObjectiveFunction(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
				solution_rebuilt = swap(solution_rebuilt, map_airplane, map_airstrip, end_day, from_to, location_fuel, from_to_FuelConsumed);
				//cout << "ho appena fatto lo swap" << endl;
				//stampo_caso_strano(solution_rebuilt, from_to, map_airplane);
				//cout << "Cost of the solution rebuilt after Move + Swap: " << calculate_ObjectiveFunction(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
				if (initial_cost == calculate_ObjectiveFunction(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed)) {
					solution_rebuilt = inter_move(solution_rebuilt, map_airplane, map_airstrip, end_day, from_to, location_fuel, from_to_FuelConsumed);
					//cout << "ho appena fatto lo inter move" << endl;
					//stampo_caso_strano(solution_rebuilt, from_to, map_airplane);
					//cout << "Cost of the solution rebuilt after Move + Swap: " << calculate_ObjectiveFunction(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
				}
				solution_rebuilt = heuristic_costructive_second_fase(solution_rebuilt, end_day);
				double cost_objectiveFunction_second_fase_after_rebuilt = calculate_ObjectiveFunction(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
				cout << "Cost of the solution rebuilt with Move + Swap + Second phase: " << cost_objectiveFunction_second_fase_after_rebuilt << endl;
				//if (cost_objectiveFunction_second_fase_after_rebuilt < initial_cost) solutionAll.push_back(solution_rebuilt_without_LS);
				//cout << "costo routing: " << costo_senza_time_windows(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
				//cout << "costo time windows: " << costo_time_windows(solution_rebuilt, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
				if (cost_objectiveFunction_second_fase_after_rebuilt < start_solution) {
					//cout << "Ottimo aggiorno la soluzione da cui continuare a fare perturbazioni " << endl;
					start_solution_route.clear();
					start_solution_route.shrink_to_fit();
					//cout << " Ho cancellato " << endl;
					//cout << " Adesso ho azzerato start_solution_route stampo la size: " << start_solution_route.size() << endl;
					for (Route so : solution_rebuilt) start_solution_route.push_back(so);
					//cout << " Adesso ho aggiornato start_solution_route stampo la size: " << start_solution_route.size() << endl;
					double award = Ob_Funct_Improvement(cost_objectiveFunction_second_fase_after_rebuilt, start_solution);
					//cout << " Con un miglioramento di " << start_solution - cost_objectiveFunction_second_fase_after_rebuilt << " si ha un award di " << award << endl;
					//cout << " ed un fattore tempo di Destroy di " << time_spent << endl;
					//cout << " ed un fattore tempo di Repair di " << time_spent_r << endl;
					start_solution = cost_objectiveFunction_second_fase_after_rebuilt;
					iteration = 0;
					//cout << " Aggiungo al destroy ad al Repair 1 + award =  " << award << endl;
					Weigth_destroy[choosen_destroy] += (1 + award - time_spent);
					Weigth_repair[choosen_repair] += (1 + award - time_spent_r);
					if (cost_objectiveFunction_second_fase_after_rebuilt < best_solution) {
						//cout << "Aggiorno migliore soluzione " << endl;
						best_solution_route.clear();
						best_solution_route.shrink_to_fit();
						for (Route s : solution_rebuilt) best_solution_route.push_back(s);
						best_solution = cost_objectiveFunction_second_fase_after_rebuilt;
						best_iteration = iteration;
						start_route_bs = (int)solutionAll.size();
						size_route_bs = (int)solution_rebuilt.size();
						//cout << " Ho aggiornato la migliore soluzione le route adesso si trovano nella posizione: " << start_route_bs << " con size: " << size_route_bs << endl;
						//system("pause");
					}
				}
				else {

					r = double(rand()) / (double(RAND_MAX) + 1.0);
					//cout << " Ho generato numero random " << r << endl;
					//cout << "-( " << cost_objectiveFunction_second_fase_after_rebuilt << " - " << start_solution << ") / " << T;
					double espo = -(cost_objectiveFunction_second_fase_after_rebuilt - start_solution) / T;
					//cout << " Adesso ho generato espo " << espo << endl;
					//cout << " Se non lo è devo incrementare iterazione se lo è aggiorno valori X con X'  " << endl;
					if (r <= exp(espo) && exp(espo) != 1) {
						//cout << "Confrona i costi sono entrato perche: " << r << " < " << exp(espo) << endl;
						start_solution_route.clear();
						start_solution_route.shrink_to_fit();
						//cout << " Ho cancellato " << endl;
						//cout << " Adesso ho azzerato start_solution_route stampo la size: " << start_solution_route.size() << endl;
						for (Route s : solution_rebuilt) start_solution_route.push_back(s);
						//cout << " Adesso ho aggiornato start_solution_route stampo la size: " << start_solution_route.size() << endl;
						start_solution = cost_objectiveFunction_second_fase_after_rebuilt;
						iteration = 0;
						Weigth_destroy[choosen_destroy] ++;
						Weigth_repair[choosen_repair] ++;
					}
					else {
						iteration++;
					}
				}
				solutionAll.push_back(solution_rebuilt);
				cout << " Pool per modello adesso contiene  numero di soluzioni ---> " << solutionAll.size() << endl;
			}
			else {
				cout << " ************ ITERAZIONE FALLITA ************************* " << endl;
			}
			k++;
			//cout << " Valore attuale di K = " << k << " aggiorno temperatura dopo: " << DeltaK << endl;
			if (k >= DeltaK) {
				T = (int)(alpha * T);
				//cout << " Aggiorno temperatura A: " << T << endl;
				k = 0;
			}
			cout << " A T < " << Tmin << " devi fermarti T= " << T << " or " << iteration << " > " << iteration_max << " Ciclo Grande fuori iterazione ------> " << Iter_FirstDo << endl;
		} while ((iteration <= iteration_max) && (T > Tmin));


		// FINITO IL CICLO DELLA PERTURBAZIONE STAMPA RISULTATI

		cout << ".........Build all the structure for the Model........." << endl;
		auto start_model = chrono::high_resolution_clock::now();
		vector<Airplane> airplanes_model;
		for (auto k : map_airplane) {
			airplanes_model.push_back(k.second);
		}
		map<string, vector<Route>> airplane_routes;
		map<string, int> solution_warm_up;
		for (Airplane a : airplanes_model) {
			vector<Route> routes;
			airplane_routes.insert(make_pair(a.code, routes));
		}
		int counter = 0;
		for (vector<Route> solution : solutionAll) {
			if (counter == start_route_bs) {
				for (Route r : solution) {
					solution_warm_up[r.aircraft_code] = (int)(airplane_routes[r.aircraft_code].size());
					airplane_routes[r.aircraft_code].push_back(r);
				}
			}
			else {
				for (Route r : solution) {
					airplane_routes[r.aircraft_code].push_back(r);
				}
			}

			counter++;
		}

		cout << " CHECK SE LA MAPPA CHE HO CREATO VA BENE " << endl;
		vector<Route> Prova;
		for (auto a : airplane_routes) {
			if (solution_warm_up.find(a.first) != solution_warm_up.end()) {
				cout << " Aereo: " << a.first << endl;
				Prova.push_back(a.second[solution_warm_up[a.first]]);

			}
		}
		cout << " il costo della soluzione che mi sono salvato nella mappa: " << calculate_ObjectiveFunction(Prova, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
		int n = 0;
		for (Route path : Prova) {
			path.print();
			n += (int)path.passengers_in_route.size();
		}
		cout << " Soluzione contiene numero di passeggieri pari a " << n << endl;
		//finito di fissare gli aerei
		vector<vector<vector<int>>> A3;  //matrix A
		vector<vector<double>> C;  //cost
		vector<Route> routes;
		for (auto airplane : airplanes_model) {
			//cout << "Airplane: " << airplane.code << endl;
			vector<double> c;
			vector<vector<int>> A2;
			for (Route r : airplane_routes[airplane.code]) {
				//r.print();
				routes.push_back(r);
				vector<int> A1;
				for (Passenger p : passengers) {
					auto it = find_if(r.passengers_in_route.begin(), r.passengers_in_route.end(),
						[=](Passenger p_)
					{
						return p.pnr == p_.pnr;
					});
					if (it != r.passengers_in_route.end())
					{
						A1.push_back(1);
					}
					else {
						A1.push_back(0);
					}
				}
				A2.push_back(A1);
				//cout << "- " << r.cost << endl;
				c.push_back(r.cost);
			}
			A3.push_back(A2);
			C.push_back(c);
		}
		//Creating model with gurobi
		//Create new Model object
		vector<Route> solution_modello;
		Model *model = new Model(A3, C, airplanes_model, airplane_routes, routes, (int)passengers.size(), passengers, solution_modello, map_airplane);
		//Create and solve model with gurobi
		model->create_Model_grb(number_airplane, solution_warm_up);
		cout << " Cost of the final solution  " << endl;
		start_solution_route.clear();
		start_solution_route.shrink_to_fit();
		for (Route s : model->solution_model) start_solution_route.push_back(s);
		start_solution = calculate_ObjectiveFunction(start_solution_route, map_airstrip, map_airplane, from_to, from_to_FuelConsumed);
		cout << " Costo del Modello che sarè nuovo costo di partenza = " << start_solution << endl;
		Iter_FirstDo++;
		cout << "*******************************************************************************************************************************************************" << endl;
		cout << " ********************************************** ITERATION WHILE: " << Iter_FirstDo << " OF: " << iterMAX_FirstDo << "**********************************" << endl;
		cout << "*******************************************************************************************************************************************************" << endl;
		auto stop_model = chrono::high_resolution_clock::now();
		auto duration_model = chrono::duration_cast<chrono::seconds>(stop_model - start_model);
	         time_spent_model += (double)duration_model.count();
		//cin.get();
	} while ((Iter_FirstDo <= iterMAX_FirstDo));

	cout << "Best solution herurisic: " << start_solution << endl;
	cout << "costo routing: " << costo_senza_time_windows(start_solution_route, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
	cout << "costo time windows: " << costo_time_windows(start_solution_route, map_airstrip, map_airplane, from_to) << endl;
	for (Route s : start_solution_route) cout << s.cost << " -- " << endl;
	//*********************************************************************************AGGREGAZIONE SEMPLICE***************************************************************
	cout << "ora faccio l'aggregazione semplice" << endl;
	start_solution_route = aggrezione_simple_after_model(start_solution_route, map_airplane, from_to);
	cout << calculate_ObjectiveFunction(start_solution_route, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
	cout << " Routing cost : " << costo_senza_time_windows(start_solution_route, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
	cout << " Time windows cost: " << costo_time_windows(start_solution_route, map_airstrip, map_airplane, from_to) << endl;
	stampo_caso_strano(start_solution_route, from_to, map_airplane);
	//*********************************************************************************AGGREGAZIONE COMPLESSA***************************************************************
	cout << "ora faccio l'aggregazione complessa" << endl;
	start_solution_route = aggrezione_complex_after_model(start_solution_route, map_airplane, from_to, from_to_FuelConsumed);
	cout << calculate_ObjectiveFunction(start_solution_route, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
	cout << " Routing cost : " << costo_senza_time_windows(start_solution_route, map_airstrip, map_airplane, from_to, from_to_FuelConsumed) << endl;
	cout << " Time windows cost: " << costo_time_windows(start_solution_route, map_airstrip, map_airplane, from_to) << endl;
	stampo_caso_strano(start_solution_route, from_to, map_airplane);
	//*********************************************************************************************************************************************************************
	cout << " ********** Final Weight ************ " << endl;
	cout << " Cluster || Worst || 2-Regret || Thanos " << endl;
	for (double i : Weigth_destroy) cout << i << " || ";
	cout << endl;
	cout << " One || SP || Regret || Forbidden ||Perturbation " << endl;
	for (double i : Weigth_repair) cout << i << " || ";
	cout << endl;
	tempo_finale = difftime(time(NULL), time_now);
	cout << "Time at the end: " << tempo_finale << endl;
	cout << "Time model: " << time_spent_model << endl;
	cout << "Numero SA= " << NumeroSA << endl;
	system("pause");
	return 0;
}

